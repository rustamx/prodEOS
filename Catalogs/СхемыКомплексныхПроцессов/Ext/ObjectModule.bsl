
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОписаниеПеременных_ВыполнениеПроцессаПоСхеме

Перем СтрокиТаблицыЭлементыСхемы;

Перем СтрокиТаблицыПараметрыДействий;

Перем СтрокиТаблицыПараметрыОбработок;

Перем СтрокиТаблицыПараметрыУсловий;

Перем ГрафическаяСхемаПроцесса;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Заполняет схему на основании другой.
// В текущей схеме обязательно должен быть заполнен ВладелецСхемы.
//
// Параметры:
//  СхемаОснование - СправочникСсылка.СхемыКомплексныхПроцессов - ссылка на схему основание.
//
Процедура ЗаполнитьНастройкиПоСхеме(СхемаОснование) Экспорт
	
	// Если в схеме не указан владелец, то не заполняем схему.
	Если Не ЗначениеЗаполнено(ВладелецСхемы) Тогда
		Возврат;
	КонецЕсли;
	
	СсылкаНаСхему = Ссылка;
	Если Не ЗначениеЗаполнено(СсылкаНаСхему) Тогда
		СсылкаНаСхему = Справочники.СхемыКомплексныхПроцессов.ПолучитьСсылку(
			Новый УникальныйИдентификатор);
		УстановитьСсылкуНового(СсылкаНаСхему);
	КонецЕсли;
	
	СхемаОбъектОснования = СхемаОснование.ПолучитьОбъект();
	
	ВладелецСхемыОснованияКомплексныйПроцесс = 
		(ТипЗнч(СхемаОбъектОснования.ВладелецСхемы) = Тип("БизнесПроцессСсылка.КомплексныйПроцесс"));
	
	ВладелецТекущейСхемыКомплексныйПроцесс =
		(ТипЗнч(ВладелецСхемы) = Тип("БизнесПроцессСсылка.КомплексныйПроцесс"));
	
	ГрафическаяСхемаПроцесса = СхемаОбъектОснования.Схема.Получить();
	
	// Скопируем таблицу элементов.
	Для Каждого СтрокаТаблицы Из СхемаОбъектОснования.ЭлементыСхемы Цикл
		
		ЭлементСхемы = ЭлементыСхемы.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементСхемы, СтрокаТаблицы,, "Пройден, Текущий");
		
		// Установим рамку для элементов по умолчанию.
		Если ВладелецСхемыОснованияКомплексныйПроцесс Тогда
			ЭлементГрафическойСхемы = 
				ГрафическаяСхемаПроцесса.ЭлементыГрафическойСхемы.Найти(СтрокаТаблицы.Имя);
			
			ЭлементГрафическойСхемы.Рамка = 
				РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.РамкаЭлементаПоУмолчанию();
		КонецЕсли;
		
		// Если текущая схема заполняется для комплексного процесса,
		// то отмечаем все элементы старта текущими.
		// По умолчанию запуск процесса выполняем с них.
		Если ВладелецТекущейСхемыКомплексныйПроцесс
			И СтрокаТаблицы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Старт Тогда
			
			ЭлементСхемы.Текущий = Истина;
			
			ЭлементГрафическойСхемы =
				ГрафическаяСхемаПроцесса.ЭлементыГрафическойСхемы.Найти(СтрокаТаблицы.Имя);
			
			ЭлементГрафическойСхемы.Рамка = 
				РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.РамкаТекущегоЭлемента();
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого СтрокаТаблицы Из СхемаОбъектОснования.ПредшественникиЭлементовСхемы Цикл
		
		ЗаполнитьЗначенияСвойств(ПредшественникиЭлементовСхемы.Добавить(), СтрокаТаблицы);
		
		// Установим выделение линии по умолчанию.
		Если ВладелецСхемыОснованияКомплексныйПроцесс Тогда
			ЭлементГрафическойСхемы = 
				ГрафическаяСхемаПроцесса.ЭлементыГрафическойСхемы.Найти(СтрокаТаблицы.ИмяСоединительнойЛинии);
			
			ЭлементГрафическойСхемы.Линия = 
				РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.РамкаЭлементаПоУмолчанию();
		КонецЕсли;
		
	КонецЦикла;
	
	ИдентификаторыСкриптов = Новый Массив;
	
	// Скопируем настройки условий и получим индентификаторы выражений на встроенном языке.
	Для Каждого СтрокаТаблицы Из СхемаОбъектОснования.ПараметрыУсловий Цикл
		ЗаполнитьЗначенияСвойств(ПараметрыУсловий.Добавить(), СтрокаТаблицы);
		
		НастройкиУсловия = СтрокаТаблицы.НастройкиУсловия.Получить();
		Если НастройкиУсловия <> Неопределено Тогда
			ПолучитьИдентификаторыВыражений(НастройкиУсловия.Отбор.Элементы, ИдентификаторыСкриптов);
		КонецЕсли;
	КонецЦикла;
	
	// Скопируем настройки обработок и дополним идентификаторы выражений на встроенном языке.
	Для Каждого СтрокаТаблицы Из СхемаОбъектОснования.ПараметрыОбработок Цикл
		ЗаполнитьЗначенияСвойств(ПараметрыОбработок.Добавить(), СтрокаТаблицы);
		ИдентификаторыСкриптов.Добавить(СтрокаТаблицы.ИдентификаторСкрипта);
	КонецЦикла;
	
	// Скопируем скрипты (выражения на встроенном языке) для новой схемы.
	УстановитьПривилегированныйРежим(Истина);
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	СкриптыСхемКомплексныхПроцессов.Схема,
		|	СкриптыСхемКомплексныхПроцессов.ИдентификаторСкрипта,
		|	СкриптыСхемКомплексныхПроцессов.Скрипт
		|ИЗ
		|	РегистрСведений.СкриптыСхемКомплексныхПроцессов КАК СкриптыСхемКомплексныхПроцессов
		|ГДЕ
		|	СкриптыСхемКомплексныхПроцессов.ИдентификаторСкрипта В(&ИдентификаторыСкриптов)
		|	И СкриптыСхемКомплексныхПроцессов.Схема = &СхемаОснование";
	Запрос.УстановитьПараметр("ИдентификаторыСкриптов", ИдентификаторыСкриптов);
	Запрос.УстановитьПараметр("СхемаОснование", СхемаОснование);
	Скрипты = Запрос.Выполнить().Выгрузить();
	
	Если Скрипты.Количество() > 0 Тогда
		Скрипты.ЗаполнитьЗначения(СсылкаНаСхему, "Схема");
		НаборЗаписей = 
			РегистрыСведений.СкриптыСхемКомплексныхПроцессов.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Схема.Установить(СсылкаНаСхему);
		
		НаборЗаписей.Загрузить(Скрипты);
		НаборЗаписей.Записать();
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);
	
	// Скопируем параметры действий.
	Для Каждого СтрокаТаблицы Из СхемаОбъектОснования.ПараметрыДействий Цикл
		
		ПараметрыДействия = ПараметрыДействий.Добавить();
		ЗаполнитьЗначенияСвойств(ПараметрыДействия, СтрокаТаблицы,, "Процесс, ШаблонПроцесса");
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.ШаблонПроцесса) Тогда
		
			КопируемыйШаблонОбъект = СтрокаТаблицы.ШаблонПроцесса.ПолучитьОбъект();
			
			ЗаполнитьИсходныйШаблон = Не ЗначениеЗаполнено(КопируемыйШаблонОбъект.КомплексныйПроцесс);
			
			КопируемыйШаблонОбъект.КомплексныйПроцесс = КомплексныйПроцесс;
			
			НовыйШаблон = КопируемыйШаблонОбъект.Скопировать();
			
			Если ЗаполнитьИсходныйШаблон Тогда
				НовыйШаблон.ИсходныйШаблон = КопируемыйШаблонОбъект.Ссылка;
			КонецЕсли;
			
			НовыйШаблон.ВладелецШаблона = ВладелецСхемы;
			
			НовыйШаблон.ШаблонВКомплексномПроцессе = Истина;
			НовыйШаблон.Ответственный = ПользователиКлиентСервер.ТекущийПользователь();
			
			ШаблоныБизнесПроцессов.ЗаписатьШаблон(НовыйШаблон,
				"ЗаписьСЗаполнениемСлужебныхРеквизитовКомплексныхПроцессов");
			
			ПараметрыДействия.ШаблонПроцесса = НовыйШаблон.Ссылка;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Схема = Новый ХранилищеЗначения(ГрафическаяСхемаПроцесса);
	ГрафическаяСхемаПроцесса = Неопределено;
	
КонецПроцедуры

// Обновляет порядок сортировки действий (ПорядокСортировки в табличной части ПараметрыДействий).
//
Процедура ОбновитьПорядокСортировкиДействий() Экспорт
	
	КэшСтрокТаблицыПараметрыДействий = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ПараметрыДействий Цикл
		СтрокаТаблицы.ПорядокСортировки = 0;
		КэшСтрокТаблицыПараметрыДействий.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы);
	КонецЦикла;
	
	// Найдем элемент старта.
	СтрокаЭлементаСхемы = 
		ЭлементыСхемы.Найти(Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Старт, "Тип");
	
	// Если элемента старта не найден, то прекращаем обновление порядка.
	Если СтрокаЭлементаСхемы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПоследнийПорядковыйНомерДействия = 0;
	
	// Обновляем порядок действий.
	ОбновитьПорядокСортировкиПоследующихДействий(
		СтрокаЭлементаСхемы.Имя, ПоследнийПорядковыйНомерДействия, КэшСтрокТаблицыПараметрыДействий);
		
	// Заполняем порядок сортировки для действий, не попавших ни в один путь.
	// Это нужно, чтобы не было действий с пустым порядком.
	// Пустой порядок является условием завершения отложенного обработчика обновления
	// порядка сортировки.
	Для Каждого СтрокаТаблицы Из ПараметрыДействий Цикл
		Если ЗначениеЗаполнено(СтрокаТаблицы.ПорядокСортировки) Тогда
			Продолжить;
		КонецЕсли;
		СтрокаТаблицы.ПорядокСортировки = 1;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ПрограммныйИнтерфейс_ВыполнениеПроцессаПоСхеме

// Находит элемент старта в схеме процесса и запускает его обработку.
//
// Параметры:
//  ФормируемыеБизнесПроцессы
//   * БазнесПроцесОбъект - Массив - массив созданных бизнеспроцессов в ходе обработки.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - объект запускаемого комплексного процесса.
//
Процедура СтартоватьПроцессПоСхеме(ФормируемыеБизнесПроцессы, Процесс) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(ВладелецСхемы) <> Тип("БизнесПроцессСсылка.КомплексныйПроцесс") Тогда
		Возврат;
	КонецЕсли;
	
	ИнициализироватьПеременныеДляМаршрутизации();
	
	// Ищем элементы отмеченные текущими и запускаем их обработку.
	Отбор = Новый Структура;
	Отбор.Вставить("Текущий", Истина);
	НайденныеЭлементы = ЭлементыСхемы.НайтиСтроки(Отбор);
	
	// Если текущих элементов нет, не стартуем процесс,
	// т.к. запускать нечего.
	Если НайденныеЭлементы.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'В процессе нет ни одного текущего элемента. Запуск процесса невозможен.'; en = 'No current items in process. It is impossible to start the process.'");
	КонецЕсли;
	
	// Запускаем обработку элементов.
	ОбработатьЭлементыСхемыПроцесса(НайденныеЭлементы, ФормируемыеБизнесПроцессы, Процесс);
	
	// Запишем информацию о пройденных элементах в схеме процесса.
	ЗаписатьСхемуПроцесса();
	
КонецПроцедуры

// Продолжает выполнение процесса по схеме, после завершенного действия.
//
// Если не указано завершенное действие, то происходит поиск и попытка обработки
// текущих элементов.
//
// Параметры:
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - объект запускаемого комплексного процесса.
//  ЗавершенноеДействие - БизнесПроцессСсылка - ссылка на действие комплексного процесса.
//
Процедура ПродолжитьВыполнениеПроцессаПоСхеме(Процесс, ЗавершенноеДействие = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(ВладелецСхемы) <> Тип("БизнесПроцессСсылка.КомплексныйПроцесс") Тогда
		Возврат;
	КонецЕсли;
	
	ИнициализироватьПеременныеДляМаршрутизации();
	
	ОчередьЭлементовСхемы = Новый Массив;
	
	Если ЗначениеЗаполнено(ЗавершенноеДействие) Тогда
	
		// Получим параметры действия из схемы процесса.
		ПараметрыДействия = ПараметрыДействий.Найти(ЗавершенноеДействие, "Процесс");
	
		// Установим признак прохождения элемента.
		УстановитьПризнакПрохожденияЭлемента(ПараметрыДействия.Имя, Истина);
		
		// Добавим последователей действия в очередь.
		ДобавитьВОчередьЭлементыПослеЗавершенногоДействия(ПараметрыДействия.Имя, ОчередьЭлементовСхемы);
		
	Иначе
		
		// Находим все текущие элементы и помещаем их в очередь для обработки (ОчередьЭлементовСхемы).
		Для Каждого СтрокаТаблицы Из СтрокиТаблицыЭлементыСхемы Цикл
			Если Не СтрокаТаблицы.Значение.Текущий Тогда
				Продолжить;
			КонецЕсли;
			ОчередьЭлементовСхемы.Добавить(СтрокаТаблицы.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ОчередьЭлементовСхемы.Количество() > 0 Тогда
	
		// Запустим обработку следующих элементов схемы.
		ФормируемыеБизнесПроцессы = Новый Массив;
		ОбработатьЭлементыСхемыПроцесса(ОчередьЭлементовСхемы, ФормируемыеБизнесПроцессы, Процесс);
		
		// Стартуем сформированные процессы, в ходе обработке схемы элементов.
		СтартоватьПроцессыДействий(ФормируемыеБизнесПроцессы, Процесс);
		
	КонецЕсли;
	
	// Запишем информацию о стартованных и выполненных действиях.
	ЗаписатьСхемуПроцесса();
	
КонецПроцедуры

#КонецОбласти

#Область ПрограммныйИнтерфейс_ПроверкаКорректностиСхемы

// Выполняет проверку корректности схемы.
//
// Возвращаемое значение:
//  Структура
//   * СхемаКорректна - Булево - признак корректности схемы.
//   * ОписаниеОшибки - Строка - текст ошибки, если схема некорректна.
//   * ИмяЭлемента - Строка - имя элемента, связанного с ошибкой.
//
Функция СхемаКорректна() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатПроверки = Новый Структура;
	РезультатПроверки.Вставить("НетОшибок", Истина);
	РезультатПроверки.Вставить("ОписаниеОшибки", "");
	РезультатПроверки.Вставить("ИмяЭлемента", "");
	
	СтруктураДляПроверки = СтруктураДляПроверкиСхемы();
	ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки);
	ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки);
	СформироватьПутиПоСхеме(СтруктураДляПроверки);
	ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки);
	ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки);
	
	ЭлементыГрафическойСхемы = СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы;
	
	Если СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент старта может быть только один.'; en = 'There must be the single start element.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовСтарта = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента старта.'; en = 'No start elements.'");
		
		// IDS_NO_START_POINT
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент завершения может быть только один.'; en = 'There must be the single end element.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента завершения.'; en = 'No end elements.'");
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНедопустимогоЭлемента) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(СтруктураДляПроверки.ИмяНедопустимогоЭлемента);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Схема содержит недопустимый элемент: ""%1"".'; en = 'The diagram contains an invalid element: ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНедопустимогоЭлемента;
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Соединительная линия ""%1"" не присоединена ни к одному элементу схемы.'; en = 'Connecting line ""%1"" is not attached to any element of the diagram.'"),
			СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии;
		
		// IDS_NOT_CONNECTED_TO_ANY_POINT
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет ни одной входящей линии.'; en = '""%1"" element has no incoming lines.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний;
		
		// IDS_STR_HAS_NO_START
		
	ИначеЕсли СтруктураДляПроверки.СложнаяКарта Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Проверка карты схемы процесса не выполнена, т.к. она слишком сложная.'; en = 'Failed to check the process diagram because it is too complex.'");
		
		// IDS_TOO_COMPLEX_MAP
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаОбрыва) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаОбрыва);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет пути к завершению схемы.'; en = '""%1"" element is not connected to the end of the diagram.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаОбрыва;
		
		// IDS_HAS_NO_PATH
		
	ИначеЕсли СтруктураДляПроверки.НетЗавершенныхПутей Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'В схеме нет ни одного завершенного пути.'; en = 'The diagram has no completed routes.'");
		
		// IDS_STR_NO_ROUTE
		
	ИначеЕсли СтруктураДляПроверки.ЕстьЦиклыБезДействий Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Есть циклы не имеющие ни одного действия/вложенного процесса.'; en = 'There are loops without conditions or processes nested into them'");
		
		// IDS_STR_HAS_CYCLES_WITHOUT_ROUTE_POINTS
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В элемент ""%1"" невозможно попасть.'; en = '""%1"" element is unreachable.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть;
		
		// IDS_STR_UNREACHABLE_CODE
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В схеме есть зацикливание: %1'; en = 'The diagram contains a loop: %1'"),
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение);
		
		// IDS_FOUND_CYCLING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У разделения ""%1"" есть только одна исходящая линия.'; en = 'Forking ""%1"" has only one outgoing line.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией;
		
		// IDS_STR_ONLY_ONE_OUTGOING_LINE_FROM_BRANCHING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя из разделения ""%1"" нескольким исходящим линиями входить в один и тот же элемент.'; en = 'Lines coming out of forking ""%1"" cannot enter the same element.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент;
		
		// IDS_STR_BRANCHING_SAME_NEXT_POINT
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСОднойВходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У слияния ""%1"" есть только одна входящая линия.'; en = 'Merging ""%1"" has only one incoming line.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСОднойВходящейЛинией;
		
		// IDS_STR_ONLY_ONE_INCOMING_LINE_INTO_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеБезРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеБезРазделения);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Не все линии, вошедшие слияние ""%1"" вышли из разделения.'; en = 'Not all the lines merged in ""%1"" came out of it.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеБезРазделения;
		
		// IDS_STR_GATHERING_MISMATCH
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСразуПослеРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСразуПослеРазделения);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя сразу из разделения ""%1"" попадать в слияние.'; en = 'It is forbidden to proceed to merging rightaway from forking ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСразуПослеРазделения;
		
		// IDS_STR_BRANCHING_IMMEDIATELY_AFTER_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЭлементПересеченияРазделений) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ЭлементПересеченияРазделений);
		НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Запрещено распараллеленным веткам входить в один и то же элемент ""%1"".'; en = 'Parallel branches cannot enter the same element (""%1"").'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ЭлементПересеченияРазделений;
		
		// IDS_STR_BRANCHING_MERGE
		
	КонецЕсли;
	
	Возврат РезультатПроверки
	
КонецФункции

#КонецОбласти

#Область ОбработчикиСобытий

Процедура ПередЗаписью(Отказ)
	
	Если ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	ОбновитьПорядокСортировкиДействий();
	
	Если Не ЭтоНовый() Тогда
		СтараяПометкаУдаления = 
			ОбщегоНазначенияДокументооборот.ЗначениеРеквизитаОбъектаВПривилегированномРежиме(
				Ссылка, "ПометкаУдаления");
		
		ДополнительныеСвойства.Вставить("СтараяПометкаУдаления", СтараяПометкаУдаления);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПриЗаписи(Отказ)
	
	Если ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Установим пометку удаления подчиненным шаблонам и процессам.
	Если ДополнительныеСвойства.Свойство("СтараяПометкаУдаления")
		И ДополнительныеСвойства.СтараяПометкаУдаления <> ПометкаУдаления Тогда
		
		Для Каждого ПараметрыДействия Из ПараметрыДействий Цикл
			
			Если ЗначениеЗаполнено(ПараметрыДействия.ШаблонПроцесса) Тогда
				ПараметрыДействия.ШаблонПроцесса.ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
			КонецЕсли;
			
			Если ЗначениеЗаполнено(ПараметрыДействия.Процесс) Тогда
				ПараметрыДействия.Процесс.ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Прерываем отмеченные процессы.
	// Наличие доп. свойства ПроцессыСхемыДляПрерывания говорит о том, что
	// в схеме интерактивно были отмечены процессы для прерывания.
	ПроцессыСхемыДляПрерывания = Неопределено;
	ДополнительныеСвойства.Свойство("ПроцессыСхемыДляПрерывания", ПроцессыСхемыДляПрерывания);
	
	Если ЗначениеЗаполнено(ПроцессыСхемыДляПрерывания) Тогда
		
		ПричинаПрерыванияПроцессовСхемы = "";
		Если ДополнительныеСвойства.Свойство("ПричинаПрерыванияПроцессовСхемы") Тогда
			ПричинаПрерыванияПроцессовСхемы = ДополнительныеСвойства.ПричинаПрерыванияПроцессовСхемы;
		КонецЕсли;
		
		Для Каждого ПроцессДляПрерывания Из ПроцессыСхемыДляПрерывания Цикл
			
			РеквизитыПроцесса = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
				ПроцессДляПрерывания.Значение, "Ссылка, ВедущаяЗадача, Состояние");
			
			Если РеквизитыПроцесса.Состояние = Перечисления.СостоянияБизнесПроцессов.Прерван Тогда
				Продолжить;
			КонецЕсли;
			
			БизнесПроцессыИЗадачиВызовСервера.ПрерватьБизнесПроцесс(
				РеквизитыПроцесса.Ссылка, ПричинаПрерыванияПроцессовСхемы);
			
			ВедущаяЗадачаОбъект = РеквизитыПроцесса.ВедущаяЗадача.ПолучитьОбъект();
			ВедущаяЗадачаОбъект.Выполнена = Истина;
			РаботаСБизнесПроцессами.ЗаписатьЗадачу(ВедущаяЗадачаОбъект, "ПростаяЗапись");
			
			ПротоколированиеРаботыПользователей.ЗаписатьПрерываниеБизнесПроцесса(РеквизитыПроцесса.Ссылка);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Получает идентификаторы выражений из элементов отбора компоновщика.
//
// Параметры:
//  ЭлементыОтбораКомпоновщика - КоллекцияЭлементовОтбораКомпоновкиДанных - элементы отбора.
//  ИдентификаторыВыражений - Массив - в этот параметр помещаются найденные идентификаторы.
//
Процедура ПолучитьИдентификаторыВыражений(ЭлементыОтбораКомпоновщика, ИдентификаторыВыражений)
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбораКомпоновщика Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			Если ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВыражениеНаВстроенномЯзыке") Тогда
				ИдентификаторыВыражений.Добавить(ЭлементОтбора.ПравоеЗначение.Выражение);
			КонецЕсли;
		Иначе
			ПолучитьИдентификаторыВыражений(ЭлементОтбора.Элементы, ИдентификаторыВыражений);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Обновляет порядок сортировки последующих действий после элемента.
// Рекурсивная процедура. Используется в ОбновитьПорядокСортировкиДействий.
//
// Параметры:
//  ИмяЭлемента - Строка - имя элемента в схеме процесса.
//  ПоследнийПорядковыйНомерДействия - Число - последний присвоенный порядковый номер действия.
//  КэшСтрокТаблицыПараметрыДействий - Соотвествие - кэш строк табличной части ПараметрыДействий.
//   * Ключ - Строка - имя элемента-действия.
//   * Значение - СтрокаТабличнойЧасти - строка ПараметрыДействий.
//
Процедура ОбновитьПорядокСортировкиПоследующихДействий(
	ИмяЭлемента, ПоследнийПорядковыйНомерДействия, КэшСтрокТаблицыПараметрыДействий)
	
	Отбор = Новый Структура;
	Отбор.Вставить("ИмяПредшественника", ИмяЭлемента);
	
	ЭлементыПоследователи = ПредшественникиЭлементовСхемы.НайтиСтроки(Отбор);
	
	Для Каждого СтрокаТаблицы Из ЭлементыПоследователи Цикл
		
		ПараметрыДействия = КэшСтрокТаблицыПараметрыДействий.Получить(СтрокаТаблицы.Имя);
		
		Если ПараметрыДействия <> Неопределено Тогда
			
			Если ЗначениеЗаполнено(ПараметрыДействия.ПорядокСортировки) Тогда
				Продолжить;
			КонецЕсли;
			
			ПоследнийПорядковыйНомерДействия = ПоследнийПорядковыйНомерДействия + 1;
			ПараметрыДействия.ПорядокСортировки = ПоследнийПорядковыйНомерДействия;
			
		КонецЕсли;
		
		ОбновитьПорядокСортировкиПоследующихДействий(
			СтрокаТаблицы.Имя, ПоследнийПорядковыйНомерДействия, КэшСтрокТаблицыПараметрыДействий);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ВыполнениеПроцессаПоСхеме

// Инициализирует переменные схемы для маршрутизации процесса.
// Заполняет переменные модуля:
//  СхемаОбъект
//  СтрокиТаблицыЭлементыСхемы
//  СтрокиТаблицыПараметрыДействий
//  СтрокиТаблицыПараметрыУсловий
//  ГрафическаяСхемаПроцесса
//
Процедура ИнициализироватьПеременныеДляМаршрутизации()
	
	УстановитьПривилегированныйРежим(Истина);
	
	СтрокиТаблицыЭлементыСхемы = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ЭлементыСхемы Цикл
		СтрокиТаблицыЭлементыСхемы.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы);
	КонецЦикла;
	
	СтрокиТаблицыПараметрыДействий = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ПараметрыДействий Цикл
		СтрокиТаблицыПараметрыДействий.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы);
	КонецЦикла;
	
	СтрокиТаблицыПараметрыОбработок = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ПараметрыОбработок Цикл
		СтрокиТаблицыПараметрыОбработок.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы);
	КонецЦикла;
	
	СтрокиТаблицыПараметрыУсловий = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ПараметрыУсловий Цикл
		СтрокиТаблицыПараметрыУсловий.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы);
	КонецЦикла;
	
	ГрафическаяСхемаПроцесса = Схема.Получить();
	
КонецПроцедуры

// Записывает схему (переменная СхемаОбъект) в базу.
//
Процедура ЗаписатьСхемуПроцесса()
	
	Схема = Новый ХранилищеЗначения(ГрафическаяСхемаПроцесса);
	Записать();
	
КонецПроцедуры

// Вовращает предшественников элемента.
//
// Параметры:
//  ИмяЭлемента - Строка - имя элемента последователя.
//
// Возвращаемое значение:
//  Массив
//   * СтрокаТаблицыЗначений - массив строк табличной части ПредшественникиЭлементовСхемы.
//
Функция ПредшественникиЭлементаСхемы(ИмяЭлемента)
	
	Отбор = Новый Структура;
	Отбор.Вставить("Имя", ИмяЭлемента);
	
	Возврат ПредшественникиЭлементовСхемы.НайтиСтроки(Отбор);
	
КонецФункции

// Вовращает последователей элемента.
//
// Параметры:
//  ИмяЭлемента - Строка - имя элемента предшественника.
//
// Возвращаемое значение:
//  Массив
//   * СтрокаТаблицыЗначений - массив строк табличной части ПредшественникиЭлементовСхемы схемы процесса.
//
Функция ПоследователиЭлементаСхемы(ИмяЭлемента)
	
	Отбор = Новый Структура;
	Отбор.Вставить("ИмяПредшественника", ИмяЭлемента);
	
	Возврат ПредшественникиЭлементовСхемы.НайтиСтроки(Отбор);
	
КонецФункции

// Устанавливает признак прохождения элемента.
//
// Параметры:
//  ИмяЭлемента - Строка - имя элемента в схеме.
//  Пройден - Булево - устанавливаемый признак.
//
Процедура УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Пройден)
	
	СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(ИмяЭлемента);
	СтрокаЭлемента.Пройден = Пройден;
	СтрокаЭлемента.Текущий = Не Пройден;
	
	Если СтрокаЭлемента.Текущий Тогда
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.УстановитьОтметкуТекущегоЭлементаВСхеме(
			ГрафическаяСхемаПроцесса, ИмяЭлемента);
	Иначе
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.УстановитьОтметкуПройденногоЭлементаВСхеме(
			ГрафическаяСхемаПроцесса, ИмяЭлемента, Пройден);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает признак прохождения для соединительной линии.
//
// Параметры:
//  ИмяЛинии - Строка - имя соединительной линии.
//
Процедура ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ИмяЛинии)
	
	Если Не ЗначениеЗаполнено(ИмяЛинии) Тогда
		Возврат;
	КонецЕсли;
	
	ЭлементГрафическойСхемы = ГрафическаяСхемаПроцесса.ЭлементыГрафическойСхемы.Найти(ИмяЛинии);
	
	ЭлементГрафическойСхемы.Линия = 
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.РамкаПройденногоЭлемента();
	
КонецПроцедуры

// Выполняет обработку элементов схемы процесса, в зависимости от типа.
//
// Параметры:
//  ОчередьЭлементовСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы схемы процесса.
//  ФормируемыеБизнесПроцессы
//   * БазнесПроцесОбъект - Массив - массив созданных бизнеспроцессов в ходе обработки.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - процесс-объект владельца схемы.
//
Процедура ОбработатьЭлементыСхемыПроцесса(
	ОчередьЭлементовСхемы, ФормируемыеБизнесПроцессы, Процесс)
	
	// Обработка элементов карты маршрута
	// Очередь элементов обрабатываем в таком порядке:
	// 1. В начале действия или вложенные процессы.
	// 2. После обработки.
	// 3. Условия.
	// 4. Разделения.
	// 5. Слияния.
	// 6. Остальные элементы.
	// Порядок обусловлен особенностями работы элементов. Условия,
	// разделения и слияния должны учитывать актуальные данные действий.
	
	
	Пока ОчередьЭлементовСхемы.Количество() > 0 Цикл
		
		// Сворачиваем очередь элементов, чтобы не обрабатывать 2 раза один и те же элементы.
		// Такое возможно если несколько соединительных линий элементов схемы сходятся в слияние.
		// Слияние сработает один раз после всех действий, обработок, условий и разделений. При этом
		// будут учитываться все актуальные данные.
		ОчередьЭлементовСхемы = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ОчередьЭлементовСхемы);
		
		ИндексСледующегоДействия = Неопределено;
		ИндексСледующейОбработки = Неопределено;
		ИндексСледующегоУсловия = Неопределено;
		ИндексСледующегоРазделения = Неопределено;
		ИндексСледующегоСлияния = Неопределено;
		
		Для ИндексЭлемента = 0 По ОчередьЭлементовСхемы.Количество() - 1 Цикл
			
			Если ИндексСледующегоДействия = Неопределено
				
				И (ОчередьЭлементовСхемы[ИндексЭлемента].Тип = 
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Действие
					
					Или ОчередьЭлементовСхемы[ИндексЭлемента].Тип =
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.ВложенныйПроцесс) Тогда
				
				ИндексСледующегоДействия = ИндексЭлемента;
			КонецЕсли;
			
			Если ИндексСледующейОбработки = Неопределено
				И ОчередьЭлементовСхемы[ИндексЭлемента].Тип = 
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Обработка Тогда
				
				ИндексСледующейОбработки = ИндексЭлемента;
			КонецЕсли;
			
			Если ИндексСледующегоУсловия = Неопределено
				И ОчередьЭлементовСхемы[ИндексЭлемента].Тип = 
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Условие Тогда
				
				ИндексСледующегоУсловия = ИндексЭлемента;
			КонецЕсли;
			
			Если ИндексСледующегоРазделения = Неопределено
				И ОчередьЭлементовСхемы[ИндексЭлемента].Тип = 
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Разделение Тогда
				
				ИндексСледующегоРазделения = ИндексЭлемента;
			КонецЕсли;
			
			Если ИндексСледующегоСлияния = Неопределено
				И ОчередьЭлементовСхемы[ИндексЭлемента].Тип = 
					Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Слияние Тогда
				
				ИндексСледующегоСлияния = ИндексЭлемента;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ИндексСледующегоДействия <> Неопределено Тогда
			ИндексЭлементаДляОбработки = ИндексСледующегоДействия;
		ИначеЕсли ИндексСледующейОбработки <> Неопределено Тогда
			ИндексЭлементаДляОбработки = ИндексСледующейОбработки;
		ИначеЕсли ИндексСледующегоУсловия <> Неопределено Тогда
			ИндексЭлементаДляОбработки = ИндексСледующегоУсловия;
		ИначеЕсли ИндексСледующегоРазделения <> Неопределено Тогда
			ИндексЭлементаДляОбработки = ИндексСледующегоРазделения;
		ИначеЕсли ИндексСледующегоСлияния <> Неопределено Тогда
			ИндексЭлементаДляОбработки = ИндексСледующегоСлияния;
		Иначе
			ИндексЭлементаДляОбработки = 0;
		КонецЕсли;
		
		// Берем элемент для обработки
		ЭлементСхемы = ОчередьЭлементовСхемы[ИндексЭлементаДляОбработки];
		
		// Выполняем обработку в зависимости от типа элемента.
		Если ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Старт Тогда
			ОбработатьЭлементСтартаСхемыПроцесса(ЭлементСхемы.Имя, ОчередьЭлементовСхемы);
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Действие
			Или ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.ВложенныйПроцесс Тогда
			
			ОбработатьЭлементДействиеСхемыПроцесса(
				ЭлементСхемы.Имя, ФормируемыеБизнесПроцессы, Процесс, ОчередьЭлементовСхемы);
			
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Обработка Тогда
			ОбработатьЭлементОбработкаСхемыПроцесса(ЭлементСхемы.Имя, ОчередьЭлементовСхемы, Процесс);
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Разделение Тогда
			ОбработатьЭлементРазделениеСхемыПроцесса(ЭлементСхемы.Имя, ОчередьЭлементовСхемы);
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Слияние Тогда
			ОбработатьЭлементСлияниеСхемыПроцесса(ЭлементСхемы.Имя, ОчередьЭлементовСхемы, Процесс);
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Условие Тогда
			ОбработатьЭлементУсловиеСхемыПроцесса(ЭлементСхемы.Имя, ОчередьЭлементовСхемы, Процесс);
		ИначеЕсли ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Завершение Тогда
			ОбработатьЭлементЗавершенияСхемыПроцесса(ЭлементСхемы.Имя);
		КонецЕсли;
		
		// Удаляем элемент из очереди обработки.
		ОчередьЭлементовСхемы.Удалить(ИндексЭлементаДляОбработки);
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет обработку элемента старта схемы процесса.
// Для элемента ищется его последователь и добавляется в ЭлементыСхемы.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в карте маршрута.
//  ЭлементыСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы.
//
Процедура ОбработатьЭлементСтартаСхемыПроцесса(ИмяЭлемента, ОчередьЭлементовСхемы)
	
	// Находим всех последователей текущего элемента.
	ПоследователиЭлемента = ПоследователиЭлементаСхемы(ИмяЭлемента);
	
	// Находим строку последователя в таблице ЭлементыСхемы
	// и помещаем его в очередь для обработки (ЭлементыСхемы).
	СтрокаПоследователя = СтрокиТаблицыЭлементыСхемы.Получить(ПоследователиЭлемента[0].Имя);
	ОчередьЭлементовСхемы.Добавить(СтрокаПоследователя);
	
	ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ПоследователиЭлемента[0].ИмяСоединительнойЛинии);
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

// Выполняет обработку элемента действия схемы процесса.
// Для элемента создается процесс и помещается в ФормируемыеБизнесПроцессы
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схемы.
//  ФормируемыеБизнесПроцессы - Массив
//   * БизнесПроцессОбъект - формируемые процессы по действию.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - процесс-объект владельца схемы.
//  ОчередьЭлементовСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы схемы процесса.
//
Процедура ОбработатьЭлементДействиеСхемыПроцесса(
	ИмяЭлемента, ФормируемыеБизнесПроцессы, Процесс, ОчередьЭлементовСхемы)
	
	// Находим параметры действия и создаем процесс для этого действия.
	ПараметрыДействия = СтрокиТаблицыПараметрыДействий.Получить(ИмяЭлемента);
	
	// Не обрабатываем элементы-действия, по которым есть незавершенные
	// и не прерванные процессы.
	Если ЗначениеЗаполнено(ПараметрыДействия.Процесс) Тогда
		
		РеквизитыПроцесса = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
			ПараметрыДействия.Процесс, "Завершен, Состояние");
		
		Если Не РеквизитыПроцесса.Завершен
			И РеквизитыПроцесса.Состояние <> Перечисления.СостоянияБизнесПроцессов.Прерван Тогда
		
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	/////////////////
	// Создаем процесс, по шаблону.
	
	РеквизтыШаблона = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		ПараметрыДействия.ШаблонПроцесса, "СрокОтложенногоСтарта, Автор");
	
	ОтложенныйСтартДействия = ЗначениеЗаполнено(РеквизтыШаблона.СрокОтложенногоСтарта);
	
	СтруктураПредметов = Мультипредметность.ПолучитьДанныеЗаполненияПредметовЭтапа(
		Процесс, ПараметрыДействия.Идентификатор, ПараметрыДействия.ШаблонПроцесса);
	
	МенеджерШаблона = ОбщегоНазначения.МенеджерОбъектаПоСсылке(ПараметрыДействия.ШаблонПроцесса);
	ИмяТипаПроцесса = МенеджерШаблона.ИмяПроцесса(ПараметрыДействия.ШаблонПроцесса);
	БизнесПроцесс = БизнесПроцессы[ИмяТипаПроцесса].СоздатьБизнесПроцесс();
	
	Если ЗначениеЗаполнено(РеквизтыШаблона.Автор) Тогда
		БизнесПроцесс.Автор = РеквизтыШаблона.Автор;
	Иначе
		БизнесПроцесс.Автор = Процесс.Автор;
	КонецЕсли;
	
	ПараметрыЗаполнения = Новый Структура();
	ПараметрыЗаполнения.Вставить("Шаблон", ПараметрыДействия.ШаблонПроцесса);
	ПараметрыЗаполнения.Вставить("Предметы", СтруктураПредметов.Предметы);
	БизнесПроцесс.Заполнить(ПараметрыЗаполнения);
	
	БизнесПроцесс.Дата = ТекущаяДатаСеанса();
	БизнесПроцесс.ДополнитьОписание(Процесс.Описание);
	БизнесПроцесс.Проект = Процесс.Проект;
	БизнесПроцесс.ПроектнаяЗадача = Процесс.ПроектнаяЗадача;
	
	ВПроцессеИспользуетсяСхемаБезДействий = 
		ТипЗнч(БизнесПроцесс) = Тип("БизнесПроцессОбъект.КомплексныйПроцесс")
		И ЗначениеЗаполнено(БизнесПроцесс.Схема)
		И Не Справочники.СхемыКомплексныхПроцессов.ВСхемеЕстьДействия(БизнесПроцесс.Схема);
	
	Если ВПроцессеИспользуетсяСхемаБезДействий Или ОтложенныйСтартДействия Тогда
		
		ВедущаяЗадачаДействия = Задачи.ЗадачаИсполнителя.СоздатьЗадачу();
		ВедущаяЗадачаДействия.Дата = ТекущаяДатаСеанса();
		ВедущаяЗадачаДействия.БизнесПроцесс = Процесс.Ссылка;
		ВедущаяЗадачаДействия.ТочкаМаршрута = БизнесПроцессы.КомплексныйПроцесс.ТочкиМаршрута.ВложенныйПроцесс;
		
		РаботаСКомплекснымиБизнесПроцессамиСерверПереопределяемый.СоздатьПроцессПоДействиюЗаполнениеВедущейЗадачи(
			Процесс, ВедущаяЗадачаДействия);
		
		ВедущаяЗадачаДействия.Записать();
		БизнесПроцесс.ВедущаяЗадача = ВедущаяЗадачаДействия.Ссылка;
		
	КонецЕсли;
	
	РаботаСКомплекснымиБизнесПроцессамиСерверПереопределяемый.СоздатьПроцессПоДействиюДоЗаписиПроцесса(
		Процесс, БизнесПроцесс);
	
	БизнесПроцесс.Записать();
	
	МультипредметностьКОРП.УдалитьДействиеКомплексногоПроцессаИзКэшаПредметовИУчастников(
		ПараметрыДействия.ШаблонПроцесса);
	
	РаботаСКомплекснымиБизнесПроцессамиСерверПереопределяемый.СоздатьПроцессПоДействиюПослеЗаписиПроцесса(
		Процесс, БизнесПроцесс);
	
	СписокПолей = БизнесПроцесс.ПолучитьСписокНезаполненныхПолейНеобходимыхДляСтарта();
	
	Если СписокПолей.Количество() > 0 Тогда
		
		Если (СписокПолей.Найти("Исполнитель") <> Неопределено 
			Или СписокПолей.Найти("Исполнители") <> Неопределено) Тогда
		
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Не определены исполнители следующего шага процесса (""%1"").
					|Обратитесь к автору процесса или к администратору.';
					|en = 'No performers are specified for the next step of the process (""%1"").
					|Contact the process author or the administrator.'"),
				БизнесПроцесс.Наименование);
			
		ИначеЕсли СписокПолей.Найти("Схема") <> Неопределено Тогда
			
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Схема действия (""%1"") настроена неверно.
					|Обратитесь к автору процесса или к администратору.';
					|en = 'Diagram action (""%1"") is configured incorrectly.
					|Contact the process author or the administrator.'"),
				БизнесПроцесс.Наименование);
			
		Иначе
			
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Имеются ошибки заполнения следующего действия (""%1"").
					|Обратитесь к автору процесса или к администратору.';
					|en = 'There are errors in the next action (""%1"").
					|Contact the process author or the administrator.'"),
				БизнесПроцесс.Наименование);
			
		КонецЕсли;
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	// Рассчитываем сроки исполнения действия в случае если оно стартует повторно (в цикле).
	// И в прошлый раз завершилось корректно.
	// Если прервано, то данные берутся из шаблона как есть.
	Если ПараметрыДействия.Процесс <> Неопределено
		И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ПараметрыДействия.Процесс, "Завершен") Тогда
		
		СрокиИсполненияПроцессовКОРП.РассчитатьСрокИсполненияДляНовогоПроцесса(БизнесПроцесс);
		РаботаСБизнесПроцессами.ЗаписатьПроцесс(БизнесПроцесс, "ЗаписьСОбновлениемОбщегоСпискаПроцессов");
	КонецЕсли;
	
	ПризнакПрохожденияЭлемента = Ложь;
	
	Если ОтложенныйСтартДействия Тогда
		
		Попытка
			БизнесПроцесс.ОтложенныйСтарт();
		Исключение
			
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Не удалось стартовать следующее действие ""%1"" комплексного процесса.
					|Обратитесь к автору процесса или к администратору';
					|en = 'Unable to start ""%1"" action of the composite process. 
					|Contact the process author or the administrator'"),
				БизнесПроцесс.Наименование);
			
			ВызватьИсключение ТекстОшибки;
			
		КонецПопытки;
		
	ИначеЕсли ВПроцессеИспользуетсяСхемаБезДействий Тогда
			
			// Если в схеме действия комплексного процесса нет подчиненных действий,
			// а есть только обработки, тогда отмечаем ведущую задачу выполненной и
			// стартуем действие.
			// При старте, выполнится и завершиться все действие сразу,
			// а выполненная задача не позволит инициировать маршрутизацию родительского процесса,
			// т.е. процесса с текущей схемой, в маршрутизации которого сейчас и выполняется действие.
			
			ВедущаяЗадачаДействия.Выполнена = Истина;
			ВедущаяЗадачаДействия.Записать();
			БизнесПроцесс.Старт();
			
			ПризнакПрохожденияЭлемента = Истина;
			
			// Добавим последователей действия в очередь.
			ДобавитьВОчередьЭлементыПослеЗавершенногоДействия(ИмяЭлемента, ОчередьЭлементовСхемы);
			
	Иначе
		// Созданный процесс добавляется в массив - для предоставления возможности
		// запуска процесса платформенной механикой.
		ФормируемыеБизнесПроцессы.Добавить(БизнесПроцесс);
		
	КонецЕсли;
	
	ПараметрыДействия.Процесс = БизнесПроцесс.Ссылка;
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ПараметрыДействия.Имя, ПризнакПрохожденияЭлемента);
	
КонецПроцедуры

// Добавляет в очередь элементы после завершенного действия.
//
// Параметры:
//  ИмяДействия - Строка - Имя действия в схемы.
//  ОчередьЭлементовСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы схемы процесса.
//
Процедура ДобавитьВОчередьЭлементыПослеЗавершенногоДействия(ИмяДействия, ОчередьЭлементовСхемы)
	
	// Находим параметры действия.
	ПараметрыДействия = СтрокиТаблицыПараметрыДействий.Получить(ИмяДействия);
	
	// Определим результат выполнения процесса.
	РезультатВыполнения = РегистрыСведений.РезультатыВыполненияПроцессовИЗадач.
		РезультатВыполненияПоОбъекту(ПараметрыДействия.Процесс);

	// Находим всех последователей текущего элемента.
	ПоследователиЭлемента = ПоследователиЭлементаСхемы(ПараметрыДействия.Имя);

	// Находим строки последователей в таблице ЭлементыСхемы
	// и помещаем их в очередь для обработки (ОчередьЭлементовСхемы).
	Для Каждого ПоследовательЭлемента Из ПоследователиЭлемента Цикл
		
		ЭлементСхемы = СтрокиТаблицыЭлементыСхемы.Получить(ПоследовательЭлемента.Имя);
		
		// Если последователем действия является другое действиие, то оно запускается только
		// при положительном результате выполнения.
		Если (ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Действие
				Или ЭлементСхемы.Тип = Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.ВложенныйПроцесс)
				
			И РезультатВыполнения = Перечисления.ВариантыВыполненияПроцессовИЗадач.Отрицательно Тогда
			
			Продолжить;
		КонецЕсли;
		
		ОчередьЭлементовСхемы.Добавить(ЭлементСхемы);
		ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ПоследовательЭлемента.ИмяСоединительнойЛинии);
		
	КонецЦикла;
	
КонецПроцедуры

// Стартует процессы действий комплексного процесса.
//
// Параметры:
//  ФормируемыеБизнесПроцессы - Массив - объекты сформированных действий.
//  Процесс - БизнесПроцессОбъект - объект комплексного процесса.
//
Процедура СтартоватьПроцессыДействий(ФормируемыеБизнесПроцессы, Процесс)
	
	Для Каждого ПроцессДляСтарта Из ФормируемыеБизнесПроцессы Цикл
		
		// Создаем ведущую задачу для стартуемого процесса.
		ВедущаяЗадачаДействия = Задачи.ЗадачаИсполнителя.СоздатьЗадачу();
		ВедущаяЗадачаДействия.Дата = ТекущаяДатаСеанса();
		ВедущаяЗадачаДействия.БизнесПроцесс = Процесс.Ссылка;
		ВедущаяЗадачаДействия.ТочкаМаршрута = 
			БизнесПроцессы.КомплексныйПроцесс.ТочкиМаршрута.ВложенныйПроцесс;
		ВедущаяЗадачаДействия.Проект = Процесс.Проект;
		ВедущаяЗадачаДействия.ПроектнаяЗадача = Процесс.ПроектнаяЗадача;
		
		РаботаСКомплекснымиБизнесПроцессамиСерверПереопределяемый.
			СоздатьПроцессПоДействиюЗаполнениеВедущейЗадачи(
				Процесс, ВедущаяЗадачаДействия);
		
		ВедущаяЗадачаДействия.Записать();
	
		ПроцессДляСтарта.ВедущаяЗадача = ВедущаяЗадачаДействия.Ссылка;
	
		// Записываем и стартуем процесс.
		ПроцессДляСтарта.Записать();
		ПроцессДляСтарта.Старт();
	
	КонецЦикла;
	
КонецПроцедуры

// Выполняет обработку элемента Отработка схемы процесса.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схемы.
//  Процесс - БизнесПроцессОбъект.КомплексныйПроцесс - объект комплексного процесса.
//
Процедура ОбработатьЭлементОбработкаСхемыПроцесса(ИмяЭлемента, ОчередьЭлементовСхемы, Процесс)
	
	// Находим параметры обработки.
	ПараметрыОбработки = СтрокиТаблицыПараметрыОбработок.Получить(ИмяЭлемента);
	
	// Получаем выражение на встроенном языке.
	ВыраженияНаВстроенномЯзыке =
		РегистрыСведений.СкриптыСхемКомплексныхПроцессов.СкриптСхемы(Ссылка,
			ПараметрыОбработки.ИдентификаторСкрипта);
	
	Выполнить(ВыраженияНаВстроенномЯзыке);
	
	// Находим всех последователей текущего элемента.
	ПоследователиЭлемента = ПоследователиЭлементаСхемы(ИмяЭлемента);
	
	// Находим строки последователей в таблице ЭлементыСхемы схемы процесса
	// и помещаем их в очередь для обработки (ЭлементыСхемы).
	Для Каждого ПоследовательЭлемента Из ПоследователиЭлемента Цикл
		ЭлементСхемы = СтрокиТаблицыЭлементыСхемы.Получить(ПоследовательЭлемента.Имя);
		ОчередьЭлементовСхемы.Добавить(ЭлементСхемы);
		ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ПоследовательЭлемента.ИмяСоединительнойЛинии);
	КонецЦикла;
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

// Выполняет обработку элемента разделения схемы процесса.
// Для элемента ищутся его последователи и добавляются в ЭлементыСхемы.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схеме.
//  ЭлементыСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы.
//
Процедура ОбработатьЭлементРазделениеСхемыПроцесса(ИмяЭлемента, ОчередьЭлементовСхемы)
	
	// Находим всех последователей текущего элемента.
	ПоследователиЭлемента = ПоследователиЭлементаСхемы(ИмяЭлемента);
	
	// Находим строки последователей в таблице ЭлементыСхемы схемы процесса
	// и помещаем их в очередь для обработки (ЭлементыСхемы).
	Для Каждого ПоследовательЭлемента Из ПоследователиЭлемента Цикл
		ЭлементСхемы = СтрокиТаблицыЭлементыСхемы.Получить(ПоследовательЭлемента.Имя);
		ОчередьЭлементовСхемы.Добавить(ЭлементСхемы);
		ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ПоследовательЭлемента.ИмяСоединительнойЛинии);
	КонецЦикла;
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

// Выполняет обработку элемента слияния схемы процесса.
// Проверят все ли предыдущие элементы были обработаны и
// если обработаны все, то добавляет в элементы для обработки последователя.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схеме процесса.
//  ЭлементыСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы.
//
Процедура ОбработатьЭлементСлияниеСхемыПроцесса(ИмяЭлемента, ОчередьЭлементовСхемы, Процесс)
	
	// Найдем все предшествующие действия.
	ИменаДействий = ИменаДействийПредшествующихСлиянию(ИмяЭлемента);
	
	// Проверим их завершенность. Слияние выполняется только при выполнении всех
	// стартованных предшествующих действий.
	
	ВсеДействияПройдены = Истина;
	
	Для Каждого ИмяДействия Из ИменаДействий Цикл
		
		СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(ИмяДействия);
		СтрокаДействия = СтрокиТаблицыПараметрыДействий.Получить(ИмяДействия);
		
		// Пропускаем все нестартованные действия.
		Если Не ЗначениеЗаполнено(СтрокаДействия.Процесс) Тогда
			Продолжить;
		КонецЕсли;
		
		// выходим из цикла если есть хотя бы одно не завершенное действие.
		Если Не СтрокаЭлемента.Пройден Тогда
			ВсеДействияПройдены = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ВсеДействияПройдены Тогда
		Возврат;
	КонецЕсли;
	
	// Добавим последователей слияния в обрабатываемые элементы.
	Последователи = ПоследователиЭлементаСхемы(ИмяЭлемента);
	
	Для Каждого СтрокаТаблицы Из Последователи Цикл
		
		СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(СтрокаТаблицы.Имя);
		ОчередьЭлементовСхемы.Добавить(СтрокаЭлемента);
		ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(СтрокаТаблицы.ИмяСоединительнойЛинии);
		
	КонецЦикла;
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

// Возвращает имена действий которые предшествуют слиянию.
// Имена действий ищутся между слиянием его парным разделением.
//
// Параметры:
//  ИмяСлияния - Строка - имя слияния
//
// Возвращаемое значение:
//  Массив - массив имен (строк) действий.
//
Функция ИменаДействийПредшествующихСлиянию(ИмяСлияния)
	
	// Вначале находятся все пути схемы без зацикливаний.
	// После определяются все разделения которые входят во всех пути
	// с слиянием.
	// Из найденных разделений выбирается ближайшее к слиянию - это разделение
	// является парным для слияния.
	// Далее выбираются все действия между разделением и слиянием.
	
	// Найдем элемент старта.
	СтрокаЭлементаСхемы = ЭлементыСхемы.Найти(
		Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Старт, "Тип");
	
	ПутиСхемы = РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.ПутиСхемыКомплексногоПроцесса(
		СтрокаЭлементаСхемы.Имя, ПредшественникиЭлементовСхемы);
	
	ПутиССлиянием = Новый Массив;
	
	// Находим все разделения предшествующие текущему слиянию.
	ИменаРазделений = Новый Соответствие;
	
	Для Каждого Путь Из ПутиСхемы Цикл
		
		// Пропускаем пути, в которых нет текущего слияния.
		Если Путь.Найти(ИмяСлияния) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Добавляем путь в список путей с текущим слиянием.
		ПутиССлиянием.Добавить(Путь);
		
		Для Каждого ЭлементПути Из Путь Цикл
			
			// Прерываем анализ элементов пути после рассматриваемого слияния.
			Если ЭлементПути = ИмяСлияния Тогда
				Прервать;
			КонецЕсли;
			
			СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(ЭлементПути);
			
			// Пропускаем все элементы, которые не являются слиянием.
			Если СтрокаЭлемента.Тип <> Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Разделение Тогда
				Продолжить;
			КонецЕсли;
			
			// Переходим к следующему элементу, если
			// текущее слияние уже было добавлено имена разделений.
			Если ИменаРазделений.Получить(ЭлементПути) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Добавляем разделение в список всех разделений до
			// текущего слияния.
			ИменаРазделений.Вставить(ЭлементПути, ЭлементПути);
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Исключим разделения которые не входят во все пути с слиянием.
	РазделенияКИсключению = Новый Массив;
	Для Каждого ЭлементСоответствия Из ИменаРазделений Цикл
		
		Для Каждого ПутьССлиянием Из ПутиССлиянием Цикл
			
			Если ПутьССлиянием.Найти(ЭлементСоответствия.Ключ) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			РазделенияКИсключению.Добавить(ЭлементСоответствия.Ключ);
			Прервать;
		КонецЦикла;
		
	КонецЦикла;
	Для Каждого РазделениеКИсключению Из РазделенияКИсключению Цикл
		ИменаРазделений.Удалить(РазделениеКИсключению);
	КонецЦикла;
	
	// Ищем ближайшее разделение к слиянию.
	// Оно будет парным для слияния.
	ИмяРазделения = "";
	РасстояниеДоСлияния = 2147483647;
	
	Для Каждого ПутьССлиянием Из ПутиССлиянием Цикл
		
		ПозицияСлиянияВПути = ПутьССлиянием.Найти(ИмяСлияния);
		
		Для Каждого ЭлементСоответствия Из ИменаРазделений Цикл
			
			ПозицияРазделенияВПути = ПутьССлиянием.Найти(ЭлементСоответствия.Ключ);
			
			РасстояниеМеждуЭлементами = ПозицияСлиянияВПути - ПозицияРазделенияВПути;
			
			Если РасстояниеМеждуЭлементами < РасстояниеДоСлияния Тогда
				ИмяРазделения = ЭлементСоответствия.Ключ;
				РасстояниеДоСлияния = РасстояниеМеждуЭлементами;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Ищем все действия между разделением и слиянием.
	ИменаДействий = Новый Массив;
	Для Каждого ПутьССлиянием Из ПутиССлиянием Цикл
		
		ИндексНачала = ПутьССлиянием.Найти(ИмяРазделения) + 1;
		ИндексОкончания = ПутьССлиянием.Найти(ИмяСлияния) - 1;
		
		Если ИндексНачала > ИндексОкончания Тогда
			Продолжить;
		КонецЕсли;
		
		Для ИндексЭлемента = ИндексНачала По ИндексОкончания Цикл
			
			ИмяЭлемента = ПутьССлиянием[ИндексЭлемента];
			
			СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(ИмяЭлемента);
			
			Если СтрокаЭлемента.Тип <> Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.Действие
				И СтрокаЭлемента.Тип <> Перечисления.ТипыЭлементовСхемыКомплексногоПроцесса.ВложенныйПроцесс Тогда
				
				Продолжить;
			КонецЕсли;
			
			ИменаДействий.Добавить(ИмяЭлемента);
			
		КонецЦикла;
		
	КонецЦикла;
	
	ИменаДействий = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ИменаДействий);
	
	Возврат ИменаДействий;
	
КонецФункции

// Выполняет обработку элемента условия схемы процесса.
// Вычисляет результат и в зависимости от результата помещает следующий элемент
// в ЭлементыСхемы для обработки.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схеме.
//  ЭлементыСхемы - Массив
//   * СтрокаТабличнойЧасти - строка табличной части ЭлементыСхемы.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - процесс-объект владельца схемы.
//
Процедура ОбработатьЭлементУсловиеСхемыПроцесса(ИмяЭлемента, ОчередьЭлементовСхемы, Процесс)
	
	// Вычислим результат условия.
	РезультатУсловия = РезультатУсловия(ИмяЭлемента, Процесс);
	
	// Находим последователя с учетом результата условия.
	Отбор = Новый Структура;
	Отбор.Вставить("ИмяПредшественника", ИмяЭлемента);
	Отбор.Вставить("РезультатУсловияПредшественника", РезультатУсловия);
	НайденныеПоследователи = ПредшественникиЭлементовСхемы.НайтиСтроки(Отбор);
	ПоследовательУсловия = НайденныеПоследователи[0];
	
	// Находим строку последователя в таблице ЭлементыСхемы
	// и помещаем его в очередь для обработки (ЭлементыСхемы).
	СтрокаЭлемента = СтрокиТаблицыЭлементыСхемы.Получить(ПоследовательУсловия.Имя);
	ОчередьЭлементовСхемы.Добавить(СтрокаЭлемента);
	ВыделитьПройденнуюСоединительнуюЛиниюНаСхеме(ПоследовательУсловия.ИмяСоединительнойЛинии);
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

// Вычисляет и возвращает результат условия.
//
// Параметры:
//  ИмяУсловия - Строка - имя условия в схеме.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - процесс-объект владельца схемы.
//
// Возвращаемое значение:
//  Булево - Истина, если условие выполнено, иначе - Ложь.
//
Функция РезультатУсловия(ИмяУсловия, Процесс)
	
	// Получаем настройки условия в виде насройки компоновки данных.
	ПараметрыУсловия = СтрокиТаблицыПараметрыУсловий.Получить(ИмяУсловия);
	
	ПредставлениеУсловия = 
		ГрафическаяСхемаПроцесса.ЭлементыГрафическойСхемы.Найти(ИмяУсловия).Наименование;
	
	НастройкиКомпоновкиДанных = ПараметрыУсловия.НастройкиУсловия.Получить();
	
	// Определяем действия-предшественников условия.
	ДействияПредшественники = Новый Массив;
	ПолучитьДействияПредшествующиеЭлементу(ИмяУсловия, ДействияПредшественники);
	
	// Поменяем значения элементов отбора настройки компоновки данных на поле ПолеДляПроверки.
	Попытка
		ВычислитьЗначенияЭлементовОтбора(НастройкиКомпоновкиДанных.Отбор.Элементы, Процесс, ДействияПредшественники);
	Исключение
		
		Инфо = ИнформацияОбОшибке();
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Проверка условия схемы процесса'; en = 'Evaluation of process diagram rule'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,
			Процесс.Ссылка,
			ПодробноеПредставлениеОшибки(Инфо));
			
		ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При проверке условия ""%1"" схемы процесса возникла ошибка:
				|%2
				|Обратитесь к администратору.';
				|en = 'While evaluating ""%1"" rule the following error occurred:
				|%2
				|Contact the administrator.'"),
			ПредставлениеУсловия, 
			Инфо.Описание);
		ВызватьИсключение ТекстИсключения;
		
	КонецПопытки;
	
	// Вычисляем результат условия при помощи схемы компоновки данных.
	СхемаКомпоновкиДанных = Справочники.СхемыКомплексныхПроцессов.ПолучитьМакет("Условие");
	
	Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	URLСхемы = ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, Новый УникальныйИдентификатор());
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(URLСхемы);
	Компоновщик.Инициализировать(ИсточникНастроек);
	Компоновщик.ЗагрузитьНастройки(НастройкиКомпоновкиДанных);
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, 
		Компоновщик.ПолучитьНастройки(),,,
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	ТаблицаРезультата = Новый ТаблицаЗначений;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(ТаблицаРезультата);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	// Возвращаем результат.
	Возврат ТаблицаРезультата.Количество() > 0;
	
КонецФункции

// Получает действия предшественников элементу.
// Рекурсивная процедура.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента.
//  ДействияПредшественники - Массив - в этот параметр будут помещены предшествующие действия
//                                     (строки табличной части ПараметрыДействий).
//
Процедура ПолучитьДействияПредшествующиеЭлементу(ИмяЭлемента, ДействияПредшественники)
	
	ПредшественникиЭлемента = ПредшественникиЭлементаСхемы(ИмяЭлемента);
	
	Для Каждого ПредшественникЭлемента Из ПредшественникиЭлемента Цикл
		
		ПараметрыДействия = СтрокиТаблицыПараметрыДействий.Получить(ПредшественникЭлемента.ИмяПредшественника);
		
		Если ПараметрыДействия <> Неопределено Тогда
			ДействияПредшественники.Добавить(ПараметрыДействия);
			Продолжить;
		КонецЕсли;
		
		ПолучитьДействияПредшествующиеЭлементу(
			ПредшественникЭлемента.ИмяПредшественника,
			ДействияПредшественники);
		
	КонецЦикла;
	
КонецПроцедуры

// Вычисляет значения элементов отбора условия карты маршрута процесса.
// Рекурсивная процедура.
//
// Параметры:
//  ЭлементыОтбора - КоллекцияЭлементовОтбораКомпоновкиДанных - элементы отбора условия.
//  Процесс - БазнесПроцесОбъект.КомплексныйПроцесс - процесс-объект владельца схемы.
//  ДействияПредшественники - Массив - предшественники условия с текущими элементами отбора.
//                             Массив строк таблицы ПредшественникиЭлементовСхемы.
//
Процедура ВычислитьЗначенияЭлементовОтбора(ЭлементыОтбора, Процесс, ДействияПредшественники)
	
	ТипЭлементОтбораКомпоновкиДанных = Тип("ЭлементОтбораКомпоновкиДанных");
	ТипГруппаЭлементовОтбораКомпоновкиДанных = Тип("ГруппаЭлементовОтбораКомпоновкиДанных");
	
	ПолеУсловиеПоПредметам = Новый ПолеКомпоновкиДанных("УсловиеПоПредметам");
	
	ПолеУсловиеПоРезультатамВыполненияДействий = 
		Новый ПолеКомпоновкиДанных("УсловиеПоРезультатамВыполненияДействий");
		
	ПолеВыражениеНаВстроенномЯзыке = Новый ПолеКомпоновкиДанных("ВыражениеНаВстроенномЯзыке");
	
	ПолеДляПроверки = Новый ПолеКомпоновкиДанных("ПолеДляПроверки");
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		ТипЭлементаОтбора = ТипЗнч(ЭлементОтбора);
		
		Если ТипЭлементаОтбора = ТипЭлементОтбораКомпоновкиДанных Тогда
			
			Результат = Ложь;
			
			Если ЭлементОтбора.ЛевоеЗначение = ПолеУсловиеПоПредметам Тогда
				
				ИмяПредмета = ЭлементОтбора.ПравоеЗначение.ИмяПредмета;
				Условие = ЭлементОтбора.ПравоеЗначение.Условие;
				
				Отбор = Новый Структура;
				Отбор.Вставить("ИмяПредмета", ИмяПредмета);
				ПредметыУсловия = Процесс.Предметы.НайтиСтроки(Отбор);
				
				// Если в процессе отсутствует предмет с указанным именем,
				// то игнорируем текущее условие.
				Если ПредметыУсловия.Количество() = 0 Тогда
					ЭлементОтбора.Использование = Ложь;
					Продолжить;
				КонецЕсли;
				
				ПредметУсловия = ПредметыУсловия[0].Предмет;
				Результат = РаботаСУсловиямиМаршрутизации.ПроверитьПрименимостьУсловияМаршрутизацииКОбъекту(
					ПредметУсловия, Условие);
				
			ИначеЕсли ЭлементОтбора.ЛевоеЗначение = ПолеУсловиеПоРезультатамВыполненияДействий Тогда
				
				ИмяДействия = ЭлементОтбора.ПравоеЗначение.Действие;
				РезультатВыполненияПоУсловию = ЭлементОтбора.ПравоеЗначение.РезультатВыполнения;
				
				ПараметрыДействия = СтрокиТаблицыПараметрыДействий.Получить(ИмяДействия);
				
				// Если в процессе отсутствует действие, то игнорируем текущее условие.
				Если ПараметрыДействия = Неопределено Тогда
					ЭлементОтбора.Использование = Ложь;
					Продолжить;
				КонецЕсли;
				
				Действие = ПараметрыДействия.Процесс;
				
				// Если по действию не запущен процесс, то игнорируем текущее условие.
				Если Не ЗначениеЗаполнено(Действие) Тогда
					ЭлементОтбора.Использование = Ложь;
					Продолжить;
				КонецЕсли;
				
				// Игнорируем условие, если действие отсутствует среди предшественников.
				ДействияНетСредиПредшественников = Истина;
				Если ЗначениеЗаполнено(Действие) Тогда
					Для Каждого СтрокаПредшественник Из ДействияПредшественники Цикл
						Если СтрокаПредшественник.Имя = ИмяДействия Тогда
							ДействияНетСредиПредшественников = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				Если ДействияНетСредиПредшественников Тогда 
					ЭлементОтбора.Использование = Ложь;
					Продолжить;
				КонецЕсли;
				
				ДействиеЗавершено = 
					ОбщегоНазначенияДокументооборот.ЗначениеРеквизитаОбъектаВПривилегированномРежиме(
						Действие, "Завершен");
				
				Если ДействиеЗавершено Тогда
					
					РезультатВыполненияДействия = Перечисления.ВариантыВыполненияПроцессовИЗадач.ПустаяСсылка();
					
					Запрос = Новый Запрос;
					Запрос.Текст = 
						"ВЫБРАТЬ
						|	РезультатыВыполненияПроцессовИЗадач.Результат
						|ИЗ
						|	РегистрСведений.РезультатыВыполненияПроцессовИЗадач КАК РезультатыВыполненияПроцессовИЗадач
						|ГДЕ
						|	РезультатыВыполненияПроцессовИЗадач.Объект = &Объект";
					
					Запрос.УстановитьПараметр("Объект", Действие);
					
					Выборка = Запрос.Выполнить().Выбрать();
					
					Если Выборка.Следующий() Тогда
						РезультатВыполненияДействия = Выборка.Результат;
					КонецЕсли;
					
					Если РезультатВыполненияПоУсловию = 
						Перечисления.РезультатыВыполненияДействийКомплексныхПроцессов.ЗавершеноСЛюбымРезультатом Тогда
						
						Результат = Истина;
						
					ИначеЕсли РезультатВыполненияПоУсловию = 
						Перечисления.РезультатыВыполненияДействийКомплексныхПроцессов.Отрицательно Тогда
						
						Результат = (РезультатВыполненияДействия = 
							Перечисления.ВариантыВыполненияПроцессовИЗадач.Отрицательно);
						
					ИначеЕсли РезультатВыполненияПоУсловию = 
						Перечисления.РезультатыВыполненияДействийКомплексныхПроцессов.Положительно Тогда
						
						Результат = (РезультатВыполненияДействия = 
								Перечисления.ВариантыВыполненияПроцессовИЗадач.Положительно)
								
							Или (РезультатВыполненияДействия = 
									Перечисления.ВариантыВыполненияПроцессовИЗадач.ПоложительноСЗамечаниями);
						
					ИначеЕсли РезультатВыполненияПоУсловию = 
						Перечисления.РезультатыВыполненияДействийКомплексныхПроцессов.ПоложительноБезЗамечаний Тогда
						
						Результат = (РезультатВыполненияДействия = 
								Перечисления.ВариантыВыполненияПроцессовИЗадач.Положительно);
						
					ИначеЕсли РезультатВыполненияПоУсловию = 
						Перечисления.РезультатыВыполненияДействийКомплексныхПроцессов.ПоложительноСЗамечаниями Тогда
						
						Результат = (РезультатВыполненияДействия = 
								Перечисления.ВариантыВыполненияПроцессовИЗадач.ПоложительноСЗамечаниями);
						
					КонецЕсли;
					
				КонецЕсли;
				
			ИначеЕсли ЭлементОтбора.ЛевоеЗначение = ПолеВыражениеНаВстроенномЯзыке Тогда
				
				// Получаем текст выражения в привилегированном режиме, т.к.
				// условие может вычисляться в сеансе пользователя, у которого нет прав
				// на редактирование и просмотр выражений. 
				УстановитьПривилегированныйРежим(Истина);
				ТекстВыражения = 
					РегистрыСведений.СкриптыСхемКомплексныхПроцессов.СкриптСхемы(
						Ссылка, ЭлементОтбора.ПравоеЗначение.Выражение);
				УстановитьПривилегированныйРежим(Ложь);
				
				Если ЗначениеЗаполнено(ТекстВыражения) Тогда
					УстановитьБезопасныйРежим(Истина);
					Выполнить(ТекстВыражения);
					УстановитьБезопасныйРежим(Ложь);
				КонецЕсли;
				
			КонецЕсли;
			
			ЭлементОтбора.ЛевоеЗначение = ПолеДляПроверки;
			ЭлементОтбора.ПравоеЗначение = Результат;
			
		ИначеЕсли ТипЭлементаОтбора = ТипГруппаЭлементовОтбораКомпоновкиДанных Тогда
			ВычислитьЗначенияЭлементовОтбора(ЭлементОтбора.Элементы, Процесс, ДействияПредшественники);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет обработку элемента завершения схемы процесса.
//
// Параметры:
//  ИмяЭлемента - Строка - Имя элемента в схеме.
//
Процедура ОбработатьЭлементЗавершенияСхемыПроцесса(ИмяЭлемента)
	
	// Установим признак прохождения элемента.
	УстановитьПризнакПрохожденияЭлемента(ИмяЭлемента, Истина);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ПроверкаКорректностиСхемы

// Возвращает структуру для проверки схемы.
//
// Возвращаемое значение:
//  Структура
//
Функция СтруктураДляПроверкиСхемы()
	
	СтруктураДляПроверки = Новый Структура;
	
	// Кэш элементов схемы.
	СтруктураДляПроверки.Вставить("ЭлементыСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("СоединительныеЛинииСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("Слияния", Новый Массив);
	СтруктураДляПроверки.Вставить("Разделения", Новый Массив);
	СтруктураДляПроверки.Вставить("ЭлементСтарта", "");
	СтруктураДляПроверки.Вставить("ЭлементЗавершения", "");
	СтруктураДляПроверки.Вставить("ГрафическаяСхема", Неопределено);
	
	// Пути схемы.
	СтруктураДляПроверки.Вставить("ЗавершенныеПути", Новый Массив);
	СтруктураДляПроверки.Вставить("Циклы", Новый Массив);
	
	// Результат проверки.
	СтруктураДляПроверки.Вставить("ПроверкаЗавершена", Ложь);
	СтруктураДляПроверки.Вставить("СложнаяКарта", Ложь);
	СтруктураДляПроверки.Вставить("НетЗавершенныхПутей", Ложь);
	СтруктураДляПроверки.Вставить("ЕстьЦиклыБезДействий", Ложь);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовСтарта", 0);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовЗавершения", 0);
	СтруктураДляПроверки.Вставить("ИмяНедопустимогоЭлемента", "");
	СтруктураДляПроверки.Вставить("ИмяНеприсоединеннойСоединительнойЛинии", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаБезВходящихСоединительныхЛиний", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаОбрыва", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаВКоторыйНевозможноПопасть", "");
	СтруктураДляПроверки.Вставить("ЦиклИзКоторогоНедоступноЗавершение", "");
	СтруктураДляПроверки.Вставить("РазделениеСОднойИсходящейЛинией", "");
	СтруктураДляПроверки.Вставить("РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент", "");
	СтруктураДляПроверки.Вставить("СлияниеСОднойВходящейЛинией", "");
	СтруктураДляПроверки.Вставить("СлияниеБезРазделения", "");
	СтруктураДляПроверки.Вставить("СлияниеСразуПослеРазделения", "");
	СтруктураДляПроверки.Вставить("ЭлементПересеченияРазделений", "");
	
	Возврат СтруктураДляПроверки;
	
КонецФункции

#Область ЗаполнитьКэшЭлементовВСтруктуреДляПроверки

// Заполняет кэш элементов схемы в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки)
	
	СтруктураДляПроверки.ГрафическаяСхема = Схема.Получить();
	
	Если СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы.Количество() = 0 Тогда
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
		Возврат;
	КонецЕсли;
	
	// Заполним соотвествия ЭлементыГрафическойСхемы и СоединительныеЛинииГрафическойСхемы
	// и выполним возможные проверки.
	// В случаи ошибок заполнения, прерываем заполнение.
	Для Каждого Элемент Из СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы Цикл
		
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Пропуская декоративные линии и декорации.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыДекоративнаяЛиния")
			Или ТипЭлемента = Тип("ЭлементГрафическойСхемыДекорация") Тогда
			
			Продолжить;
		КонецЕсли;
		
		// Прерываем проверку, если схема содержит недопустимые элементы.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыВыборВарианта") Тогда
			
			СтруктураДляПроверки.ИмяНедопустимогоЭлемента = Элемент.Имя;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
		// Считаем количество элементов старта и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			СтруктураДляПроверки.КоличествоЭлементовСтарта = 
				СтруктураДляПроверки.КоличествоЭлементовСтарта + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементСтарта = Элемент.Имя;
		КонецЕсли;
		
		// Считаем количество элементов завершения и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
			СтруктураДляПроверки.КоличествоЭлементовЗавершения =
				СтруктураДляПроверки.КоличествоЭлементовЗавершения + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементЗавершения = Элемент.Имя;
		КонецЕсли;
		
		// Помещаем все элементы в соотвествие ЭлементыГрафическойСхемы,
		// а соединительные линии в СоединительныеЛинииГрафическойСхемы
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСоединительнаяЛиния") Тогда
			
			НачалоЭлемент = Элемент.НачалоЭлемент;
			КонецЭлемент = Элемент.КонецЭлемент;
			
			// Если линия не присоединена, то прерываем проверку.
			Если НачалоЭлемент = Неопределено Или КонецЭлемент = Неопределено Тогда
				СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии = Элемент.Имя;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			
			СоединительнаяЛинияГрафическойСхемы = СоединительнаяЛинияГрафическойСхемы();
			СоединительнаяЛинияГрафическойСхемы.Предшественник = НачалоЭлемент.Имя;
			СоединительнаяЛинияГрафическойСхемы.Последователь = КонецЭлемент.Имя;
			
			СтруктураДляПроверки.СоединительныеЛинииСхемы.Вставить(
				Элемент.Имя,
				СоединительнаяЛинияГрафическойСхемы);
		Иначе
			
			ЭлементГрафическойСхемы = ЭлементГрафическойСхемы();
			ЭлементГрафическойСхемы.Тип = ТипЭлемента;
			
			СтруктураДляПроверки.ЭлементыСхемы.Вставить(
				Элемент.Имя,
				ЭлементГрафическойСхемы);
		КонецЕсли;
		
		// Поместим имена сляний и разделение в отдельные массивы структуры для проверки.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСлияние") Тогда
			СтруктураДляПроверки.Слияния.Добавить(Элемент.Имя);
		ИначеЕсли ТипЭлемента = Тип("ЭлементГрафическойСхемыРазделение") Тогда
			СтруктураДляПроверки.Разделения.Добавить(Элемент.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	// Заполним предшественников и последователей элементов в соотвествии ЭлементыСхемы
	// по соединительными линиям (СоединительныеЛинииСхемы)
	Для Каждого Линия Из СтруктураДляПроверки.СоединительныеЛинииСхемы Цикл
		
		ПараметрыЛинии = Линия.Значение;
		
		// Заполняем предшественников
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Последователь);
		ЭлементСхемы.Предшественники.Добавить(ПараметрыЛинии.Предшественник);
		
		// Заполняем последователей
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Предшественник);
		ЭлементСхемы.Последователи.Добавить(ПараметрыЛинии.Последователь);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает структуру соединительной линии в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура
//   * Предшественник - Строка - имя предшествующего элемента.
//   * Последователь - Строка - имя последующего элемента.
//
Функция СоединительнаяЛинияГрафическойСхемы()
	
	СоединительнаяЛиния = Новый Структура;
	СоединительнаяЛиния.Вставить("Предшественник", "");
	СоединительнаяЛиния.Вставить("Последователь", "");
	
	Возврат СоединительнаяЛиния;
	
КонецФункции

// Возвращает структуру графического элемента в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура
//   * Тип - ЭлементГрафическойСхемыДействие,
//           ЭлементГрафическойСхемыРазделение,
//           ЭлементГрафическойСхемыУсловие,
//           ЭлементГрафическойСхемыЗавершение,
//           ЭлементГрафическойСхемыСтарт,
//           ЭлементГрафическойСхемыСлияние,
//           ЭлементГрафическойСхемыВложенныйБизнесПроцесс - тип элемента графической схемы.
//   * Предшественники - Массив - имена предшествующих элементов.
//   * Последователи - Массив - имена последующих элементов.
//
Функция ЭлементГрафическойСхемы()
	
	ЭлементГрафическойСхемы = Новый Структура;
	ЭлементГрафическойСхемы.Вставить("Тип", Неопределено);
	ЭлементГрафическойСхемы.Вставить("Предшественники", Новый Массив);
	ЭлементГрафическойСхемы.Вставить("Последователи", Новый Массив);
	
	Возврат ЭлементГрафическойСхемы;
	
КонецФункции

#КонецОбласти

// Проверяет заполнение предшественников у элементов.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверяем заполнение предшественников у элементов.
	// Если элемент не Старт и у него нет входящих соединительных линий - прерываем проверку.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ПараметрыЭлемента = Элемент.Значение;
		
		// Пропускаем элемент Старта.
		Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыЭлемента.Предшественники.Количество() = 0 Тогда
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#Область СформироватьПутиПоСхеме

// Формирует список завершенных путей и циклов по схеме процесса.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура СформироватьПутиПоСхеме(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Создадим начальный путь с одим элементом старта и поместим его в массив путей для обработки.
	Путь = Новый Массив;
	Путь.Добавить(СтруктураДляПроверки.ЭлементСтарта);
	
	ПутиВОбработке = Новый Массив;
	ПутиВОбработке.Добавить(Путь);
	
	КоличествоЭлементовИЛиний = СтруктураДляПроверки.ЭлементыСхемы.Количество()
		+ СтруктураДляПроверки.СоединительныеЛинииСхемы.Количество();
	
	// Вычислим количество циклов определения путей. Количество должно быть конечно, т.к.
	// использовать бесконечный цикл с условием выхода опасно – из за ошибки можно получить зависание программы.
	КоличествоЦикловОпределенияПути = КоличествоЭлементовИЛиний * 10;
	
	// Определим максимальное количество путей. В случае превышения прерываем проверку.
	// Нужно, чтобы не ожидать очень долго проверки сложной карты маршрута.
	МаксимальноеКоличествоПутей = КоличествоЭлементовИЛиний * 100;
	
	// Выполняем поиск всех путей
	Для НомерЦикла = 0 По КоличествоЦикловОпределенияПути Цикл
		
		НовыеПутиКОбработке = Новый Массив;
		
		Если ПутиВОбработке.Количество() >= МаксимальноеКоличествоПутей Тогда
			СтруктураДляПроверки.СложнаяКарта = Истина;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
		// Обходим все пути в обработке.
		Для Каждого ОбрабатываемыйПуть Из ПутиВОбработке Цикл
			
			// Продвигаемся по пути схемы.
			РезультатПродвижения = ПродвинутьсяПоПутиСхемы(
				СтруктураДляПроверки, ОбрабатываемыйПуть, НовыеПутиКОбработке);
			
			// Выполняем проверку результата продвижения и помещаем путь в соответствующий список структуры для проверки.
			// В случае обрыва прерываем обработку.
			Если РезультатПродвижения = "УПутиЕстьПродолжение" Тогда
				
				НовыеПутиКОбработке.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьЗавершен" Тогда
				
				СтруктураДляПроверки.ЗавершенныеПути.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьИмеетЦикл" Тогда
				
				ВыделитьЦиклВПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.Циклы.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьОборван" Тогда
				
				ПоследнийЭлемент = ПоследнийЭлементПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.ИмяЭлементаОбрыва = ПоследнийЭлемент;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
			Прервать;
		КонецЕсли;
		
		Если НовыеПутиКОбработке.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПутиВОбработке = 
			ОбщегоНазначенияКлиентСервер.СкопироватьМассив(НовыеПутиКОбработке);
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ЗавершенныеПути.Количество() = 0 Тогда
		СтруктураДляПроверки.НетЗавершенныхПутей = Истина;
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Продвигается по пути схемы, при определении завершенных путей и возвращает результат
// продвижения.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Путь - Массив - массив из имен элементов схемы.
//  НовыеПутиКОбработке - Массив - массив новых путей для обработки.
//
// Возвращаемое значение:
//  Строка - может принимать значения
//   * "УПутиЕстьПродолжение"
//   * "ПутьЗавершен"
//   * "ПутьИмеетЦикл"
//   * "ПутьОборван"
//
Функция ПродвинутьсяПоПутиСхемы(СтруктураДляПроверки, Путь, НовыеПутиКОбработке)
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	Последователи = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Последователи;
	
	КоличествоПоследователей = Последователи.Количество();
	
	// Если у элемента нет последователей и путь не достиг элемента завершения, то это ошибка.
	Если КоличествоПоследователей = 0 Тогда
		Возврат "ПутьОборван";
	КонецЕсли;
	
	// Обходим всех последователей, кроме последнего.
	Для ИндексПоследователя = 0 По КоличествоПоследователей - 2 Цикл
		
		ЭлементПоследователь = Последователи[ИндексПоследователя];
		
		// Копируем исходный путь.
		НовыйПуть = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(Путь);
		
		// Добавляем в новый путь последователя
		НовыйПуть.Добавить(ЭлементПоследователь);
		
		// Выполняем проверку и помещаем путь в соответствующий список структуры для проверки.
		Если ПутьЗавершен(СтруктураДляПроверки, НовыйПуть) Тогда
			СтруктураДляПроверки.ЗавершенныеПути.Добавить(НовыйПуть);
		ИначеЕсли ПутьИмеетЦикл(НовыйПуть) Тогда
			ВыделитьЦиклВПути(НовыйПуть);
			СтруктураДляПроверки.Циклы.Добавить(НовыйПуть);
		Иначе
			НовыеПутиКОбработке.Добавить(НовыйПуть);
		КонецЕсли;
		
	КонецЦикла;
	
	// Поместим последнего последователя в путь.
	ЭлементПоследователь = Последователи[КоличествоПоследователей - 1];
	Путь.Добавить(ЭлементПоследователь);
	
	// Выполняем проверку текущего пути и возвращаем результат.
	Если ПутьЗавершен(СтруктураДляПроверки, Путь) Тогда
		Возврат "ПутьЗавершен";
	ИначеЕсли ПутьИмеетЦикл(Путь) Тогда
		Возврат "ПутьИмеетЦикл";
	Иначе
		Возврат "УПутиЕстьПродолжение";
	КонецЕсли;
	
КонецФункции

// Возвращает последний элемент пути. Путь должен иметь не менее 1го элемента.
//
// Параметры:
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Строка
//
Функция ПоследнийЭлементПути(Путь)
	
	Возврат Путь[Путь.Количество() - 1];
	
КонецФункции

// Проверяет путь на предмет достижения элемиента завершения.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьЗавершен(СтруктураДляПроверки, Путь)
	
	Результат = Ложь;
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	ТипЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Тип;
	
	Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет и возвращает признак наличия цикла в пути.
//
// Параметры:
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьИмеетЦикл(Путь)
	
	Результат = Ложь;
	
	// Проверяем только последений элемент пути.
	ИндексПоследнегоЭлемента = Путь.Количество() - 1;
	
	ПоследнийЭлемент = Путь[ИндексПоследнегоЭлемента];
	
	ИндексЭлемента = Путь.Найти(ПоследнийЭлемент);
	
	Если ИндексЭлемента <> ИндексПоследнегоЭлемента Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Удаляет из пути все, что находится до цикла.
// Например, было так: 1-2-3-4-5-3
// Станет так: 3-4-5-3.
//
Процедура ВыделитьЦиклВПути(Путь)
	
	КоличествоЭлементов = Путь.Количество();
	
	// Получаем последнеий элемент пути
	ПоследнийЭлемент = Путь[КоличествоЭлементов - 1];
	
	// Получим индекс следующего элемента с конца.
	ИндексЭлемента = КоличествоЭлементов - 2;
	
	// Обходим путь с конца и удаляем элементы, которые не входят в цикл.
	УдалитьЭлемент = Ложь;
	Пока ИндексЭлемента >=0 Цикл
		
		// Удаляем элемент из массива
		Если УдалитьЭлемент Тогда
			Путь.Удалить(ИндексЭлемента);
			
		// Если текущий элемент равен последнему, то включаем удаление всех предыдущих.
		ИначеЕсли Путь[ИндексЭлемента] = ПоследнийЭлемент Тогда
			УдалитьЭлемент = Истина;
		КонецЕсли;
		
		ИндексЭлемента = ИндексЭлемента - 1;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ПроверитьЗацикливаниеСхемы

// Проверяет зацикливание схемы.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие действий и вложенных процессов в циклах.
	// Если в циклах их нет, то прекращаем проверку.
	Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
		
		ЕстьЦиклыБезДействий = Истина;
		
		Для Каждого Элемент Из Путь Цикл
			
			ПараметрыЭлементы = СтруктураДляПроверки.ЭлементыСхемы.Получить(Элемент);
			
			Если ПараметрыЭлементы.Тип = Тип("ЭлементГрафическойСхемыДействие")
				Или ПараметрыЭлементы.Тип = Тип("ЭлементГрафическойСхемыВложенныйБизнесПроцесс") Тогда
				
				ЕстьЦиклыБезДействий = Ложь;
				
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ЕстьЦиклыБезДействий Тогда
			
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЕстьЦиклыБезДействий = Истина;
			
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие элементов в которые невозможно попасть.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ВЭлементНевозможноПопасть = Истина;
		
		// Проверим наличие элемента в циклах
		Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
			
			Для Каждого ЭлементПути Из Путь Цикл
				
				Если ЭлементПути = Элемент.Ключ Тогда
					ВЭлементНевозможноПопасть = Ложь;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если элемент входит хотябы в один цикл, то прервываем проверку
			// остальных циклов.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент входит хотябы в один цикл, то прерываем проверку текущего
		// элемента и переходим к следующему.
		Если Не ВЭлементНевозможноПопасть Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверим наличие элемента в завершенных путях.
		Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл
			
			Для Каждого ЭлементПути Из Путь Цикл
				
				Если ЭлементПути = Элемент.Ключ Тогда
					ВЭлементНевозможноПопасть = Ложь;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если элемент входит хотябы в один путь, то прервываем проверку
			// остальных путей.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент не найден ни в одном пути и ни в одном цикле, тогда
		// прекращаем проверку.
		Если ВЭлементНевозможноПопасть Тогда
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим возможность достижения элемента завершения из циклов.
	
	СостоянияЗацикленныхПутей = Неопределено;
	
	// Обойдем все циклы
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклыВОбработке = Новый Массив;
		
		// Получим состояние текущего цикла.
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла <> "ИзЦиклаДоступноЗавершение" Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			
			ПредставлениеЦиклаСтрокой = "";
			ПутьЦикла = СтруктураДляПроверки.Циклы[ИндексЦикла];
			Разделитель = "";
			Для Каждого ЭлементПути Из ПутьЦикла Цикл
				ПредставлениеЦиклаСтрокой = ПредставлениеЦиклаСтрокой
					+ Разделитель
					+ Строка(ЭлементПути);
				Разделитель = " - ";
			КонецЦикла;
			
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение = ПредставлениеЦиклаСтрокой;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет и возвращает состояние цикла.
// Рекурсивная процедура. Рекурсивный вызов из СостояниеЦиклаПоСвязаннымЦиклам.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  ИндексЦикла - Число - индекс цикла в СтруктураДляПроверкиСхемы.Циклы
//  ЦиклыВОбработке - Массив - массиво циклов, которые находятся в обработке определения состояния.
//  СостоянияЗацикленныхПутей - Соотвествие
//    * Ключ - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращается одно из 3х значений:
//   "ЦиклУжеВОбработке", "ИзЦиклаНеДоступноЗавершение", "ИзЦиклаДоступноЗавершение"
//
Функция СостояниеЦикла(СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке,
	СостоянияЗацикленныхПутей = Неопределено)
	
	Если СостоянияЗацикленныхПутей = Неопределено Тогда
		СостоянияЗацикленныхПутей = Новый Соответствие;
	КонецЕсли;
	
	СостояниеЦикла = СостоянияЗацикленныхПутей.Получить(ИндексЦикла);
	Если СостояниеЦикла <> Неопределено Тогда
		Возврат СостояниеЦикла;
	КонецЕсли;
	
	Если ЦиклыВОбработке.Найти(ИндексЦикла) <> Неопределено Тогда
		Возврат "ЦиклУжеВОбработке";
	КонецЕсли;
	
	ЦиклыВОбработке.Добавить(ИндексЦикла);
	
	СостояниеЦикла = "ИзЦиклаНеДоступноЗавершение";
	
	ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
	
	Для Каждого ЭлементЦикла Из ЦиклПути Цикл
		
		Если ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, ЭлементЦикла) Тогда
			СостояниеЦикла = "ИзЦиклаДоступноЗавершение";
			Прервать;
		КонецЕсли;
		
		СостояниеПоСвязаннымЦиклам = СостояниеЦиклаПоСвязаннымЦиклам(
			СтруктураДляПроверки, ЭлементЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеПоСвязаннымЦиклам = "ИзЦиклаДоступноЗавершение" Тогда
			СостояниеЦикла = СостояниеПоСвязаннымЦиклам;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	СостоянияЗацикленныхПутей.Вставить(ИндексЦикла, СостояниеЦикла);
	
	Возврат СостояниеЦикла;
	
КонецФункции

// Возвращает состояние цикла по связанным циклам.
// Вспомогательная функция, используется в СостояниеЦикла.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - имя элемента цикла.
//  ЦиклыВОбработке - Массив - массив индексов циклов.
//  СостоянияЗацикленныхПутей - Соотвествие
//    * Ключ - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращает одно из двух значений: "ИзЦиклаДоступноЗавершение", "ИзЦиклаНеДоступноЗавершение"
//
Функция СостояниеЦиклаПоСвязаннымЦиклам(СтруктураДляПроверки, Элемент, ЦиклыВОбработке, СостоянияЗацикленныхПутей)
	
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
		
		Если ЦиклПути.Найти(Элемент) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла = "ИзЦиклаДоступноЗавершение" Тогда
			Возврат СостояниеЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат "ИзЦиклаНеДоступноЗавершение";
	
КонецФункции

// Определяет, содержится элемент в завершенных путях.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - Имя элемента схемы процесса.
//
// Возвращаемое значение:
//  Булево
//
Функция ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, Элемент)
	
	Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл
		Для Каждого ЭлементПути Из Путь Цикл
			Если ЭлементПути = Элемент Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область ПроверитьКорректностьРазделенийИСлияний

// Проверяет корректность разделений и слияний в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	Разделения = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(СтруктураДляПроверки.Разделения);
	
	// Проверим элементы разделений на корректность последователей.
	// Последователи должны быть уникальными.
	Для Каждого Разделение Из Разделения Цикл
		
		ПараметрыРазделения = СтруктураДляПроверки.ЭлементыСхемы.Получить(Разделение);
		
		// Проверим корректность количества последователей.
		Если ПараметрыРазделения.Последователи.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией = Разделение;
			Возврат;
		КонецЕсли;
		
		// Проверяем, чтобы последователи в текущем разделении были уникальными.
		Для Каждого Последователь1 Из ПараметрыРазделения.Последователи Цикл
			
			КоличествоВхождений = 0;
			Для Каждого Последователь2 Из ПараметрыРазделения.Последователи Цикл
				
				Если Последователь1 = Последователь2 Тогда
					КоличествоВхождений = КоличествоВхождений + 1;
				КонецЕсли;
				
				Если КоличествоВхождений > 1 Тогда
					СтруктураДляПроверки.ПроверкаЗавершена = Истина;
					СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент = Разделение;
					Возврат;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Проверяем элементы слияний на количество предшественников.
	// Предшественников должно быть более 1го.
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		ПараметрыСлияния = СтруктураДляПроверки.ЭлементыСхемы.Получить(Слияние);
		
		Если ПараметрыСлияния.Предшественники.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией = Слияние;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	// Объединяем завершенные пути и циклы в один массив
	ЗавершенныеПутиИЦиклы = Новый Массив;
	Для Каждого ЗавершенныйПуть Из СтруктураДляПроверки.ЗавершенныеПути Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЗавершенныйПуть);
	КонецЦикла;
	Для Каждого ЦиклПути Из СтруктураДляПроверки.Циклы Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЦиклПути);
	КонецЦикла;
	
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		СвязанноеРазделение = Неопределено;
		ИндексСвязанногоРазделения = Неопределено;
		МинимальнаяДистанцияДоРазделения = 2147483647;
		
		// Найдем раздление для текущего слияния.
		Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
			
			Разделение = Разделения[ИндексРазделения];
			
			Если Разделение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СлияниеИРаздлеоениеВОдномПути = Ложь; // хоть раз попали вместе на один путь
			МаксимальнаяДистанцияДоСлияния = 0;
			СлияниеБезРазделенияВПути = Ложь;
			
			ОдинЭлементПарыВходитВПуть = Ложь; // т.е. когда есть раздление и нет слиятния в пути, и на оборот.
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(Разделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					// Пропускаем текущий путь, если в нем нет ни разделения, ни слияния.
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Останавливаем поиск, когда в пути есть слияние и нет раздлеления.
					// Т.к. это заведом плохой путь.
					СлияниеБезРазделенияВПути = Истина;
					Прервать;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Если в пути есть и слияние и разделение.
					
					// Если раздление раположено раньше слияния, тогда определяем
					// дистанцию между ними
					Если ИндексРазделенияВПути < ИндексСлияния Тогда
						Дистанция = ИндексСлияния - ИндексРазделенияВПути;
						Если Дистанция > МаксимальнаяДистанцияДоСлияния Тогда
							МаксимальнаяДистанцияДоСлияния = Дистанция;
						КонецЕсли;
						СлияниеИРаздлеоениеВОдномПути = Истина;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если СлияниеИРаздлеоениеВОдномПути И Не СлияниеБезРазделенияВПути
				И МаксимальнаяДистанцияДоСлияния < МинимальнаяДистанцияДоРазделения Тогда
				
				МинимальнаяДистанцияДоРазделения = МаксимальнаяДистанцияДоСлияния;
				СвязанноеРазделение = Разделение;
				ИндексСвязанногоРазделения = ИндексРазделения;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если не нашли слияния для разделения
		Если СвязанноеРазделение = Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеБезРазделения = Слияние;
			Возврат;
		Иначе
			
			Разделения[ИндексСвязанногоРазделения] = Неопределено;
			
			СегментыПуйтейДляРазделения = Новый Массив;
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(СвязанноеРазделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// ВызватьИсключение Ложь;
					Продолжить;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					
					Если ИндексРазделенияВПути >= ИндексСлияния Тогда
						//ВызватьИсключение Ложь;
						Продолжить;
					ИначеЕсли ИндексРазделенияВПути < ИндексСлияния Тогда
						
						СегментПути = Новый Массив;
						Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По ИндексСлияния - 1 Цикл
							СегментПути.Добавить(Путь[ИндексЭлементаПути]);
						КонецЦикла;
						
						Если СегментПути.Количество() = 0 Тогда
							СтруктураДляПроверки.ПроверкаЗавершена = Истина;
							СтруктураДляПроверки.СлияниеСразуПослеРазделения = Слияние;
							Возврат;
						КонецЕсли;
						
						СегментыПуйтейДляРазделения.Добавить(СегментПути);
						
					КонецЕсли;
					
				ИначеЕсли РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					
					СегментПути = Новый Массив;
					// Завершение не включаем
					Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По Путь.Количество() - 2 Цикл
						СегментПути.Добавить(Путь[ИндексЭлементаПути]);
					КонецЦикла;
					
					СегментыПуйтейДляРазделения.Добавить(СегментПути);
					
				КонецЕсли;
				
			КонецЦикла;
			
			// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
			ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
				СтруктураДляПроверки, СегментыПуйтейДляРазделения, СвязанноеРазделение);
				
			Если ПроблемныйЭлемент <> Неопределено Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	СегментыПуйтейДляРазделения = Новый Массив;
	
	Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
		
		Разделение = Разделения[ИндексРазделения];
		
		Если Разделение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
			
			ИндексРазделенияВПути = Путь.Найти(Разделение);
			РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
			
			Если Не РазделениеВходитВТекущийПуть Тогда
				Продолжить;
			КонецЕсли;
			
			СегментПути = Новый Массив;
			
			// Элемент Завершение не включаем.
			Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По Путь.Количество() - 2 Цикл
				
				ЭлементПути = Путь[ИндексЭлементаПути];
				ПараметрыЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ЭлементПути);
				
				Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСлияние") Тогда
					Прервать;
				КонецЕсли;
				
				СегментПути.Добавить(ЭлементПути);
			КонецЦикла;
			
			СегментыПуйтейДляРазделения.Добавить(СегментПути);
			
		КонецЦикла;
		
		// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
		ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
			СтруктураДляПроверки, СегментыПуйтейДляРазделения, Разделение);
			
		Если ПроблемныйЭлемент <> Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Ищет элемент, входящий в несколько сегментов Разделение-Слияние.
// В качестве результата, возвращает его имя.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  СегментыРазделениеСлияние - Массив - массив последотельностей (массивов) элементов между разделением и слиянием.
//  Разделение - Строка - имя разделения, с которого начинается последовательность.
//
// Возвращаемое значение:
//  Строка, Неопределено - имя элемента входящего в 2 параллельных сегмента.
//
Функция ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
	СтруктураДляПроверки, СегментыРазделениеСлияние, Разделение)
	
	ПоследователиРазделения = СтруктураДляПроверки.ЭлементыСхемы.Получить(Разделение).Последователи;
	
	Для Каждого ПоследовательРазделения Из ПоследователиРазделения Цикл
		
		Для Каждого СегментТекущегоРазделения Из СегментыРазделениеСлияние Цикл
			
			Если СегментТекущегоРазделения.Количество() = 0
				Или ПоследовательРазделения <> СегментТекущегоРазделения[0] Тогда
				
				Продолжить;
			КонецЕсли;
			
			Для Каждого СегментДругогоРазделения Из СегментыРазделениеСлияние Цикл
				
				Если СегментТекущегоРазделения[0] = СегментДругогоРазделения[0] Тогда
					Продолжить;
				КонецЕсли;
				
				Для Каждого ЭлементСегмента Из СегментТекущегоРазделения Цикл
					Если СегментДругогоРазделения.Найти(ЭлементСегмента) <> Неопределено Тогда
						Возврат ЭлементСегмента;
					КонецЕсли;
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецЕсли
