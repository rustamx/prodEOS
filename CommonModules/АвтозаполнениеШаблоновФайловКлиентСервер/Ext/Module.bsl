#Если НЕ ВебКлиент Тогда
		
////////////////////////////////////////////////////
//// РАБОТА С ПРОСТЫМ АВТОЗАПОЛНЕНИЕМ MS OFFICE


// Возвращает признак того, является ли указанное расширение ассоциированным с MSWord (включая шаблоны).
//
// Параметры:
//  Расширение - Строка - расширение в нижнем регистре.
//
// Возвращаемое значение:
//  Булево - признак того, что расширение ассоциируется с MSWord (включая шаблоны).
//
Функция ФорматMSWord(Расширение) Экспорт
	
	Возврат Расширение = "doc" 
		ИЛИ Расширение = "dot"
		ИЛИ Расширение = "docx" 
		ИЛИ Расширение = "dotx";
		
КонецФункции

// Возвращает признак того, является ли указанное расширение ассоциированным с MSWord.
//
// Параметры:
//  Расширение - Строка - расширение в нижнем регистре.
//
// Возвращаемое значение:
//  Булево - признак того, что расширение ассоциируется с MSWord.
//
Функция ЭтоMSWord(Расширение) Экспорт
	
	Возврат Расширение = "doc" 
		ИЛИ Расширение = "docx";
		
КонецФункции

Функция ПолучитьМассивКороткихПодстрок(Знач ДлиннаяСтрока, МаксДлинаПодстроки)
	
	Результат = Новый Массив;
	
	Пока СтрДлина(ДлиннаяСтрока) > 0 Цикл
		Если СтрДлина(ДлиннаяСтрока) >= МаксДлинаПодстроки Тогда
			Подстрока = Лев(ДлиннаяСтрока, МаксДлинаПодстроки);
		Иначе
			Подстрока = ДлиннаяСтрока;
		КонецЕсли;
		
		Результат.Добавить(Подстрока);
		ДлиннаяСтрока = Прав(ДлиннаяСтрока, СтрДлина(ДлиннаяСтрока) - СтрДлина(Подстрока));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
		
//Заполняет документ MSWord с использованием настроек автозаполнения
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив настроек замены
//			ПутьКФайлуНаДиске - путь на компьютере, куда выгружена текущая версия файла
//Возвращает:Путь на диске компьютера, куда сохранена заполненная версия файла
Функция ЗаполнитьФайлMSWordПоАдресуФайла(Расширение, НастройкиЗамены, ПутьКФайлуНаДиске) Экспорт
	
	Если НастройкиЗамены.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(Расширение);

	КолКолонок = 0;
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		Если ТипЗнч(НастройкаЗамены.ЗначениеЗамены) = Тип("Массив") Тогда
			КолКолонок = КолКолонок + 1;
		КонецЕсли;
	КонецЦикла;
	
	Попытка
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
			WordApp = Новый COMОбъект("Word.Application");
		Иначе
			УдалитьФайлы(НовыйПутьКФайлу);
			Возврат "Linux";
		КонецЕсли;
	Исключение
		УдалитьФайлы(НовыйПутьКФайлу);
		ВызватьИсключение(НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'; en = 'Error working with MS Word application. It is necessary to check the correct installation.'"));
	КонецПопытки;
	
	ОчиститьТабличнуюЧасть = Истина; НашаТаблица = Неопределено;
	Док = WordApp.Documents.Add(ПутьКФайлуНаДиске);
	КоличествоТаблиц = Док.Tables.Count;
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		Попытка
			Если ЗначениеЗаполнено(НастройкаЗамены.ЗначениеЗамены) ИЛИ НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
				Если ТипЗнч(НастройкаЗамены.ЗначениеЗамены) = Тип("Массив") Тогда 
					ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
					
					Если КоличествоТаблиц > 0 Тогда 
						Если НашаТаблица = Неопределено Тогда 
							Для Ит = 1 По КоличествоТаблиц Цикл 
								Если Док.Tables(Ит).Rows.Count > 1 Тогда 
									
									Для Ном = 1 По Док.Tables(Ит).Columns.Count Цикл
										Попытка
											Если Док.Bookmarks(ИмяРеквизита).Range.BookmarkID = 
												Док.Tables(Ит).Cell(2, Ном).Range.Fields(1).Result.BookmarkID Тогда 
												
												НашаТаблица = Док.Tables(Ит);
												НастройкаЗамены.НомерКолонкиТабличнойЧасти = Ном;
												Прервать;
											КонецЕсли;
										Исключение
										КонецПопытки;
									КонецЦикла;
								КонецЕсли;
								
								Если НашаТаблица <> Неопределено Тогда 
									// Нашли нужную таблицу
									Прервать;
								КонецЕсли;
							КонецЦикла;
						Иначе 
							Для Ном = 1 По НашаТаблица.Columns.Count Цикл
								Попытка
									Если Док.Bookmarks(ИмяРеквизита).Range.BookmarkID = 
										НашаТаблица.Cell(2, Ном).Range.Fields(1).Result.BookmarkID Тогда 
										
										НастройкаЗамены.НомерКолонкиТабличнойЧасти = Ном;
										Прервать;
									КонецЕсли;
								Исключение
								КонецПопытки;
							КонецЦикла;
						КонецЕсли;
						
						Если ОчиститьТабличнуюЧасть Тогда 
							КоличествоСтрокТаблицы = НашаТаблица.Rows.Count;
							Если КоличествоСтрокТаблицы > 2 Тогда 
								Пока КоличествоСтрокТаблицы > 2 Цикл 
									НашаТаблица.Rows(КоличествоСтрокТаблицы).Delete();
									КоличествоСтрокТаблицы = КоличествоСтрокТаблицы - 1;
								КонецЦикла;
							КонецЕсли;
							
							Для Ном = 1 По НастройкаЗамены.ЗначениеЗамены.Количество() - 1 Цикл 
								НашаТаблица.Rows.Add();

							КонецЦикла;
							
							ОчиститьТабличнуюЧасть = Ложь;
						КонецЕсли;
						
						Для Ном = 2 По НастройкаЗамены.ЗначениеЗамены.Количество() + 1 Цикл
							Значение = НастройкаЗамены.ЗначениеЗамены[Ном - 2];
							
							Если Ном = 2 Тогда 
								Док.Bookmarks(ИмяРеквизита).Range.Fields(1).Result.Text = СокрЛП(Значение.Значение);
							Иначе 
								НашаТаблица.Cell(Ном, НастройкаЗамены.НомерКолонкиТабличнойЧасти).Range.Text = 
									СокрЛП(Значение.Значение);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
				Иначе 
				
					НастройкаЗамены.ЗначениеЗамены = СтрЗаменить(НастройкаЗамены.ЗначениеЗамены, Символы.ПС, "_+_");
					Если НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
						ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
						Док.Bookmarks(ИмяРеквизита).Range.Fields(1).Result.Text = НастройкаЗамены.ЗначениеЗамены;
					КонецЕсли;
					Если НЕ ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						МассивКороткихПодстрок = ПолучитьМассивКороткихПодстрок(НастройкаЗамены.ЗначениеЗамены, 200);
						Для Счетчик = 0 ПО МассивКороткихПодстрок.Количество() - 1 Цикл
							МассивКороткихПодстрок[Счетчик] = МассивКороткихПодстрок[Счетчик] + "_~_";
						КонецЦикла;	  
						Счетчик = 0;
						Для Каждого ОднаПодстрока Из МассивКороткихПодстрок Цикл
							Если Счетчик = 0 Тогда
								Док.Content.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
								Для Каждого Секция Из Док.Sections Цикл
									Для Каждого Верхний Из Секция.Headers Цикл 
										Если Верхний.Exists Тогда
											Верхний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
									Для Каждого Нижний Из Секция.Footers Цикл 
										Если Нижний.Exists Тогда
											Нижний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
								КонецЦикла;
							Иначе
								Док.Content.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
								Для Каждого Секция Из Док.Sections Цикл
									Для Каждого Верхний Из Секция.Headers Цикл 
										Если Верхний.Exists Тогда
											Верхний.Range.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
									Для Каждого Нижний Из Секция.Footers Цикл 
										Если Нижний.Exists Тогда
											Нижний.Range.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
								КонецЦикла;	
							КонецЕсли;
							Счетчик = Счетчик + 1;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				
				Док.Content.Find.Execute("_~_", , , , , , , , , "", 2);
				Док.Content.Find.Execute("_+_", , , , , , , , , "^p", 2);
				Для Каждого Секция Из Док.Sections Цикл
					Для Каждого Верхний Из Секция.Headers Цикл 
						Если Верхний.Exists Тогда
							Верхний.Range.Find.Execute("_~_", , , , , , , , , "", 2);
							Верхний.Range.Find.Execute("_+_", , , , , , , , , "^p", 2);
						КонецЕсли;
					КонецЦикла;
					Для Каждого Нижний Из Секция.Footers Цикл 
						Если Нижний.Exists Тогда
							Нижний.Range.Find.Execute("_~_", , , , , , , , , "", 2);
							Нижний.Range.Find.Execute("_+_", , , , , , , , , "^p", 2);
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
		Исключение
			Инфо = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЦикла; 	 
	
	Если Найти(WordApp.Build, "12.") = 1 ИЛИ Найти(WordApp.Build, "14.") = 1 Тогда
		Если Расширение = "docx" Тогда
			Док.SaveAs(НовыйПутьКФайлу, 12);                        
		Иначе
			Док.SaveAs(НовыйПутьКФайлу, 0);
		КонецЕсли;
	Иначе
	    Если Расширение = "docx" Тогда
			Док.SaveAs(НовыйПутьКФайлу, 109);                        
		Иначе
			Док.SaveAs(НовыйПутьКФайлу);
		КонецЕсли;
	КонецЕсли;
	
	Док.Saved = Истина;
	Док.Close(); 
	WordApp.Quit();	
	WordApp = Неопределено;
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	
	УдалитьФайлы(ПутьКФайлуНаДиске);	
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

//Заполняет документ MSWord с использованием настроек автозаполнения
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив настроек замены
//			ДвоичныеДанныеФайла - бинарные данные текущей версии файла
//Возвращает:Путь на диске компьютера, куда сохранена заполненная версия файла
Функция ЗаполнитьФайлMSWordПоДвоичнымДанным(Расширение, НастройкиЗамены, ДвоичныеДанныеФайла) Экспорт
	
	Если НастройкиЗамены.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ДвоичныеДанныеФайла <> Неопределено Тогда
		Если НРег(Расширение) = "doc" Тогда 
			ПутьКФайлуНаДиске = ПолучитьИмяВременногоФайла(Расширение);
			ДвоичныеДанныеФайла.Записать(ПутьКФайлуНаДиске);
			Возврат ЗаполнитьФайлMSWordПоАдресуФайла(Расширение, НастройкиЗамены, ПутьКФайлуНаДиске);
		ИначеЕсли НРег(Расширение) = "docx" Тогда
			Попытка
				Возврат ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, Расширение, НастройкиЗамены, Ложь);
			Исключение
				Возврат ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, Расширение, НастройкиЗамены, Истина);
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

//Осуществляет поиск в файле MSWord полей и строк, которые указаны в массиве автозамен
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив автозамен в файле
//			ДвоичныеДанныеФайла - ДвоичныеДанные последней версии файла
//Возвращает:Текст сообщения об ошибке с использованием НСтр() с перечислением отсутствующих полей и строк, если какое-либо поле или строка не найдена
//			 ПустаяСтрока, если все поля и строки присутствуют в файле
Функция ПроверитьНаличиеПолейИСтрокВФайлеMSWord(Расширение, НастройкиЗамены, ДвоичныеДанныеФайла) Экспорт
	
	ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(Расширение);
	ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
	
	Если НРег(Расширение) = "doc" Тогда
		Попытка
			WordApp = Новый COMОбъект("Word.Application");    
		Исключение
			УдалитьФайлы(ИмяФайлаСПутем);
			Возврат НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'; en = 'Error working with MS Word application. It is necessary to check the correct installation.'");
		КонецПопытки;
		
		Док = WordApp.Documents.Add(ИмяФайлаСПутем); 
	КонецЕсли;
	
	ЕстьОшибкаПоПолям = Ложь;
	ОписаниеОшибкиПоля = НСтр("ru = 'Следующие поля отсутствуют в шаблоне:'; en = 'Following fields are not in the template:'") + Символы.ВК;
	
	ЕстьОшибкаПоСтрокам = Ложь;
	ОписаниеОшибкиСтроки = НСтр("ru = 'Следующие строки отсутствуют в шаблоне:'; en = 'Following rows are not in the template:'") + Символы.ВК;
	
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		
		Если ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) И
			 ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
			Возврат НСтр("ru = 'Необходимо указать либо строку для замены, либо поле для замены'; en = 'You must specify a string or field for replacement'");
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
			ПолеНайдено = Ложь;
			Если НРег(Расширение) = "doc" Тогда 
				Для Каждого Field из Док.FormFields Цикл
					Если (Field.Name = НастройкаЗамены.ТермДляЗамены) Тогда
						ПолеНайдено = Истина;
					КонецЕсли;
				КонецЦикла;
			ИначеЕсли НРег(Расширение) = "docx" Тогда
				ПолеНайдено = ПроверитьНаличиеПоляВФайлеDocX(НастройкаЗамены.ТермДляЗамены, ИмяФайлаСПутем);
			КонецЕсли;
			
			Если НЕ ПолеНайдено Тогда 
				ОписаниеОшибкиПоля = ОписаниеОшибкиПоля + НастройкаЗамены.ТермДляЗамены + Символы.ВК;
				ЕстьОшибкаПоПолям = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
			Если НРег(Расширение) = "doc" Тогда
				РезультатЕстьВВерхнемКолонтитуле = Ложь;
				РезультатЕстьВНижнемКолонтитуле = Ложь;
				Для Каждого Секция Из WordApp.ActiveDocument.Sections Цикл
					Для Каждого Верхний Из Секция.Headers Цикл 
						Если Верхний.Exists Тогда
							РезультатЕстьВВерхнемКолонтитуле = Верхний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина);
							Если РезультатЕстьВВерхнемКолонтитуле Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					Для Каждого Нижний Из Секция.Footers Цикл 
						Если Нижний.Exists Тогда
							РезультатЕстьВНижнемКолонтитуле = Нижний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина);
							Если РезультатЕстьВНижнемКолонтитуле Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
				Если НЕ WordApp.Selection.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина)
					И НЕ WordApp.Selection.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Ложь) 
					И Не РезультатЕстьВВерхнемКолонтитуле 
					И Не РезультатЕстьВНижнемКолонтитуле Тогда
					ОписаниеОшибкиСтроки = ОписаниеОшибкиСтроки + НастройкаЗамены.ЗаменяемаяСтрока + Символы.ВК;
					ЕстьОшибкаПоСтрокам = Истина;
				Иначе 
					WordApp.Selection.Collapse();
				КонецЕсли;
			ИначеЕсли НРег(Расширение) = "docx" Тогда 
				ПолеНайдено = ПроверитьНаличиеСтрокиВФайлеDocX(НастройкаЗамены.ЗаменяемаяСтрока, ИмяФайлаСПутем);
				Если НЕ ПолеНайдено Тогда
					ОписаниеОшибкиСтроки = ОписаниеОшибкиСтроки + НастройкаЗамены.ЗаменяемаяСтрока + Символы.ВК;
					ЕстьОшибкаПоСтрокам = Истина;	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;

	Если НРег(Расширение) = "doc" Тогда
		Док.Saved = Истина;
		Док.Close(); 
		WordApp.Quit();
		WordApp = Неопределено;
	КонецЕсли;

	УдалитьФайлы(ИмяФайлаСПутем);
	
	Если ЕстьОшибкаПоПолям И
		 ЕстьОшибкаПоСтрокам Тогда
		Возврат ОписаниеОшибкиПоля + Символы.ВК + ОписаниеОшибкиСтроки;
	ИначеЕсли ЕстьОшибкаПоПолям Тогда
		Возврат ОписаниеОшибкиПоля;
	ИначеЕсли ЕстьОшибкаПоСтрокам Тогда
		Возврат ОписаниеОшибкиСтроки;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

//Выполняет поиск всех полей в файле формата MSWord 2003-
Функция НайтиВсеПоляВФайлеMSWord(Расширение,ДвоичныеДанныеФайла) Экспорт
	
	РезультатПоиска = Новый Массив();
	Если Расширение = "doc" Тогда
		Попытка
			WordApp = Новый COMОбъект("Word.Application");
		Исключение
			Сообщение = НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'; en = 'Error working with MS Word application. It is necessary to check the correct installation.'");
			ВызватьИсключение(Сообщение);
		КонецПопытки;

		ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(Расширение);
		ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
		
		Док = WordApp.Documents.Add(ИмяФайлаСПутем);
		Для Каждого Field Из Док.FormFields Цикл
			Если РезультатПоиска.Найти(Field.Name) = Неопределено 
				И Найти(Field.Name, "_GoBack") = 0 Тогда
				РезультатПоиска.Добавить(Field.Name);
			КонецЕсли;
		КонецЦикла;
		
		Док.Saved = Истина;
		Док.Close(); 
		WordApp.Quit();
		WordApp = Неопределено;
		УдалитьФайлы(ИмяФайлаСПутем);
	ИначеЕсли Расширение = "docx" Тогда
        НайтиВсеПоляВФайлеDocX(ДвоичныеДанныеФайла, РезультатПоиска);
	КонецЕсли;
	
	Возврат РезультатПоиска;
	
КонецФункции

//Выполняет поиск указанной строки в файле формата MS Word 2003-
Функция ПроверитьНаличиеСтрокиВФайлеMSWord(ИмяФайлаСПутем, Строка, WordApp = Неопределено) Экспорт
	
	ЗакрыватьПриложение = Ложь;
	Если WordApp = Неопределено Тогда 
		
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
			Попытка
				WordApp = Новый COMОбъект("Word.Application");
			Исключение
				ВызватьИсключение(НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'; en = 'Error working with MS Word application. It is necessary to check the correct installation.'"));
			КонецПопытки;
		Иначе
			ВызватьИсключение(НСтр("ru = 'Работа с файлами MS Word возможна только в Windows. Обратитесь к администратору.'; en = 'Working with MS Word files is only possible in Windows. Contact your administrator.'"));	
		КонецЕсли;
		ЗакрыватьПриложение = Истина;
		
	КонецЕсли;

	Док = WordApp.Documents.Add(ИмяФайлаСПутем);
	Если Док.ProtectionType <> 2 Тогда
		Результат = WordApp.Selection.Find.Execute(Строка);
		Если Не Результат Тогда
			Для Каждого InlineShape Из WordApp.ActiveDocument.InlineShapes Цикл
				Если InlineShape.AlternativeText = Строка Тогда
					Результат = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	Док.Saved = Истина;
	Док.Close(); 
	Если ЗакрыватьПриложение Тогда
		WordApp.Quit();
		WordApp = Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////
//// РАБОТА С АВТОЗАПОЛНЕНИЕМ MS OFFICE 2007+

//заполняет поля и строки в файле MSWord формата 2007+
// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
//Функция ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен, ЗаменятьПространствоИмен = Истина) Экспорт
Функция ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен, ЗаменятьПространствоИмен = Истина, ра_ФайлСсылка = Неопределено) Экспорт
// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
	
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
	Возврат ра_ОбщегоНазначенияКлиентСервер.ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен, ЗаменятьПространствоИмен, ра_ФайлСсылка);
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	КопироватьФайл(СтарыйПутьКФайлу, СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//Заполнение полей в теле документа
	Если ЗаменятьПространствоИмен Тогда
		ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	КонецЕсли;
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document_update.xml");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	
	АдресXML = ВременнаяПапкаДляРазархивирования + "/word/document_update1.xml";

	ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен);
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();

	ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/word/document_update.xml", ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/document_update.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/document_update1.xml");
	
	// Заполнение полей в верхних колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЗаписьXML = Новый ЗаписьXML;
	СтрокаXML = Новый ЗаписьXML;
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Если ЗаменятьПространствоИмен Тогда
			ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		АдресXML = ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update1.xml";

		ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен);
		
		ЧтениеXML.Закрыть();
		ЗаписьXML.Закрыть();
		
		ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml", ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update1.xml");
	КонецЦикла;
	
	// Заполнение полей в нижних колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЗаписьXML = Новый ЗаписьXML;
	СтрокаXML = Новый ЗаписьXML;
	
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Если ЗаменятьПространствоИмен Тогда
			ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		
		АдресXML = ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update1.xml";
		
		ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен);
		
		ЧтениеXML.Закрыть();
		ЗаписьXML.Закрыть();
		
		ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml", ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update1.xml");
	КонецЦикла;
	
	Архиватор = Новый ЗаписьZipФайла(ВременныйZIPФайл, "", "");
	Архиватор.Добавить(ВременнаяПапкаДляРазархивирования + "\*.*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
	Архиватор.Записать();

	ПереместитьФайл(ВременныйZIPФайл, НовыйПутьКФайлу);
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);	
	
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	УдалитьФайлы(СтарыйПутьКФайлу);
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

Функция ПроверитьНаличиеПоляВФайлеDocX(ИмяПоля, ПутьКФайлу)
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(ПутьКФайлу, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ПутьКФайлу, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//поиск полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
		ЧтениеXML.Закрыть();
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
		УдалитьФайлы(ВременныйZIPФайл);
		Возврат Истина;
	КонецЕсли;
			
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml"); 
		Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
			ЧтениеXML.Закрыть();
			УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
			УдалитьФайлы(ВременныйZIPФайл);
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;	
			
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml"); 
		Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
			ЧтениеXML.Закрыть();
			УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
			УдалитьФайлы(ВременныйZIPФайл);
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	ЧтениеXML.Закрыть();
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ВременныйZIPФайл);
	Возврат Ложь;
	
КонецФункции

Функция НайтиПоле(ЧтениеXML, ИмяПоля)
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	ФлагНайденоПоле = Ложь;	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name" 
						И ИмяПоля = ЧтениеXML.Значение Тогда
						Возврат Истина;
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//Выполняет поиск указанной строки в файле MS Word формата 2007+
Функция ПроверитьНаличиеСтрокиВФайлеDocX(ИскомаяСтрока, ПутьКФайлу) Экспорт
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(ПутьКФайлу, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ПутьКФайлу, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//поиск строк в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	
	НайденаВТеле = Ложь;
	НайденаВКолонтитулах = Ложь;
	ФлагНайденаСтрока = Ложь;
	ФлагНайденаКартинка = Ложь;
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

			Если ЧтениеXML.Имя = "w:t" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;
			Если ЧтениеXML.Имя =  "w:drawing" Тогда
				ФлагНайденаКартинка = Истина;
			КонецЕсли;
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденаКартинка И ЧтениеXML.Имя = "name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если ИскомаяСтрока = СтрПоиска Тогда
							НайденаВТеле = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденаСтрока
				И Найти(ЧтениеXML.Значение, ИскомаяСтрока) > 0 Тогда
				ЧтениеXML.Закрыть();
				НайденаВТеле = Истина;
			Иначе
				ФлагНайденаСтрока = Ложь;
			КонецЕсли;  
		КонецЕсли;
	КонецЦикла;
	ЧтениеXML.Закрыть();	
	Если НЕ НайденаВТеле Тогда
		Для Счетчик = 1 по 10 Цикл
			Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
				Прервать;
			КонецЕсли;

			ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml"); 

			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

					Если ЧтениеXML.Имя = "w:t" Тогда
						ФлагНайденаСтрока = Истина;
					КонецЕсли;

				ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
					Если ФлагНайденаСтрока
						И ЧтениеXML.Значение = ИскомаяСтрока Тогда
						ЧтениеXML.Закрыть();
						НайденаВКолонтитулах = Истина;
					Иначе
						ФлагНайденаСтрока = Ложь;
					КонецЕсли;  
				КонецЕсли;
			КонецЦикла;
			
			ЧтениеXML.Закрыть();			
		КонецЦикла;
		Если НЕ НайденаВКолонтитулах Тогда
			Для Счетчик = 1 по 10 Цикл
				Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
					Прервать;
				КонецЕсли;

				ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml"); 

				Пока ЧтениеXML.Прочитать() Цикл
					Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

						Если ЧтениеXML.Имя = "w:t" Тогда
							ФлагНайденаСтрока = Истина;
						КонецЕсли;

					ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
						Если ФлагНайденаСтрока
							И ЧтениеXML.Значение = ИскомаяСтрока Тогда
							ЧтениеXML.Закрыть();
							НайденаВКолонтитулах = Истина;
						Иначе
							ФлагНайденаСтрока = Ложь;
						КонецЕсли;  
					КонецЕсли;
				КонецЦикла;
				
				ЧтениеXML.Закрыть();			
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НайденаВКолонтитулах ИЛИ НайденаВТеле;
	
КонецФункции

Процедура НайтиВсеПоляВФайлеDocX(ДвоичныеДанныеФайла, МассивПолей)
	
	Если Не ЗначениеЗаполнено(ДвоичныеДанныеФайла) Тогда 
		Возврат;
	КонецЕсли;
	
	ВременныйФайл = ПолучитьИмяВременногоФайла("docx");
	ДвоичныеДанныеФайла.Записать(ВременныйФайл);
	
	КопироватьФайл(ВременныйФайл, СтрЗаменить(ВременныйФайл, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ВременныйФайл, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//поиск полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	НайтиВсеПоля(ЧтениеXML, МассивПолей);	
	ЧтениеXML.Закрыть();
	
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		НайтиВсеПоля(ЧтениеXML, МассивПолей);
		ЧтениеXML.Закрыть();
	КонецЦикла;
	
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		НайтиВсеПоля(ЧтениеXML, МассивПолей);
		ЧтениеXML.Закрыть();
	КонецЦикла;
	
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ВременныйZIPФайл);
	УдалитьФайлы(ВременныйФайл);
	
КонецПроцедуры

Функция НайтиВсеПоля(ЧтениеXML, МассивПолей)
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	ФлагНайденоПоле = Ложь;	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name" 
						И Найти(ЧтениеXML.Значение, "_GoBack") = 0 
						И Лев(ЧтениеXML.Значение, 1) <> "_" Тогда 
						МассивПолей.Добавить(ЧтениеXML.Значение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;	
	
КонецФункции

//Осуществляет выборку всех полей в файле MSWord
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			ДвоичныеДанныеФайла - двоичные данные файла
//Возвращает:Массив наименований полей. Массив пустой, если в файле нет полей.
//Выполняет замену полей и строк в документе MSOffice 2007+ (OpenXML)
//Параметры:ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//			ЗаписьXML - объект ЧтениеXML, содержащий в себе файл с измененными данными, составляющий OpenOffice документ
//			МассивДанныхДляАвтоЗамен - массив настроек для заполнения файла данными
Процедура ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен) Экспорт
	
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
	ра_ОбщегоНазначенияКлиентСервер.ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен);
	Возврат;
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
	
	// Получаем количество строк в таблице товары, если она заполнена.
	КоличествоСтрок = 0;
	Для Каждого Настройка Из МассивДанныхДляАвтоЗамен Цикл 
		Если Настройка.НомерКолонкиТабличнойЧасти = 1 Тогда 
			КоличествоСтрок = Настройка.ЗначениеЗамены.Количество();
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	ФлагНайденоПоле = Ложь;
	ФлагНайденаСтрока = Ложь;
	
	ПереводСтроки = Ложь; ВозможенПереводСтроки = Ложь;
	СтрЗамены = "";
	СтрПоиска = "";
	ТекстБылЗаписан = Ложь;
	
	СтрокаТаблицы = 0; НомерКолонки = 0;
	ФлагНайденаТаблица = Ложь; ФлагНайденаНашаТаблица = Ложь;
	ФлагНайденаСтрокаТаблицы = Ложь;
	ПервыйТег = КоличествоСтрок > 1; ПропуститьСтроку = Ложь;
	СтрокаXMLОткрыт = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			// Найдено предполагаемое поле для замены
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
				СкрытаяЗакладка = Ложь;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:t" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;
			
			// Предполагаем, что найдена наша таблица для замены
			Если ЧтениеXML.Имя = "w:tbl" И КоличествоСтрок > 0 Тогда
				ФлагНайденаТаблица = Истина;
				СтрокаТаблицы = 0;
			КонецЕсли;
			
			// Предполагаем, что найдена строка нашей таблица для замены
			Если ЧтениеXML.Имя = "w:tr" И ФлагНайденаТаблица Тогда 
				Если СтрокаТаблицы > КоличествоСтрок И ФлагНайденаНашаТаблица Тогда 
					ПропуститьСтроку = Истина;
					Продолжить;
				КонецЕсли;
				
				СтрокаТаблицы = СтрокаТаблицы + 1;
				
				Если СтрокаТаблицы = 2 И КоличествоСтрок > 1 Тогда
					ФлагНайденаСтрокаТаблицы = Истина;
				КонецЕсли;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:tc" Тогда 
				НомерКолонки = НомерКолонки + 1;
			КонецЕсли;
			
			// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
			Если ЧтениеXML.Имя = "w:cr" И ВозможенПереводСтроки Тогда
				ПереводСтроки = Истина;
				Продолжить;
			КонецЕсли;
			
			Если ПропуститьСтроку Тогда 
				Продолжить;
			КонецЕсли;
			
			ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);
			
			Если ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда
				Если Не СтрокаXMLОткрыт Тогда 
					КопияСтрокиXML = СоздатьНовуюЗапись(АдресXML);
					СтрокаXMLОткрыт = Истина;
				КонецЕсли;
				
				КопияСтрокиXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);
			КонецЕсли;
			
			// Читаем и записываем атрибуты тега
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name"
						И Найти(ЧтениеXML.Значение, "_GoBack") = 0 Тогда
						СтрПоиска = ЧтениеXML.Значение;
						
						// Скрытые закладки начинаются с символа "_"
						Если Лев(ЧтениеXML.Значение, 1) = "_" Тогда 
							СкрытаяЗакладка = Истина;
						КонецЕсли;
						
						Если ФлагНайденаТаблица И Не ФлагНайденаНашаТаблица Тогда
							Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
								Если НастройкаЗамены.ТермДляЗамены = СтрПоиска 
									И НастройкаЗамены.НомерКолонкиТабличнойЧасти > 0 Тогда
									ФлагНайденаНашаТаблица = Истина;
									Прервать;
								КонецЕсли;
							КонецЦикла;
						КонецЕсли;
						
						Если ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда 
							КопияСтрокиXML.ЗаписатьАтрибут(ЧтениеXML.Имя, Лев(СтрПоиска, 19) + "1");
						КонецЕсли;
					
					ИначеЕсли ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда 
						КопияСтрокиXML.ЗаписатьАтрибут(ЧтениеXML.Имя, ЧтениеXML.Значение);
					КонецЕсли;
					
					ЗаписьXML.ЗаписатьАтрибут(ЧтениеXML.Имя, ЧтениеXML.Значение);
				КонецЦикла
			КонецЕсли;
			
			ПервыйТег = Ложь;
			
		// Текст тега
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ПереводСтроки И ВозможенПереводСтроки Тогда
				ЗаписьXML.ЗаписатьБезОбработки("");
				
			// Перезаполняем поля таблицы
			ИначеЕсли ФлагНайденаНашаТаблица И ФлагНайденоПоле И ФлагНайденаСтрока Тогда
				Если ПропуститьСтроку Тогда 
					Продолжить;
				КонецЕсли;
				
				СтрЗамены = ЧтениеXML.Значение;
				БылаВыполненаЗамена = Ложь;
				
				Если ЗначениеЗаполнено(СтрЗамены) Тогда 
					Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
						ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
						Если ИмяРеквизита <> СтрПоиска Тогда
							Продолжить;
						КонецЕсли;
						
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены[СтрокаТаблицы - 2].Значение;
						БылаВыполненаЗамена = Истина;
						Прервать;
					КонецЦикла;
				КонецЕсли;
				
				Если БылаВыполненаЗамена И Найти(СтрЗамены, Символы.ПС) > 0 Тогда
					СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "<w:cr/>");
					Если СтрЗамены <> ЧтениеXML.Значение Тогда
						ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
						
						Если ФлагНайденаСтрокаТаблицы Тогда 
							КопияСтрокиXML.ЗаписатьБезОбработки(СтрЗамены);
						КонецЕсли;
					Иначе
						ЗаписьXML.ЗаписатьТекст(СтрЗамены);
						
						Если ФлагНайденаСтрокаТаблицы Тогда 
							КопияСтрокиXML.ЗаписатьТекст(СтрЗамены);
						КонецЕсли;
					КонецЕсли;
				Иначе
					ЗаписьXML.ЗаписатьТекст(СтрЗамены);
					
					Если ФлагНайденаСтрокаТаблицы Тогда 
						КопияСтрокиXML.ЗаписатьТекст(СтрЗамены);
					КонецЕсли;
				КонецЕсли;
				
				СтрЗамены = "";
				ФлагНайденоПоле = Ложь;
				
			// Перезаполняем поля документа
			ИначеЕсли ФлагНайденоПоле И ФлагНайденаСтрока Тогда
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
					Если ИмяРеквизита = СтрПоиска Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				СтрЗаменыССимволамиПС = СтрЗамены;
				СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "<w:cr/>");
				
				Если ЗначениеЗаполнено(СтрЗамены) Тогда
					Если СтрЗамены <> СтрЗаменыССимволамиПС Тогда
						ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
					Иначе
						ЗаписьXML.ЗаписатьТекст(СтрЗамены);
					КонецЕсли;
				ИначеЕсли Не СкрытаяЗакладка И СтрЗамены <> ЧтениеXML.Значение Тогда
					ЗаписьXML.ЗаписатьТекст(" ");
				Иначе
					ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
				КонецЕсли;
				
				ФлагНайденоПоле = Ложь;
				СтрЗамены = "";
				ВозможенПереводСтроки = Истина;
				
			// Перезаполняем строки документа
			ИначеЕсли ФлагНайденаСтрока Тогда
				СтрЗамены = ЧтениеXML.Значение;
				БылаВыполненаЗамена = Ложь;
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если Не ЗначениеЗаполнено(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если Найти(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока) > 0 Тогда 
						СтрЗамены = СтрЗаменить(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока, НастройкаЗамены.ЗначениеЗамены);
						БылаВыполненаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				Если БылаВыполненаЗамена И Найти(СтрЗамены, Символы.ПС) > 0 Тогда
					СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "<w:cr/>");
					Если СтрЗамены <> ЧтениеXML.Значение Тогда
						ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
					Иначе
						ЗаписьXML.ЗаписатьТекст(СтрЗамены);
					КонецЕсли;
				Иначе
					ЗаписьXML.ЗаписатьТекст(СтрЗамены);
				КонецЕсли;
			Иначе
				ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
				
				Если ФлагНайденаСтрокаТаблицы Тогда 
					КопияСтрокиXML.ЗаписатьТекст(ЧтениеXML.Значение);
				КонецЕсли;
			КонецЕсли;
			
		// Читаем и записываем конец тега
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
			Если ЧтениеXML.Имя = "w:cr" И ВозможенПереводСтроки Тогда
				Продолжить;
			КонецЕсли;
			
			Если ФлагНайденаТаблица И ЧтениеXML.Имя = "w:tbl" Тогда
				ФлагНайденаТаблица = Ложь;
				ФлагНайденаНашаТаблица = Ложь;
				ПропуститьСтроку = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			
			Если ПропуститьСтроку Тогда 
				Продолжить;
			КонецЕсли;
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ФлагНайденаСтрокаТаблицы Тогда
				КопияСтрокиXML.ЗаписатьКонецЭлемента();
			КонецЕсли;
			
			Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:bookmarkEnd" Тогда
				ФлагНайденоПоле = Ложь; СкрытаяЗакладка = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				ФлагНайденаСтрока = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:tr" И ФлагНайденаТаблица Тогда 
				НомерКолонки = 0;
				ФлагНайденаСтрокаТаблицы = Ложь;
				
				Если СтрокаТаблицы = 2 И КоличествоСтрок > 1 Тогда 
					КопияСтрокиXML.ЗаписатьКонецЭлемента();
					КопияСтрокиXML.Закрыть();
					СтрокаXMLОткрыт = Ложь;
					ЗаменитьПространствоИменR(АдресXML);
					
					// Добавление в документ копии первой строки таблицы, с последующим заполнением данными документа
					Если ФлагНайденаНашаТаблица Тогда 
						Пока СтрокаТаблицы - 1 < КоличествоСтрок Цикл 
							ЧтениеСтрокиXML = Новый ЧтениеXML();
							ЧтениеСтрокиXML.ОткрытьФайл(АдресXML);
							ЧтениеСтрокиXML.ИгнорироватьПробелы = Ложь;
							ФлагНайденоПоле = Ложь; ФлагНайденаСтрока = Ложь;
							
							Пока ЧтениеСтрокиXML.Прочитать() Цикл
								Если ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
									
									// Первый тег пропускаем
									Если ЧтениеСтрокиXML.Имя = "w:document" Тогда 
										Продолжить;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:bookmarkStart" Тогда
										ФлагНайденоПоле = Истина; 
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:t" Тогда
										ФлагНайденаСтрока = Истина;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:tr" Тогда 
										СтрокаТаблицы = СтрокаТаблицы + 1;
									КонецЕсли;
									Если ЧтениеСтрокиXML.Имя = "w:tc" Тогда 
										НомерКолонки = НомерКолонки + 1;
									КонецЕсли;
					
									// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
									Если ЧтениеСтрокиXML.Имя = "w:cr" И ВозможенПереводСтроки Тогда
										ПереводСтроки = Истина;
										Продолжить;
									КонецЕсли;
					
									ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеСтрокиXML.Имя);
									Если ЧтениеСтрокиXML.КоличествоАтрибутов() > 0 Тогда
										Пока ЧтениеСтрокиXML.ПрочитатьАтрибут() Цикл
											
											Если ФлагНайденоПоле И ЧтениеСтрокиXML.Имя = "w:name"
												И Найти(ЧтениеXML.Значение, "_GoBack") = 0 Тогда
												СтрПоиска = ЧтениеСтрокиXML.Значение;
											КонецЕсли;
											
											ЗаписьXML.ЗаписатьАтрибут(ЧтениеСтрокиXML.Имя, ЧтениеСтрокиXML.Значение);
										КонецЦикла
									КонецЕсли;
									
								ИначеЕсли ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.Текст Тогда
									Если ПереводСтроки И ВозможенПереводСтроки Тогда
										ЗаписьXML.ЗаписатьБезОбработки("");
										
									ИначеЕсли ФлагНайденоПоле И ФлагНайденаСтрока Тогда 
										
										СтрЗамены = ЧтениеСтрокиXML.Значение;
										БылаВыполненаЗамена = Ложь;
										Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
											ИмяРеквизита = Лев(НастройкаЗамены.ТермДляЗамены, 19) + "1";
											Если ИмяРеквизита <> СтрПоиска Тогда
												Продолжить;
											КонецЕсли;
											
											СтрЗамены = НастройкаЗамены.ЗначениеЗамены[СтрокаТаблицы - 2].Значение;
											БылаВыполненаЗамена = Истина;
											Прервать;
										КонецЦикла;
										
										Если БылаВыполненаЗамена И Найти(СтрЗамены, Символы.ПС) > 0 Тогда
											СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "<w:cr/>");
											Если СтрЗамены <> ЧтениеСтрокиXML.Значение Тогда
												ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
											Иначе
												ЗаписьXML.ЗаписатьТекст(СтрЗамены);
											КонецЕсли;
										Иначе
											ЗаписьXML.ЗаписатьТекст(СтрЗамены);
										КонецЕсли;
										
										СтрЗамены = "";
										ФлагНайденоПоле = Ложь;
									Иначе 
										ЗаписьXML.ЗаписатьТекст(ЧтениеСтрокиXML.Значение);
									КонецЕсли;
									
								ИначеЕсли ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
									// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
									Если ЧтениеСтрокиXML.Имя = "w:cr" И ВозможенПереводСтроки Тогда
										Продолжить;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:document" Тогда 
										Продолжить;
									КонецЕсли;
									
									ЗаписьXML.ЗаписатьКонецЭлемента();
									
									Если ФлагНайденоПоле И ЧтениеСтрокиXML.Имя = "w:bookmarkEnd" Тогда
										ФлагНайденоПоле = Ложь;
										СтрЗамены = "";
									КонецЕсли;
									Если ФлагНайденаСтрока Тогда
										ФлагНайденаСтрока = Ложь;
										СтрЗамены = "";
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:tr" Тогда 
										НомерКолонки = 0;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
						
							ЧтениеСтрокиXML.Закрыть();
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если ВозможенПереводСтроки И ЧтениеXML.Имя = "w:bookmarkEnd" Тогда
				ПереводСтроки = Ложь;
				ВозможенПереводСтроки = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Создает новый файл XML
Функция СоздатьНовуюЗапись(ИмяФайла)
	
	ФайлНаДиске = Новый Файл(ИмяФайла);
	Если ФайлНаДиске.Существует() Тогда
		ПереместитьФайл(ИмяФайла, ИмяФайла + "1");
		УдалитьФайлы(ИмяФайла);
		
		НовоеЧтениеXML = Новый ЧтениеXML();
		НовоеЧтениеXML.ОткрытьФайл(ИмяФайла + "1");
		НовоеЧтениеXML.ИгнорироватьПробелы = Ложь;
		
		СтрокаXML = Новый ЗаписьXML;
		СтрокаXML.ОткрытьФайл(ИмяФайла);
		СтрокаXML.ЗаписатьОбъявлениеXML();
		
		Пока НовоеЧтениеXML.Прочитать() Цикл
			СтрокаXML.ЗаписатьТекущий(НовоеЧтениеXML);
			Прервать;
		КонецЦикла;
		
		НовоеЧтениеXML.Закрыть();
		УдалитьФайлы(ИмяФайла + "1");
		
	Иначе 
		СтрокаXML = Новый ЗаписьXML;
		СтрокаXML.ОткрытьФайл(ИмяФайла);
		СтрокаXML.ЗаписатьОбъявлениеXML(); 
	КонецЕсли;
	
	Возврат СтрокаXML;
	
КонецФункции

// Выполняет в указанном xml замену пространства имен "r" на "dor".
Процедура ЗаменитьПространствоИменR(ИмяФайла) Экспорт
	
	ОбъектЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.UTF8);
	Строка = ОбъектЧтениеТекста.Прочитать();
	ОбъектЧтениеТекста.Закрыть();
	УдалитьФайлы(ИмяФайла);
	
	Пока Найти(Строка, "xmlns:lсrdo") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:lсrdo", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " lсrdo:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " lсrdo:", " r:");
	КонецЦикла;
	Пока Найти(Строка, "xmlns:rdo") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:rdo", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " rdo:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " rdo:", " r:");
	КонецЦикла;
	Пока Найти(Строка, "xmlns:dor") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:dor", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " dor:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " dor:", " r:");
	КонецЦикла;
	
	Строка = СтрЗаменить(Строка, "xmlns:r", "xmlns:dor");
	Строка = СтрЗаменить(Строка, " r:", " dor:");
	
	ОбъектЗапись = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.UTF8);
	ОбъектЗапись.Записать(Строка);
	ОбъектЗапись.Закрыть();
	
КонецПроцедуры

////////////////////////////////////////////////////
//// РАБОТА С OPEN OFFICE

// Выполняет поиск указанного элемента в файла OpenOffice Writer
//
// Параметры:
//  ПутьКФайлу - Строка - путь к файлу на диске на клиенте или на сервере, в зависимости от того,
//						откуда вызывается функция
//  ИскомыеДанные - Строка - имя поля или строка, которую необходимо найти
//  ТипИскомыхДанных - Строка - если выполняется поиск строки, то необходимо указать "Строка", если поле - "Поле"
//
// Возвращаемое значение:
//  Булево - Признак того, что искомый элемент найден в файле.
Функция НайтиДанныеВФайлеOpenOfficeWriter(ПутьКФайлу, ИскомыеДанные, ТипИскомыхДанных) Экспорт
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(НРег(ПутьКФайлу), "odt", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(НРег(ПутьКФайлу), "odt", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();
	ЧтениеXML = Новый ЧтениеXML();
	
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content.xml");
	РезультатПроверкиТела = АвтозаполнениеШаблоновФайловКлиентСервер.ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(ЧтениеXML, ИскомыеДанные, ТипИскомыхДанных);
	ЧтениеXML.Закрыть();
	
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/Styles.xml");
	РезультатПроверкиКолонтитулы = АвтозаполнениеШаблоновФайловКлиентСервер.ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(ЧтениеXML, ИскомыеДанные, ТипИскомыхДанных);
	ЧтениеXML.Закрыть();
	
	Если ПустаяСтрока(РезультатПроверкиТела)
		ИЛИ ПустаяСтрока(РезультатПроверкиКолонтитулы) Тогда
		Найдено = Истина;
	Иначе
		Найдено = Ложь;
	КонецЕсли;
	
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ИмяФайлаСПутемZIP);	
	
	Возврат Найдено;
	
КонецФункции

//Выполняет замену полей и строк в документе OpenOffice Writer
//Параметры:ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//			ЗаписьXML - объект ЧтениеXML, содержащий в себе файл с измененными данными, составляющий OpenOffice документ
//			МассивДанныхДляАвтоЗамен - массив настроек для заполнения файла данными
Процедура ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(ЧтениеXML,ЗаписьXML,МассивДанныхДляАвтоЗамен) Экспорт
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	ФлагНайденоПоле = Ложь;
	ФлагНайденаСтрока = Ложь;
	СтрЗамены = "";
	СтрПоиска = "";
	ТекстБылЗаписан = Ложь;
	СтрокаСтиля = "";
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "text:variable-set" Тогда
				ФлагНайденоПоле = Истина;
			КонецЕсли;

			Если ЧтениеXML.Имя = "text:p" ИЛИ ЧтениеXML.Имя = "text:span" Тогда
				ФлагНайденаСтрока = Истина;
				
			КонецЕсли;

			ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
					КонецЕсли;
					Если ЧтениеXML.Имя = "text:style-name" Тогда
						СтрокаСтиля = "text:style-name = """ + ЧтениеXML.Значение + """";
					КонецЕсли;
					ЗаписьXML.ЗаписатьАтрибут(ЧтениеXML.Имя,ЧтениеXML.Значение); 
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденоПоле Тогда
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если НастройкаЗамены.ТермДляЗамены = СтрПоиска Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
					КонецЕсли;
				КонецЦикла;
				
				ЗаписьXML.ЗаписатьТекст(СтрЗамены);
				ТекстБылЗаписан = Истина;
			ИначеЕсли ФлагНайденаСтрока Тогда
				СтрЗамены = ЧтениеXML.Значение;
				БылаВыполненаЗамена = Ложь;
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если Не ЗначениеЗаполнено(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если Найти(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока) > 0 Тогда 
						СтрЗамены = СтрЗаменить(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока, НастройкаЗамены.ЗначениеЗамены);
						БылаВыполненаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				Если БылаВыполненаЗамена И Найти(СтрЗамены, Символы.ПС) > 0 Тогда
					СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "</text:p><text:p " + СтрокаСтиля + ">");
					Если СтрЗамены <> ЧтениеXML.Значение Тогда
						ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
					Иначе
						ЗаписьXML.ЗаписатьТекст(СтрЗамены);
					КонецЕсли;
				Иначе
					ЗаписьXML.ЗаписатьТекст(СтрЗамены);
                КонецЕсли;
			Иначе
				ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
			КонецЕсли;  
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если НЕ ТекстБылЗаписан И ФлагНайденоПоле Тогда
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если НастройкаЗамены.ТермДляЗамены = СтрПоиска Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
					КонецЕсли;
				КонецЦикла;
				ЗаписьXML.ЗаписатьТекст(СтрЗамены);	
			КонецЕсли;
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ФлагНайденоПоле Тогда
				ФлагНайденоПоле = Ложь;
				ТекстБылЗаписан = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				ФлагНайденаСтрока = Ложь;
				СтрЗамены = "";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

//Проверяет наличие полей для ввода и текстовых строк в OpenOffice Writer документе
//Параметры:ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//			ПолеДляПоиска - имя искомого поля либо искомая строка
//			РежимПоиска - режим поиска. Допустимые значения - "Поле" и "Строка"
//Возвращает:ПустаяСтрока, если искомое поле или строка найдены
//			 Значение параметра ПолеДляПоиска, если искомые данные не найдены
Функция ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(ЧтениеXML, ПолеДляПоиска, РежимПоиска) Экспорт
	
	ФлагНайденоПоле = Ложь;
	ФлагНайденаСтрока = Ложь;
	ФлагНайденаКартинка = Ложь;
	СтрПоиска = "";

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если РежимПоиска = "Поле" Тогда
				Если ЧтениеXML.Имя = "text:variable-set" Тогда
					ФлагНайденоПоле = Истина;
				КонецЕсли;
			ИначеЕсли РежимПоиска = "Строка" Тогда
				Если ЧтениеXML.Имя = "text:p" Тогда
					ФлагНайденаСтрока = Истина;
				КонецЕсли;
				Если ЧтениеXML.Имя = "draw:frame" Тогда
					ФлагНайденаКартинка = Истина;
				КонецЕсли;
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если ПолеДляПоиска = СтрПоиска Тогда
							Возврат "";
						КонецЕсли;
					КонецЕсли;
					Если ФлагНайденаКартинка И ЧтениеXML.Имя = "draw:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если ПолеДляПоиска = СтрПоиска Тогда
							Возврат "";
						КонецЕсли;	
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденоПоле Тогда
				Если ПолеДляПоиска = СтрПоиска Тогда
					Возврат "";
				КонецЕсли;
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				Если СтрЧислоВхождений(ЧтениеXML.Значение, ПолеДляПоиска) > 0 Тогда
					Возврат "";
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:variable-set" Тогда
				ФлагНайденоПоле = Ложь;
			КонецЕсли; 
			Если ФлагНайденаСтрока И ЧтениеXML.Имя = "text:p" Тогда
				ФлагНайденаСтрока = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПолеДляПоиска;
	
КонецФункции

//Осуществляет поиск полей (переменных) в файле OpenOfficeWriter
//Параметры:ЧтениеXML - объект типа ЧтениеXML, в который загружена часть файла OpenOffice.
//						content.xml - тело файла
//						styles.xml - верхний и нижний колонтитулы
//Возвращает:Массив наименований полей в указанной части файла. Массив пустой, если полей не найдено.
Функция НайтиПоляВФайлеOpenOfficeWriter(ЧтениеXML) Экспорт
	
	ДанныеДляВозврата = Новый Массив();
	ФлагНайденоПоле = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "text:variable-set" Тогда
				ФлагНайденоПоле = Истина;
			КонецЕсли;
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						ДанныеДляВозврата.Добавить(ЧтениеXML.Значение);
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если ФлагНайденоПоле Тогда
				ФлагНайденоПоле = Ложь;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДанныеДляВозврата;
	
КонецФункции

//Выполняет замену данных в документе OpenOffice Writer
//Параметры:СтарыйПутьКФайлу - путь на диске, по которому выгружена текущая версия файла
//			ТекущаяВерсияРасширение - расширение файла
//			Файл - ссылка на объект файл, в котором следует выполнить замену
//			МассивДанныхДляАвтоЗамен - массив настроек для заполнения файла данными
//Возвращает:Путь на диске к заполненному файлу
Функция ЗаполнитьФайлOpenOfficeWriter(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен) Экспорт	
	
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	КопироватьФайл(СтарыйПутьКФайлу, СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//Заполнение полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content_update.xml");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
		
	ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(ЧтениеXML, ЗаписьXML, МассивДанныхДляАвтоЗамен);
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();

	ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/content_update.xml", ВременнаяПапкаДляРазархивирования + "/content.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/content_update.xml");

	//заполнение полей в колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/styles.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/styles_update.xml");
	ЗаписьXML.ЗаписатьОбъявлениеXML(); 

	ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(ЧтениеXML, ЗаписьXML, МассивДанныхДляАвтоЗамен);
	
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();
	
	ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/styles_update.xml", ВременнаяПапкаДляРазархивирования + "/styles.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/styles_update.xml");
	
	Архиватор = Новый ЗаписьZipФайла(ВременныйZIPФайл, "", "");
	Архиватор.Добавить(ВременнаяПапкаДляРазархивирования + "\*.*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
	Архиватор.Записать();

	ПереместитьФайл(ВременныйZIPФайл, НовыйПутьКФайлу);
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);	
	
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	УдалитьФайлы(СтарыйПутьКФайлу);
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

////////////////////////////////////////////////////
//// ПРОЧИЕ ФУНКЦИИ

//Осуществляет замену строк в текстовом документе
//Параметры:СтарыйПутьКФайлу - путь к выгруженной версии файла, в котором осуществляется замена
//			ТекущаяВерсияРасширение - расширение файла, в котором производится замена
//			МассивДанныхДляАвтоЗамен - массив данных для замены. Получается функцией ПолучитьМассивАвтозаполненийШаблона
//Возвращает:Путь к измененному файлу, если замена прошла успешно
//			 ПустаяСтрока, если содержимое исходного файла не удалось прочитать
Функция ЗаполнитьТекстовыйФайл(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен) Экспорт
	
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	Текст = Новый ЧтениеТекста(СтарыйПутьКФайлу);
	Стр = Текст.Прочитать();
	Текст.Закрыть();
	Если Стр <> Неопределено И 
		НЕ ПустаяСтрока(Стр) Тогда 
		
		Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
			Стр = СтрЗаменить(Стр, НастройкаЗамены.ЗаменяемаяСтрока, НастройкаЗамены.ЗначениеЗамены);
		КонецЦикла;
		
		РезультатЗамены = Новый ЗаписьТекста(НовыйПутьКФайлу);
		РезультатЗамены.Записать(Стр);
		РезультатЗамены.Закрыть();
		
		ДвоичныеДанныеЗаполненногоФайлам = Новый ДвоичныеДанные(НовыйПутьКФайлу);
		УдалитьФайлы(СтарыйПутьКФайлу);
		УдалитьФайлы(НовыйПутьКФайлу);
		Возврат ДвоичныеДанныеЗаполненногоФайлам;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Выполняет заполнение файла данными его владельца в соответствии с правилами автозаполнения шаблонов файлов.
//
// Параметры:
//  ВызовСКлиента - Булево - признак того, что вызов выполняется с клиента.
//   * ИмяСвойстваПараметра - Список типов - Текстовое описание свойства (колонки) параметра.
//  ФайлСсылка - СправочникСсылка.Файл - ссылка на заполняемый файл.
//  ОбновлятьВерсиюПослеЗаполнения - Булево - признак того, что необходимо будет создать новую версию файла.
//	УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы, с которой выполняется вызов функции
//	ДокументВладелецФайла - СправочникСсылка.ВнутренниеДокументы, СправочникСсылка.ИсходящиеДокументы - ссылка на 
//							документ, по которому необходимо выполнить заполнение.
//
// Возвращаемое значение:
//  Структура - структура
//	* Результат - Булево - признак того, что заполнение выполнено
//	* ДвоичныеДанныеЗаполненногоФайла - ДвоичныеДанные - двоичные данные заполненного файла
//	* Описание - Строка - описание ошибки, если при заполнении произошла ошибка
Функция ЗаполнитьПоляФайлаДаннымиВладельца(ВызовСКлиента, 
	ФайлСсылка, 
	ОбновлятьВерсиюПослеЗаполнения, 
	УникальныйИдентификатор = Неопределено,
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
	//ДокументВладелецФайла = Неопределено) Экспорт
	ДокументВладелецФайла = Неопределено,
	ра_ФайлСсылка = Неопределено) Экспорт
	// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
	
	НастройкиАвтозаполнения = 
		АвтозаполнениеШаблоновФайловСервер.ПолучитьНастройкиАвтозаполненияШаблоновФайлов(
			ФайлСсылка, 
			ДокументВладелецФайла);
			
	ДанныеФайла = РаботаСФайламиВызовСервера.ДанныеФайла(ФайлСсылка);			
			
	ФайлВКеше = Новый Файл(ДанныеФайла.ПолноеИмяФайлаВРабочемКаталоге);
	Если ФайлВКеше.Существует() Тогда
		
		ДатаФайлаНаДиске = ФайлВКеше.ПолучитьУниверсальноеВремяИзменения();
		Если ДатаФайлаНаДиске > ДанныеФайла.ДатаМодификацииУниверсальная Тогда // В рабочем каталоге более новый
			НастройкиАвтозаполнения.ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ДанныеФайла.ПолноеИмяФайлаВРабочемКаталоге);
		КонецЕсли;	
		
	КонецЕсли;
	
	ДанныеВозврата = Новый Структура;
		
	МассивЗамен = НастройкиАвтозаполнения.МассивЗамен;
	ЗаполнятьMSWordНаСервере = НастройкиАвтозаполнения.ВыполнятьЗаполнениеMSWordНаСервере; 
	РасширениеФайла = НастройкиАвтозаполнения.РасширениеФайла;
	ДвоичныеДанныеФайла = НастройкиАвтозаполнения.ДвоичныеДанныеФайла;
	ШаблонОснованиеДляСоздания = НастройкиАвтозаполнения.ОснованиеСозданияФайла;
	
	Если (НЕ ШаблонОснованиеДляСоздания.Пустая() 
		ИЛИ ДокументВладелецФайла <> Неопределено) 
		И МассивЗамен <> Неопределено 
		И МассивЗамен.Количество() > 0 Тогда
		
		Если ВызовСКлиента Тогда
			Если ЗаполнятьMSWordНаСервере Тогда 
				// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
				//ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловСервер.ВыполнитьАвтоЗаполнениеШаблона(ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения);
				ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловСервер.ВыполнитьАвтоЗаполнениеШаблона(ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения, ра_ФайлСсылка);
				// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
				ДанныеВозврата.Вставить("Результат", Истина);
			Иначе
				Если ФорматMSWord(РасширениеФайла) Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьФайлMSWordПоДвоичнымДанным(РасширениеФайла, МассивЗамен, ДвоичныеДанныеФайла);
					ДанныеВозврата.Вставить("Результат", Истина);
				ИначеЕсли РасширениеФайла = "odt" Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьФайлOpenOfficeWriter(ДвоичныеДанныеФайла, РасширениеФайла, МассивЗамен);
					ДанныеВозврата.Вставить("Результат", Истина);
				ИначеЕсли ТекстовыйФормат(РасширениеФайла) Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьТекстовыйФайл(ДвоичныеДанныеФайла, РасширениеФайла, МассивЗамен);
					ДанныеВозврата.Вставить("Результат", Истина);
				КонецЕсли;
			КонецЕсли;
		Иначе
			// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов {
			//ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловСервер.ВыполнитьАвтоЗаполнениеШаблона(ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения);
			ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловСервер.ВыполнитьАвтоЗаполнениеШаблона(ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения, ра_ФайлСсылка);
			// ТСК Талько Э.Г.; 14.09.2018; Автозаполнение шаблонов }
		КонецЕсли;
		
		Если ОбновлятьВерсиюПослеЗаполнения Тогда
			Если ТипЗнч(ДвоичныеДанныеЗаполненногоФайла) <> Тип("Строка")
				И ДвоичныеДанныеЗаполненногоФайла <> Неопределено Тогда
				АвтозаполнениеШаблоновФайловСервер.ОбновитьВерсиюИзДвоичныхДанных(ДвоичныеДанныеЗаполненногоФайла, 
					ФайлСсылка, 
					"Заполнение полей файла",
					УникальныйИдентификатор);
				ДанныеВозврата.Вставить("Результат", Истина);
				ДанныеВозврата.Вставить("ДвоичныеДанныеЗаполненногоФайла", ДвоичныеДанныеЗаполненногоФайла);
			Иначе
				ДанныеВозврата.Вставить("Результат", Ложь);
				СисИнфо = Новый СистемнаяИнформация;
				Если ДвоичныеДанныеЗаполненногоФайла = "Linux" Тогда
					ОписаниеОшибки = НСтр("ru = 'Автозаполнение файлов Microsoft Word возможно только в Windows. Обратитесь к администратору.'; en = 'Autofill files Microsoft Word is only possible in Windows. Please contact your administrator.'");
					ДанныеВозврата.Вставить("Описание", ОписаниеОшибки);
				Иначе
					ОписаниеОшибки = НСтр("ru = 'Необходимо проверить правильность установки Microsoft Word. Обратитесь к администратору.'; en = 'It is necessary to check the correct installation of Microsoft Word. Please contact your administrator.'");
					ДанныеВозврата.Вставить("Описание", ОписаниеОшибки);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ДвоичныеДанныеЗаполненногоФайла <> Неопределено Тогда
			ДанныеВозврата.Вставить("Результат", Истина);
			ДанныеВозврата.Вставить("ДвоичныеДанныеЗаполненногоФайла", ДвоичныеДанныеЗаполненногоФайла);
		Иначе
			ДанныеВозврата.Вставить("Результат", Ложь);	
		КонецЕсли;
	Иначе
		ДанныеВозврата.Вставить("Результат", Ложь);
		Если ШаблонОснованиеДляСоздания.Пустая() Тогда
			ОписаниеОшибки = НСтр("ru = 'Невозможно выполнить заполнение. Данный файл создан не из шаблона.'; en = 'It is impossible to fill. This file is not created from a template.'");
		КонецЕсли;
		Если МассивЗамен.Количество() = 0 Тогда
			ОписаниеОшибки =  НСтр("ru = 'Невозможно выполнить заполнение. Не найдено подходящих правил автозаполнения файлов.'; en = 'It is impossible to fill. No matching rules autofill files.'");
		КонецЕсли;
		ДанныеВозврата.Вставить("Описание", ОписаниеОшибки); 
	КонецЕсли;
	Возврат ДанныеВозврата;
	
КонецФункции

//Выполняет поиск всех таблиц в файле
Функция ПолучитьВсеТаблицыВФайле(СсылкаНаФайл) Экспорт
	
	Результат = Новый Массив;
	ДанныеФайла = РаботаСФайламиВызовСервера.ДанныеФайлаИДвоичныеДанные(СсылкаНаФайл);
	ДвоичныеДанныеФайла = ДанныеФайла.ДвоичныеДанные;
	РасширениеФайла = ДанныеФайла.ДанныеФайла.Расширение;	
	Если РасширениеФайла = "docx" ИЛИ РасширениеФайла = "odt" Тогда
    	//поиск таблиц на сервере через OpenXML
		Результат = АвтозаполнениеШаблоновФайловСервер.ПолучитьВсеТаблицыФайлаOpenXML(ДвоичныеДанныеФайла, РасширениеФайла);	
	ИначеЕсли РасширениеФайла = "doc" Тогда
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецЕсли

// Возвращает признак того, что файлы указанного расширения являются обычными текстовыми и
//	не поддерживают заполнение полей.
//
// Параметры:
//  Расширение - Строка - Проверяемое расширение файла.
//
// Возвращаемое значение:
//  Булево - признак того, что файлы указанного расширения являются обычными текстовыми и
//			 поддерживают заполнение полей.
Функция ТекстовыйФормат(Расширение) Экспорт
	Возврат Расширение = "txt" ИЛИ
		Расширение = "html" ИЛИ
		Расширение = "htm";
КонецФункции


