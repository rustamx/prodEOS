/////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ИМЕНЕМ ФАЙЛА

// Возвращает структуру
// Результат (Структура)
// - Имя (Строка)
// - Расширение (Строка)
//
// Параметры:
// - ИмяФайла (Строка)
//
Функция РазложитьИмяФайла(ИмяФайла) Экспорт
	
	Расширение = ИмяФайла;
	Поз = Найти(Расширение, ".");
	Если Поз = 0 Тогда
		Возврат Новый Структура("Имя, Расширение", СокрЛП(ИмяФайла), "");
	КонецЕсли;
	Пока Поз > 0 Цикл
		Расширение = Сред(Расширение, Поз + 1);
		Поз = Найти(Расширение, ".");
	КонецЦикла;
	Имя = Лев(ИмяФайла, СтрДлина(ИмяФайла) - СтрДлина(Расширение) - 1);
	Возврат Новый Структура("Имя, Расширение", СокрЛП(Имя), СокрЛП(Расширение));
	
КонецФункции

// Возвращает структуру
// Результат (Структура)
// - Каталог (Строка) - без последнего слеша
// - ИмяФайла (Строка) - имя файла с расширением
// - Имя (Строка)
// - Расширение (Строка) - без точки
//
// Параметры:
// - ПолноеИмяФайла (Строка)
//
Функция РазложитьПолноеИмяФайла(ПолноеИмяФайла) Экспорт
	
	ИмяФайла = ПолноеИмяФайла;
	Каталог = "";
	
	Пока Истина Цикл
		Поз = Макс(Найти(ИмяФайла, "\"), Найти(ИмяФайла, "/"));
		Если Поз = 0 Тогда
			Прервать;
		КонецЕсли;
		Каталог = Каталог + Лев(ИмяФайла, Поз);
		ИмяФайла = Сред(ИмяФайла, Поз+1);
	КонецЦикла;
	ПоследнийСимволКаталога = Прав(Каталог, 1);
	Если (ПоследнийСимволКаталога = "\") Или (ПоследнийСимволКаталога = "/") Тогда
		Каталог = Лев(Каталог, СтрДлина(Каталог) - 1);
	КонецЕсли;
	
	ИмяФайлаИнфо = РазложитьИмяФайла(ИмяФайла);
	ИмяФайлаИнфо.Вставить("ИмяФайла", ИмяФайла);
	ИмяФайлаИнфо.Вставить("Каталог", Каталог);
	
	Возврат ИмяФайлаИнфо;
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С АДРЕСАМИ ЭЛЕКТРОННОЙ ПОЧТЫ

// Принимает строку почтовых адресов в виде
// "name1 <addr1@dom1>, name2 <addr2@dom2>, ..., nameN <addrN@domN>"
// или
// "name1 <addr1@dom1>; name2 <addr2@dom2>; ...; nameN <addrN@domN>"
// Возвращает:
// Результат (Массив)
// - Элемент (Структура)
//   - Адрес (Строка)
//   - Представление (Строка)
//
Функция РазложитьСтрокуПочтовыхАдресов(Знач ПочтовыеАдресаСтр) Экспорт
	
	Результат = Новый Массив;
	
	ПочтовыеАдресаСтр= СтрЗаменить(ПочтовыеАдресаСтр, ";", Символы.ПС);
	ПочтовыеАдресаСтр = СтрЗаменить(ПочтовыеАдресаСтр, ",", Символы.ПС);
	Для Счетчик = 1 По СтрЧислоСтрок(ПочтовыеАдресаСтр) Цикл
		АдресСтр = СокрЛП(СтрПолучитьСтроку(ПочтовыеАдресаСтр, Счетчик));
		Если ПустаяСтрока(АдресСтр) Тогда
			Продолжить;
		КонецЕсли;
		АдресЭлектроннойПочтыИнфо = РазложитьПредставлениеАдресаЭлектроннойПочты(АдресСтр);
		Результат.Добавить(АдресЭлектроннойПочтыИнфо);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(АдресЭлектроннойПочты)
	
	ДопустимыеСимволы = "-.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
	Для НомерСимвола = 1 По СтрДлина(АдресЭлектроннойПочты) Цикл
		Если Найти(ДопустимыеСимволы, Сред(АдресЭлектроннойПочты, НомерСимвола, 1)) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции	

// Принимает строку почтового адреса в виде
// "name <addr@dom>"
// Возвращает:
// Результат (Структура)
// - Адрес (Строка) - addr@dom
// - ОтображаемоеИмя (Строка) - name
// - Пользователь (Строка)-  addr
// - Домен (Строка) - dom
//
Функция РазложитьПредставлениеАдресаЭлектроннойПочты(Знач АдресЭлектроннойПочтыСтр) Экспорт
	
	Результат = Новый Структура("Адрес, ОтображаемоеИмя, Пользователь, Домен, ФИО", "", "", "", "", "");
	
	АдресЭлектроннойПочтыСтр = СокрЛП(АдресЭлектроннойПочтыСтр);
	
	Поз = Найти(АдресЭлектроннойПочтыСтр, "@");
	Если Поз = 0 Тогда
		Результат.ФИО = АдресЭлектроннойПочтыСтр;
		Возврат Результат;
	КонецЕсли;
	
	СтрокаАдреса = "";
	ПозицияПервогоСимволаАдреса = 0;
	ПозицияПоследнегоСимволаАдреса = 0;
	
	// Идем влево от @
	Для Индекс = 0 По Поз - 1 Цикл
		
		ИндексВСтроке = Поз - Индекс;
		СтрокаАдресаПроверка = Сред(АдресЭлектроннойПочтыСтр, ИндексВСтроке, 1) + СтрокаАдреса;
		
		Если СтрокаСодержитТолькоДопустимыеСимволы(СтрокаАдресаПроверка) Тогда
			СтрокаАдреса = СтрокаАдресаПроверка;
			ПозицияПервогоСимволаАдреса = ИндексВСтроке;
		Иначе
			Прервать;
		КонецЕсли;	
		
	КонецЦикла;	
	
	// Идем вправо от @
	Для ИндексВСтроке = Поз + 1 По СтрДлина(АдресЭлектроннойПочтыСтр) Цикл
		
		СтрокаАдресаПроверка = СтрокаАдреса + Сред(АдресЭлектроннойПочтыСтр, ИндексВСтроке, 1);
		
		Если СтрокаСодержитТолькоДопустимыеСимволы(СтрокаАдресаПроверка) Тогда
			СтрокаАдреса = СтрокаАдресаПроверка;
			ПозицияПоследнегоСимволаАдреса = ИндексВСтроке;
		Иначе
			Прервать;
		КонецЕсли;	
		
	КонецЦикла;	
	
	Результат.Адрес = СтрокаАдреса;
	// слева от адреса берем представление
	Результат.ОтображаемоеИмя = Лев(АдресЭлектроннойПочтыСтр, ПозицияПервогоСимволаАдреса - 2);
	Результат.ОтображаемоеИмя = СокрЛП(Результат.ОтображаемоеИмя);
	
	Если Не ЭтоАдресЭлектроннойПочты(Результат.Адрес) Тогда
		Результат.Адрес = "";
	Иначе
		Поз = Найти(Результат.Адрес, "@");
		Результат.Пользователь = Лев(Результат.Адрес, Поз - 1);
		Результат.Домен = Сред(Результат.Адрес, Поз + 1);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет строку на формат адреса электронной почты
// проверка не точная но основные элементы на месте
//
Функция ЭтоАдресЭлектроннойПочты(АдресЭлектроннойПочты) Экспорт
	
	Поз = Найти(АдресЭлектроннойПочты, "@");
	Если Поз = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Корнюшенков А.Ю. Искать в тексте "ОбменЛучшимиПрактиками" 26.10.2018 {
	// апостроф разрешается использовать до символа "@", добавим это условие
	ПозицияАпостроф = Найти(АдресЭлектроннойПочты, "'");
	Если ПозицияАпостроф > Поз Тогда
		Возврат Ложь;
	КонецЕсли;
	// Корнюшенков А.Ю. Искать в тексте "ОбменЛучшимиПрактиками" 26.10.2018 } 
	
	Если СтрЧислоВхождений(АдресЭлектроннойПочты, "@") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Прав(АдресЭлектроннойПочты, 1) = "."
		Или Лев(АдресЭлектроннойПочты, 1) = "." Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Найти(АдресЭлектроннойПочты, "..") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Корнюшенков А.Ю. Искать в тексте "ОбменЛучшимиПрактиками" 26.10.2018 {
	// апостроф разрешается использовать до символа "@", добавим его в допустимые символы
	ДопустимыеСимволы = "'-.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
	// было ДопустимыеСимволы = "-.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
	// Корнюшенков А.Ю. Искать в тексте "ОбменЛучшимиПрактиками" 26.10.2018 }
	
	Для НомерСимвола = 1 По СтрДлина(АдресЭлектроннойПочты) Цикл
		Если Найти(ДопустимыеСимволы, Сред(АдресЭлектроннойПочты, НомерСимвола, 1)) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Пользователь = Лев(АдресЭлектроннойПочты, Поз - 1);
	Если СтрДлина(Пользователь) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Сервер = Сред(АдресЭлектроннойПочты, Поз + 1);
	Если СтрДлина(Сервер) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Поз = Найти(Сервер, ".");
	Если Поз = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

//Формирует представление адресата электронной почты
//
//Параметры
//  Имя     - Строка - имя адресата
//  Адрес   - Строка - адрес электронной почты адресата
//  Контакт - СправочникСсылка - контакт, которому принадлежит имя и адрес почты.
//
// Результат (Строка) - "Имя <Адрес>" или "Адрес"
//
Функция ПолучитьПредставлениеАдресаЭлектроннойПочты(Имя, Адрес) Экспорт
	
	Если ПустаяСтрока(Имя) Или Имя = Адрес Тогда
		Результат = Адрес;
	ИначеЕсли ПустаяСтрока(Адрес) Тогда
		Результат = Имя;
	Иначе
		Результат = Имя + " <" + Адрес + ">";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ТЕКСТОМ

// Удаляет недопустимые символы в XML-строке
// Параметры:
// - Текст (Строка)
// - СимволЗамены (Строка)
// 
// Результат (Строка)
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	#Если Не ВебКлиент Тогда
		ПозицияНачала = 1;
		Пока Истина Цикл
			Если ПозицияНачала > СтрДлина(Текст) Тогда
				Прервать;
			КонецЕсли;
			Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
			Если Позиция = 0 Тогда
				Прервать;
			КонецЕсли;
			// Если возращается позиция, больше чем должна быть, то корректируем ее.
			Если Позиция > 1 Тогда
				НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);
				Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
					Текст = СтрЗаменить(Текст, НедопустимыйСимвол, "");
				КонецЕсли;
			КонецЕсли;
			НедопустимыйСимвол = Сред(Текст, Позиция, 1);
			Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
				Текст = СтрЗаменить(Текст, НедопустимыйСимвол, "");
			КонецЕсли;
			ПозицияНачала = Макс(1, Позиция - 1);
		КонецЦикла;
	#КонецЕсли
	
	Возврат Текст;
	
КонецФункции

// Удаляет пустые строки в тексте.
//
Процедура УдалитьПустыеСтроки(Текст) Экспорт
	
	Результат = "";
	Для Индекс = 1 По СтрЧислоСтрок(Текст) Цикл
		Строка = СтрПолучитьСтроку(Текст, Индекс);
		Если ЗначениеЗаполнено(Строка) Тогда
			ДобавитьЗначениеКСтрокеЧерезРазделитель(
				Результат,
				Символы.ПС,
				Строка);
		КонецЕсли;
	КонецЦикла;
	
	Текст = Результат;
	
КонецПроцедуры

// Добавляет к каждой строке спереди символ квотирования.
//
Процедура ДобавитьКвотирование(Текст, Знач СимволКвотирования) Экспорт
	
	Результат = "";
	Для Индекс = 1 По СтрЧислоСтрок(Текст) Цикл
		Строка = СтрПолучитьСтроку(Текст, Индекс);
		ДобавитьЗначениеКСтрокеЧерезРазделитель(
			Результат,
			Символы.ПС,
			СимволКвотирования + Строка);
	КонецЦикла;
	Текст = Результат;
	
КонецПроцедуры

// Заменяет в переданном тексте ошибочные последовательности переноса строк.
// Все последовательности [ВК]+ПС заменяются на ВК+ПС.
// Все одиночные символы ВК заменяются на ВК+ПС.
//
Процедура ИсправитьПереносыСтрок(Текст) Экспорт
	
	Пока Найти(Текст, Символы.ВК + Символы.ПС) > 0 Цикл
		Текст = СтрЗаменить(Текст, Символы.ВК + Символы.ПС, Символы.ПС);
	КонецЦикла;
	
	Если Найти(Текст, Символы.ВК) > 0 Тогда
		Текст = СтрЗаменить(Текст, Символы.ВК, Символы.ПС);
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПРЕДСТАВЛЕНИЕМ РАЗМЕРОВ

// Принимает размер в байтах.
// Возвращает строку, например: 7.2 Кбайт, 35 Кбайт, 5.5 Мбайт, 12 Мбайт
Функция ПолучитьРазмерСтрокой(Размер) Экспорт
	
	Если Размер = 0 Тогда
		Возврат "-";
	ИначеЕсли Размер < 1024 * 10 Тогда // < 10 Кб
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 Кб'; en = '%1 KB'"),
			Формат(Макс(1, Окр(Размер / 1024, 1, 1)), "ЧГ=0"));
	ИначеЕсли Размер < 1024 * 1024 Тогда // < 1 Мб
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 Кб'; en = '%1 KB'"),
			Формат(Цел(Размер / 1024), "ЧГ=0"));
	ИначеЕсли Размер < 1024 * 1024 * 10 Тогда // < 10 Мб
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 Мб'; en = '%1 MB'"),
			Формат(Окр(Размер / 1024 / 1024, 1, 1), "ЧГ=0"));
	Иначе // >= 10 Мб
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 Мб'; en = '%1 MB'"),
			Формат(Цел(Размер / 1024 / 1024), "ЧГ=0"));
	КонецЕсли;
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С КОДИРОВКАМИ

// Функция возвращает таблицу имен кодировок
// Возвращаемое значение:
// Результат (СписокЗначений)
// - Значение (Строка) - например "ibm852"
// - Представление (Строка) - например "ibm852 (Центральноевропейская DOS)"
//
Функция ПолучитьСписокКодировок() Экспорт

	СписокКодировок = Новый СписокЗначений;
	
	СписокКодировок.Добавить("ibm866",			НСтр("ru='IBM866 (Кириллица DOS)'; en = 'IBM866 Cyrillic (DOS)'"));
	СписокКодировок.Добавить("koi8-r",			НСтр("ru='KOI8-R (Кириллица KOI8-R)'; en = 'KOI8-R Cyrillic (KOI8-R)'"));
	СписокКодировок.Добавить("windows-1251",	НСтр("ru='windows-1251 (Кириллица Windows)'; en = 'windows-1251 Cyrillic (windows)'"));
	
	СписокКодировок.Добавить("ibm852",			НСтр("ru='IBM852 (Центральноевропейская DOS)'; en = 'IBM852 (DOS Central European)'"));
	СписокКодировок.Добавить("iso-8859-1",		НСтр("ru='ISO-8859-1 (Западноевропейская ISO)'; en = 'ISO-8859-1 (Western European ISO)'"));
	СписокКодировок.Добавить("iso-8859-2",		НСтр("ru='ISO-8859-2 (Центральноевропейская ISO)'; en = 'ISO-8859-2 (Central European ISO)'"));
	СписокКодировок.Добавить("iso-8859-3",		НСтр("ru='ISO-8859-3 (Латиница 3 ISO)'; en = 'ISO-8859-3 (Latin 3 ISO)'"));
	СписокКодировок.Добавить("iso-8859-4",		НСтр("ru='ISO-8859-4 (Балтийская ISO)'; en = 'ISO-8859-4 (Baltic)'"));
	СписокКодировок.Добавить("iso-8859-5",		НСтр("ru='ISO-8859-5 (Кириллица ISO)'; en = 'ISO-8859-5 Cyrillic (ISO)'"));
	СписокКодировок.Добавить("iso-8859-7",		НСтр("ru='ISO-8859-7 (Греческая ISO)'; en = 'ISO-8859-7 (Greek ISO)'"));
	СписокКодировок.Добавить("iso-8859-9",		НСтр("ru='ISO-8859-9 (Турецкая ISO)'; en = 'ISO-8859-9 (Turkish)'"));
	СписокКодировок.Добавить("iso-8859-15",		НСтр("ru='ISO-8859-15 (Латиница 9 ISO)'; en = 'ISO-8859-15 (Latin 9 ISO)'"));
	СписокКодировок.Добавить("koi8-u",			НСтр("ru='KOI8-U (Кириллица KOI8-U)'; en = 'KOI8-U (Cyrillic KOI8-U)'"));
	СписокКодировок.Добавить("us-ascii",		НСтр("ru='US-ASCII США'; en = 'US-ASCII USA'"));
	СписокКодировок.Добавить("utf-8",			НСтр("ru='UTF-8 (Юникод UTF-8)'; en = 'UTF-8 (Unicode UTF-8)'"));
	СписокКодировок.Добавить("windows-1250",	НСтр("ru='Windows-1250 (Центральноевропейская Windows)'; en = 'Windows-1250 (Windows Central European)'"));
	СписокКодировок.Добавить("windows-1252",	НСтр("ru='Windows-1252 (Западноевропейская Windows)'; en = 'Windows-1252 (Windows Western)'"));
	СписокКодировок.Добавить("windows-1253",	НСтр("ru='Windows-1253 (Греческая Windows)'; en = 'Windows-1253 (Windows Greek)'"));
	СписокКодировок.Добавить("windows-1254",	НСтр("ru='Windows-1254 (Турецкая Windows)'; en = 'Windows-1254 (Windows Turkish)'"));
	СписокКодировок.Добавить("windows-1257",	НСтр("ru='Windows-1257 (Балтийская Windows)'; en = 'Windows-1257 (Windows Baltic)'"));
	
	Возврат СписокКодировок;

КонецФункции

// Функция возвращает представление кодировки по значению.
Функция ПолучитьКодировкуПоПредставлению(Представление) Экспорт
	
	Для каждого КодировкаЭлемент Из ПолучитьСписокКодировок() Цикл
		Если Представление = КодировкаЭлемент.Представление Тогда
			Возврат КодировкаЭлемент.Значение; 	
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Функция возвращает представление кодировки по значению.
Функция ПолучитьПредставлениеКодировки(Значение) Экспорт
	
	Для каждого КодировкаЭлемент Из ПолучитьСписокКодировок() Цикл
		Если Значение =	КодировкаЭлемент.Значение Тогда
			Возврат КодировкаЭлемент.Представление; 	
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ФУНКЦИИ

// Выделяет подстроку в скобках.
// Напрмер: ВыделитьПодстрокуВСкобках("Name <name@company.ru>", "<", ">") = "name@company.ru"
//
Функция ВыделитьПодстрокуВСкобках(Знач Строка, Знач ЛеваяСкобка, Знач ПраваяСкобка) Экспорт
	
	Поз = Найти(Строка, ЛеваяСкобка);
	Если Поз <> 0 Тогда
		Строка = Сред(Строка, Поз+1);
	КонецЕсли;
	
	Поз = Найти(Строка, ПраваяСкобка);
	Если Поз <> 0 Тогда
		Строка = Лев(Строка, Поз-1);
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

// Ищет подстроку в строке, после указанной позиции
//
Функция НайтиПосле(Строка, Подстрока, НачальнаяПозиция = 0) Экспорт
	
	Если СтрДлина(Строка) <= НачальнаяПозиция Тогда
		Возврат 0;
	КонецЕсли;
	
	Позиция = СтрНайти(Строка, Подстрока, НаправлениеПоиска.СНачала, НачальнаяПозиция + 1);
	Возврат Позиция;
	
КонецФункции

// Преобразует переданную строку в указанную кодировку.
//
Функция ПолучитьСтрокуВКодировке(Строка, Кодировка) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
		ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла, Кодировка);
		ЗаписьТекста.Записать(Строка);
		ЗаписьТекста.Закрыть();
		
		ЧтениеТекста = Новый ЧтениеТекста(ИмяВременногоФайла, Кодировка);
		Результат = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		Возврат Результат;
		
	#Иначе
		
		ВызватьИсключение НСтр("ru = 'Операция преобразования кодировки строк не поддерживается в веб-клиенте.'; en = 'String encoding conversion operations are not supported in web client.'");
		
	#КонецЕсли
	
КонецФункции

// Преобразует переданные строки в указанную кодировку.
// Результат (Структура)
//
// Параметры:
// - Строки (Структура)
// - Кодировка (Строка)
Функция ПолучитьСтрокиВКодировке(Строки, Кодировка) Экспорт
	
	#Если Не ВебКлиент Тогда
		
		Результат = Новый Структура;
		Для каждого Элемент Из Строки Цикл
			Результат.Вставить(Элемент.Ключ, ПолучитьСтрокуВКодировке(Элемент.Значение, Кодировка));
		КонецЦикла;
		
		Возврат Результат;
		
	#Иначе
		
		ВызватьИсключение НСтр("ru = 'Операция преобразования строк кодировки не поддерживается в веб-клиенте.'; en = 'String encoding conversion operations are not supported in web client.'");
		
	#КонецЕсли
	
КонецФункции

// Преобразует переданную многострочную строку в многострочную строку определенной ширины
// с учетом символа символа переписки. Если символ переписки не задан,
// то форматирование будет без учета символа переписки. Если задан, то к длинным строкам,
// начинающимся с данного символа, при разбиении будет добавляться данный символ в начало.
Функция ПолучитьСтрокуВФормате(Строка, Ширина, СимволПереписки = Неопределено, РазбиватьСтрокиПриЦитировании = Ложь) Экспорт
	
	// Если строка пустая, то просто возвращаем строку.
	Если ПустаяСтрока(Строка) Тогда
		Возврат Символы.ПС;
	КонецЕсли;
	
	СтрокаВФормате = "";
	КоличествоСтрок = СтрЧислоСтрок(Строка);
	Для Индекс = 1 По КоличествоСтрок Цикл
		
		СтрокаВФормате = 
			СтрокаВФормате 
			+ ПолучитьСтрокуВФорматеДляОднострочнойСтроки(
				СтрПолучитьСтроку(Строка, Индекс), 
				Ширина, 
				СимволПереписки,
				РазбиватьСтрокиПриЦитировании);
		
	КонецЦикла;
	
	Возврат СтрокаВФормате;
	
КонецФункции

// Преобразует переданную однострочную строку. Если ее длина превышает переданную ширину,
// то преобразует переданную строку в многострочную строку определенной ширины.
// Длина значимой содержательной части строки (без символов квотирования) будет минимум половина 
// переданного значения ширины.
Функция ПолучитьСтрокуВФорматеДляОднострочнойСтроки(Строка, Ширина, СимволПереписки = Неопределено,
	РазбиватьСтрокиПриЦитировании = Ложь)
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Символы.ПС;
	КонецЕсли;
	
	СтрокаВФормате = "";
	Если Не РазбиватьСтрокиПриЦитировании И СтрокаЯвляетсяЦитатой(Строка, СимволПереписки) Тогда
		
		// Не обрабатывать строку с цитированием 
		СтрокаВФормате = Строка + Символы.ПС;
		
	Иначе
		
		ОбрабатываемаяСтрока = Строка;
		ШиринаОбрабатываемойСтроки = Ширина;
		НачалоСтроки = "";
		ВыделитьНачалоСтроки(ОбрабатываемаяСтрока, НачалоСтроки, ШиринаОбрабатываемойСтроки, СимволПереписки);
		
		Если СтрДлина(ОбрабатываемаяСтрока) <= ШиринаОбрабатываемойСтроки Тогда
			
			// Обработка длинной строки
			ВыделитьНачалоСтроки(ОбрабатываемаяСтрока, НачалоСтроки, ШиринаОбрабатываемойСтроки, СимволПереписки);
			СтрокаВФормате = НачалоСтроки + ОбрабатываемаяСтрока + Символы.ПС; 
			
		Иначе 
			
			// Обработка короткой строки
			Пока СтрДлина(ОбрабатываемаяСтрока) > ШиринаОбрабатываемойСтроки Цикл
				ОбработаннаяСтрока = НачалоСтроки;
				ПеренестиСтрокуПоПробелу(ОбработаннаяСтрока, ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки);
				СтрокаВФормате = СтрокаВФормате + ОбработаннаяСтрока + Символы.ПС;
			КонецЦикла;
			
			Если ЗначениеЗаполнено(ОбрабатываемаяСтрока) Тогда
				СтрокаВФормате = СтрокаВФормате + НачалоСтроки + ОбрабатываемаяСтрока + Символы.ПС;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтрокаВФормате;
	
КонецФункции

// Возвращает индекс первого значащего символа строки. К незначащим символам относятся
// стандартные незначащие символы и переданные в параметре СписокНезначащихСимволов.
Функция НайтиПервыйЗначащийСимволСтроки(Строка, СписокНезначащихСимволов) Экспорт
	
	НайденЗначащийСимвол = Ложь;
	ОбрабатываемаяСтрока = Строка;
	ПоложениеПервогоСимвола = 0;
	Пока Не НайденЗначащийСимвол И ЗначениеЗаполнено(ОбрабатываемаяСтрока) Цикл
		
		ДлинаСтрокиСНезначащимиСимволами = СтрДлина(ОбрабатываемаяСтрока);
		ОбрабатываемаяСтрока = СокрЛ(ОбрабатываемаяСтрока);
		ПоложениеПервогоСимвола = 
			ПоложениеПервогоСимвола 
			+ ДлинаСтрокиСНезначащимиСимволами 
			- СтрДлина(ОбрабатываемаяСтрока); 
		
		ПервыйСимвол = Символ(КодСимвола(ОбрабатываемаяСтрока, 1));
		Если СписокНезначащихСимволов.НайтиПоЗначению(ПервыйСимвол) = Неопределено Тогда
			
			НайденНезначащийСимвол = Ложь;
			Для Каждого НезначащийСимвол Из СписокНезначащихСимволов Цикл
				
				ВозможныйПервыйСимвол = Лев(ОбрабатываемаяСтрока, СтрДлина(НезначащийСимвол.Значение));
				Если ВозможныйПервыйСимвол = НезначащийСимвол.Значение Тогда
					ПервыйСимвол = ВозможныйПервыйСимвол;
					НайденНезначащийСимвол = Истина;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			Если Не НайденНезначащийСимвол Тогда
				НайденЗначащийСимвол = Истина;
			КонецЕсли;
			
		КонецЕсли;
		ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 1 + СтрДлина(ПервыйСимвол));
		ПоложениеПервогоСимвола = ПоложениеПервогоСимвола + СтрДлина(ПервыйСимвол);
		
	КонецЦикла;
	
	Если НайденЗначащийСимвол Тогда
		Возврат ПоложениеПервогоСимвола;
	КонецЕсли;
		
	Возврат 0;
	
КонецФункции

// Функция возвращает значение Истина, если первый значащий символ в строке является
// символом переписки. В противном случае возвращает Ложь.
Функция СтрокаЯвляетсяЦитатой(Строка, СимволПереписки)
	
	ПроверяемаяСтрока = СокрЛ(Строка);
	ПервыйСимвол = Лев(ПроверяемаяСтрока, СтрДлина(СимволПереписки));
	Если ПервыйСимвол = СимволПереписки Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Если обработанная строка заканчивается на обрабатываемый знак, тогда процедура переносит
// все обрабатываемые знаки из начала обрабатываемой строки в конец обработанной строки.
Процедура ПродлитьСтрокуПоЗнаку(ОбработаннаяСтрока, ОбрабатываемаяСтрока, ОбрабатываемыйЗнак) Экспорт
	
	ПоследнийСимволОбработаннойСтроки = Символ(КодСимвола(ОбработаннаяСтрока, СтрДлина(ОбработаннаяСтрока)));
	
	Если ПоследнийСимволОбработаннойСтроки = ОбрабатываемыйЗнак Тогда
		СписокНезначащихСимволов = Новый СписокЗначений();
		СписокНезначащихСимволов.Добавить(ОбрабатываемыйЗнак);
		КоличествоОбрабатываемыхЗнаков = НайтиПервыйЗначащийСимволСтроки(ОбрабатываемаяСтрока, СписокНезначащихСимволов);	
		НачалоСтрокиИзОбрабатываемыхСимволов = Лев(ОбрабатываемаяСтрока, КоличествоОбрабатываемыхЗнаков - 1);
		ОбработаннаяСтрока = ОбработаннаяСтрока + НачалоСтрокиИзОбрабатываемыхСимволов;
		ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, КоличествоОбрабатываемыхЗнаков);
	КонецЕсли;
	
КонецПроцедуры

// Процедура переносит часть обрабатываемой строки в обработанную строку, с учетом продления
// строки за переданную ширину по знаку "-".
// Если в обрабатываемой строке нет пробелов, тогда перенос будет по переданной ширине.
// Если в обрабатываемой строке нет есть положение, тогда будет выполнен перенос по последнему
// проблему в подстроке переданной ширины, взятой из начала обрабатываемой строки.
Процедура ПеренестиСтрокуПоПробелу(ОбработаннаяСтрока, ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки) Экспорт
	
	Если Найти(ОбрабатываемаяСтрока, " ") <> 0 Тогда
		
		СтрокаПереноса = Лев(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки);
		ПоложениеПробела = Найти(СтрокаПереноса, " ");
		
		Если ПоложениеПробела = 0 Тогда
			
			ОбработаннаяСтрока = СокрП(ОбработаннаяСтрока + Лев(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки));
			ОбрабатываемаяСтрока = СокрЛ(Сред(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки + 1));
			
		Иначе			
			
			// Если последнее слово превышает допустимую ширину из-за символа "-", тогда продлеваем на остаток строки и данный символ.
			ОбрабатываемыйЗнак = "-";
			ПоследнийСимволОбрабатываемойСтроки = Символ(КодСимвола(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки));
			Если ПоследнийСимволОбрабатываемойСтроки = ОбрабатываемыйЗнак Тогда 
				
				ОбработаннаяСтрока = СокрП(ОбработаннаяСтрока + Лев(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки));
				ОбрабатываемаяСтрока = СокрЛ(Сред(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки + 1));
				ПродлитьСтрокуПоЗнаку(ОбработаннаяСтрока, ОбрабатываемаяСтрока, ОбрабатываемыйЗнак);
				
			Иначе
				
				Пока Найти(СтрокаПереноса, " ") <> 0 Цикл
					
					ОбработаннаяСтрока = ОбработаннаяСтрока + Лев(СтрокаПереноса, ПоложениеПробела);
					СтрокаПереноса = Сред(СтрокаПереноса, ПоложениеПробела + 1);
					ПоложениеПробела = Найти(СтрокаПереноса, " ");
					
				КонецЦикла;
				
				ОбработаннаяСтрока = СокрП(ОбработаннаяСтрока); 
				ОбрабатываемаяСтрока = СокрЛ(СтрокаПереноса + Сред(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки + 1));
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		ОбработаннаяСтрока = СокрП(ОбработаннаяСтрока + Лев(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки));
		ОбрабатываемаяСтрока = СокрЛ(Сред(ОбрабатываемаяСтрока, ШиринаОбрабатываемойСтроки + 1));
		
	КонецЕсли;
	
	ОбрабатываемыйЗнак = "-";
	ПродлитьСтрокуПоЗнаку(ОбработаннаяСтрока, ОбрабатываемаяСтрока, ОбрабатываемыйЗнак);

КонецПроцедуры

// Процедура предназначена для выделения из обрабатываемой строки начала строки, состоящего только
// из переданных символов переписки. В соответствии с шириной полученного начала строки уменьшается
// значение.
Процедура ВыделитьНачалоСтроки(ОбрабатываемаяСтрока, НачалоСтроки, ШиринаОбрабатываемойСтроки, СимволПереписки) Экспорт
	
	Ширина = ШиринаОбрабатываемойСтроки;
	
	Если ЗначениеЗаполнено(СимволПереписки) Тогда
		
		СписокНезначащихСимволов = Новый СписокЗначений();
		СписокНезначащихСимволов.Добавить(СимволПереписки);
		ПервыйЗначащийСимвол = НайтиПервыйЗначащийСимволСтроки(ОбрабатываемаяСтрока, СписокНезначащихСимволов);
		НачалоСтрокиНеФорматированное = Лев(ОбрабатываемаяСтрока, ПервыйЗначащийСимвол - 1);
		
		УровеньВложенностиПереписки = СтрЧислоВхождений(НачалоСтрокиНеФорматированное, СимволПереписки);
		Если УровеньВложенностиПереписки <> 0 Тогда
			
			Для ТекущийУровеньВложенности = 1 по УровеньВложенностиПереписки Цикл
				НачалоСтроки = НачалоСтроки + СимволПереписки;
			КонецЦикла;
			
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ПервыйЗначащийСимвол );
			ШиринаОбрабатываемойСтроки = ШиринаОбрабатываемойСтроки - СтрДлина(НачалоСтроки);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ШиринаОбрабатываемойСтроки < (Ширина / 2) Тогда
		ШиринаОбрабатываемойСтроки = Ширина / 2;
	КонецЕсли;
		
КонецПроцедуры

// Добавляет у каждой строки вначале символ цитирования
Процедура ДобавитьЦитирование(Текст, СимволЦитирования) Экспорт
	
	ТекстИсточника = Новый ТекстовыйДокумент;
	ТекстИсточника.УстановитьТекст(Текст);
	КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
	ТекстРезультата = "";
	
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		
		Строка = ТекстИсточника.ПолучитьСтроку(НомерСтроки);
		Строка = СимволЦитирования + Строка;
		
		Если НомерСтроки = 1 Тогда
			ТекстРезультата = Строка;
		Иначе
			ТекстРезультата = ТекстРезультата + Символы.ПС + Строка;
		КонецЕсли;
		
	КонецЦикла;
	
	Текст = ТекстРезультата;
	
КонецПроцедуры

// Удаляет у каждой строки вначале символ цитирования
Процедура УдалитьЦитирование(Текст, СимволЦитирования) Экспорт
	
	ТекстИсточника = Новый ТекстовыйДокумент;
	ТекстИсточника.УстановитьТекст(Текст);
	КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
	ТекстРезультата = "";
	
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		
		Строка = ТекстИсточника.ПолучитьСтроку(НомерСтроки);
		ПозицияСимволаЦитирования = Найти(Строка, СимволЦитирования);
		Если ПозицияСимволаЦитирования = 1 Тогда
			Строка = Сред(Строка, СтрДлина(СимволЦитирования) + 1);
		КонецЕсли;
		
		Если НомерСтроки = 1 Тогда
			ТекстРезультата = Строка;
		Иначе
			ТекстРезультата = ТекстРезультата + Символы.ПС + Строка;
		КонецЕсли;
		
	КонецЦикла;
	
	Текст = ТекстРезультата;
	
КонецПроцедуры

// Заменяет у каждой строки вначале символ цитирования
Процедура ЗаменитьЦитирование(Текст, СтарыйСимволЦитирования, НовыйСимволЦитирования, УровеньЗамены) Экспорт
	
	ТекстИсточника = Новый ТекстовыйДокумент;
	ТекстИсточника.УстановитьТекст(Текст);
	КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
	ТекстРезультата = "";
	
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		
		СимволыЦитирования = "";
		ТекущийУровеньЗамены = 1;
		ДопустимыйУровеньЗамены = Истина;
		ДопустимыйУровеньЦитирования = Истина;
		
		Строка = ТекстИсточника.ПолучитьСтроку(НомерСтроки);
		ПозицияСимволаЦитирования = Найти(Строка, СтарыйСимволЦитирования);
		Пока ПозицияСимволаЦитирования = 1 И ДопустимыйУровеньЦитирования Цикл
			
			Строка = Сред(Строка, СтрДлина(СтарыйСимволЦитирования) + 1);
			СимволыЦитирования = СимволыЦитирования + НовыйСимволЦитирования;
			
			ПозицияСимволаЦитирования = Найти(Строка, СтарыйСимволЦитирования);
			
			ТекущийУровеньЗамены = ТекущийУровеньЗамены + 1;
			ДопустимыйУровеньЦитирования = ТекущийУровеньЗамены <= УровеньЗамены;
			
		КонецЦикла;
		
		Строка = СимволыЦитирования + Строка;
		
		Если НомерСтроки = 1 Тогда
			ТекстРезультата = Строка;
		Иначе
			ТекстРезультата = ТекстРезультата + Символы.ПС + Строка;
		КонецЕсли;
		
	КонецЦикла;
	
	Текст = ТекстРезультата;
	
КонецПроцедуры


