////////////////////////////////////////////////////////////////////////////////
// Подсистема "Управление доступом".
// 
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

////////////////////////////////////////////////////////////////////////////////
// Объявление служебных событий, к которым можно добавлять обработчики.

// Объявляет события подсистемы УправлениеДоступом:
//
// Серверные события:
//   ПриЗаполненииВозможныхПравПоЗначениямДоступа,
//   ПриЗаполненииЗависимостейПравДоступа,
//   ПриЗаполненииВидовОграниченийПравОбъектовМетаданных,
//   ПриЗаполненииСвойствВидаДоступа,
//   ПриЗаполненииПоставляемыхПрофилейГруппДоступа,
//   ПриЗаполненииИспользованияВидаДоступа,
//   ПриИзмененииНаборовЗначенийДоступа,
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Заполняет свойства видов доступа, добавленных прикладным разработчиком
	// в план видов характеристик ВидыДоступа, как предопределенные элементы.
	//
	// Параметры:
	//  Свойства - Структура со свойствами,
	//             описание которых см. в комментарии к функции
	//             ПланыВидовХарактеристик.ВидыДоступа.СвойстваВидовДоступа().
	//
	// Синтаксис:
	// Процедура ПриЗаполненииСвойствВидаДоступа(Знач Свойства) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ЗаполнитьСвойстваВидаДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииСвойствВидаДоступа");
	
	// Заполняет описания поставляемых профилей групп доступа и
	// переопределяет параметры обновления профилей и групп доступа.
	//
	//  Для автоматической подготовки содержимого процедуры следует
	// воспользоваться инструментами разработчика для подсистемы
	// Управление доступом.
	//
	// Параметры:
	//  ОписанияПрофилей    - Массив в который нужно добавить описания.
	//                        Пустая структура должна быть получена при помощи функции
	//                        УправлениеДоступом.НовоеОписаниеПрофиляГруппДоступа().
	//
	//  ПараметрыОбновления - Структура со свойствами:
	//
	//                        ОбновлятьИзмененныеПрофили - Булево (начальное значение Истина).
	//
	//                        ЗапретитьИзменениеПрофилей - Булево (начальное значение Истина),
	//                        если установить Ложь, тогда поставляемые профили будут открываться
	//                        в режиме ТолькоПросмотр.
	//
	//                        ОбновлятьГруппыДоступа - Булево (начальное значение Истина).
	//
	//                        ОбновлятьГруппыДоступаСУстаревшимиНастройками - Булево (начальное
	//                        значение Ложь), если установить Истина, то настройки значений,
	//                        сделанные администратором по виду доступа, который удален из
	//                        профиля, будут удалены из группы доступа.
	//
	// Синтаксис:
	// Процедура ПриЗаполненииПоставляемыхПрофилейГруппДоступа(ОписанияПрофилей, ПараметрыОбновления) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ЗаполнитьПоставляемыеПрофилиГруппДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииПоставляемыхПрофилейГруппДоступа");
	
	// Заполняет использование видов доступа, добавленных прикладным разработчиком
	// в план видов характеристик ВидыДоступа, как предопределенные элементы.
	//
	// Параметры:
	//  ВидДоступа    - ПланВидовХарактеристикСсылка.ВидыДоступа.
	//  Использование - Булево (возвращаемое значение). Начальное значение Истина.
	//
	// Синтаксис:
	// Процедура ПриЗаполненииИспользованияВидаДоступа(Знач ВидДоступа, Использование) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ЗаполнитьИспользованиеВидаДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииИспользованияВидаДоступа");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Добавление обработчиков событий.

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииДанныхОтПодчиненного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПослеПолученияДанныхОтПодчиненного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПослеПолученияДанныхОтГлавного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииОбязательныхОбъектовПланаОбмена"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииОбъектовНачальногоОбразаПланаОбмена"].Добавить(
		"УправлениеДоступомСлужебный");
	
КонецПроцедуры

// Доопределяет действия при создании администратора в подсистеме Пользователи.
// 
// Параметры:
//  Администратор - СправочникСсылка.Пользователи (изменение объекта запрещено).
//  Уточнение     - Строка - поясняет при каких условиях был создан администратор.
//
Процедура ПриСозданииАдминистратора(Администратор, Уточнение) Экспорт
	
	Если ТипЗнч(Администратор) <> Тип("СправочникСсылка.Пользователи") Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Пользователь", Администратор);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.ПолномочияПользователей КАК ПолномочияПользователей
	|ГДЕ
	|	ПолномочияПользователей.Полномочия = ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор)
	|	И ПолномочияПользователей.Владелец = &Пользователь";
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КомментарийДляЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Пользователю ""%1"" добавлены полномочия Администратор по причине:
		           |%2';
		           |en = 'User ""%1"" added privileges of the administrator because:
		           |%2'"),
		Администратор,
		Уточнение);
	
	Объект = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
	
	НачатьТранзакцию();
	Попытка
		
		РегистрыСведений.ПолномочияПользователей.ДобавитьПолномочия(
			Администратор, Справочники.ПрофилиГруппДоступа.Администратор);
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Автоматическое изменение группы доступа Администраторы'; en = 'Access management.Automatic change Administrators access group'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			Метаданные.Справочники.Пользователи,
			Администратор,
			КомментарийДляЖурнала,
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
				
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Основные процедуры и функции.

// Добавляет пользователя в группу доступа, соответствующую поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, она будет создана.
//
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.РабочиеГруппы,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно включить в группу доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля или
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Процедура ВключитьПользователяВГруппуДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Истина);
	
КонецПроцедуры

// Удаляет пользователя из группы доступа, соответствующей поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, никаких действий не будет выполнено.
// 
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.РабочиеГруппы,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно исключить из группы доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля или
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Процедура ИсключитьПользователяИзГруппыДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Ложь);
	
КонецПроцедуры

// Найти пользователя в группе доступа, соответствующей поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, никаких действий не будет выполнено.
// 
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.РабочиеГруппы,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно найти в группе доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля или
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Функция НайтиПользователяВГруппеДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	Возврат ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль);
	
КонецФункции

// Устанавливает параметры сеанса по текущим настройкам констант и
// настройкам групп доступа пользователей.
//  Вызывается ПриНачалеРаботыСистемы.
//
Процедура УстановкаПараметровСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
	
	
	
КонецПроцедуры

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.УправлениеОбработчиками = Истина;
	Обработчик.Приоритет = 1;
	Обработчик.Версия = "*";
	Обработчик.МонопольныйРежим = Истина;
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьОбработчикиРазделенныхДанных";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.МонопольныйРежим = Истина;
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	
	//Обработчик = Обработчики.Добавить();
	//Обработчик.Версия = "*";
	//Обработчик.РежимВыполнения = "Монопольно";
	//Обработчик.Процедура = "РегистрыСведений.ПраваГруппДоступаНаТаблицы.Обновить";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ПреобразоватьИменаРолейВИдентификаторы";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.4.15";
	Обработчик.Процедура = "Справочники.ПрофилиГруппДоступа.ЗаполнитьИдентификаторыПоставляемыхДанных";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.1.55";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаменитьУдаленныеРолиВПрофиляхГруппДоступа";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.1.61";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьНазначениеПрофилейГруппДоступа";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "Справочники.ГруппыДоступа.ЗаполнитьПрофильГруппыДоступаАдминистраторы";
	Обработчик.РежимВыполнения = "Монопольно";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
КонецПроцедуры

// Переопределяет поведение после получения данных в распределенной ИБ.
Процедура ПослеПолученияДанных(Отправитель, Отказ, ОтПодчиненного) Экспорт
	
	УправлениеДоступом.ОбновитьРолиПользователей();
	
КонецПроцедуры

// Обновляет состав пользователей указанных групп исполнителей.
// 
// Требуется вызывать при изменении состава пользователей у групп исполнителей,
// например, у групп исполнителей задач.
//
// В качестве значений параметра передается группы исполнителей, состав которых изменился.
//
// Параметры:
//  ГруппыИсполнителей - Например, СправочникСсылка.ГруппыИсполнителейЗадач.
//                     - Массив значений указанных выше типов.
//                     - Неопределено - без отбора.
//
Процедура ОбновитьПользователейГруппИсполнителей(ГруппыИсполнителей = Неопределено) Экспорт
	
	
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему

// Доопределяет действия при записи пользователя, когда он записывается
// совместно с пользователем ИБ, у которого есть роль ПолныеПрава.
// 
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи (изменение объекта запрещено).
//
Процедура ПриЗаписиАдминистратора(Пользователь) Экспорт
	
	// Администраторы автоматически добавляются в группу доступа Администраторы.
	Если ПривилегированныйРежим() Тогда
		Объект = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
		Если Объект.Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
			Объект.Пользователи.Добавить().Пользователь = Пользователь;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Переопределяет текст комментария при авторизации пользователя ИБ,
// созданного в конфигураторе с административными правами.
//  Вызывается из Пользователи.АвторизоватьТекущегоПользователя().
//  Комментарий записывается в журнал регистрации.
// 
// Параметры:
//  Комментарий  - Строка - начальное значение задано.
//
Процедура ПослеЗаписиАдминистратораПриАвторизации(Комментарий) Экспорт
	
	Комментарий = НСтр("ru = 'Обнаружено, что пользователь информационной базы
	                         |с ролью ""Полные права"" был создан в Конфигураторе:
	                         |
	                         |- пользователь не найден в справочнике Пользователи,
	                         |- пользователь зарегистрирован в справочнике Пользователи,
	                         |- пользователь добавлен в группу доступа Администраторы.
	                         |
	                         |Пользователей информационной базы следует создавать в режиме 1С:Предприятия.';
	                         |en = 'User with the ""Full access"" role
	                         |was created in the Designer mode:
	                         |
	                         |- user not found in the catalog Users
	                         |- user is registered in the catalog Users
	                         |- user is added to the access group Administrators.
	                         |
	                         |Users should create the information base in 1C:Enterprise mode.'");
	
КонецПроцедуры

// Переопределяет действие при авторизации администратора локальной ИБ
// или администратора области данных.
//
Процедура ПриАвторизацииАдминистратораПриНачалеРаботыСистемы(Администратор) Экспорт
	
	// Администратор автоматически добавляется в группу доступа Администраторы при авторизации.
	Если ПривилегированныйРежим() Тогда
		
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
			ПользователиИнформационнойБазы.ТекущийПользователь().УникальныйИдентификатор);
		
		Если ПользовательИБ = Неопределено
			Или Не ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава) Тогда
			Возврат;
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Пользователь", Администратор);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
		|ГДЕ
		|	ГруппыДоступаПользователи.Ссылка = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.Администраторы)
		|	И ГруппыДоступаПользователи.Пользователь = &Пользователь";
		Если Запрос.Выполнить().Пустой() Тогда
			Объект = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
			Объект.Пользователи.Добавить().Пользователь = Администратор;
			Объект.ДополнительныеСвойства.Вставить("НезависимоеИзменениеОбъекта");
			Объект.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Содержит настройки размещения вариантов отчетов в панели отчетов.
//
// Параметры:
//   Настройки (Коллекция) Используется для описания настроек отчетов и вариантов
//       см. описание к ВариантыОтчетов.ДеревоНастроекВариантовОтчетовКонфигурации()
//
// Описание:
//   В данной процедуре необходимо указать каким именно образом предопределенные варианты отчетов
//   будут регистрироваться в программе и показываться в панели отчетов.
//
// Вспомогательные функции:
//   НастройкиОтчета   = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//   НастройкиВарианта = ВариантыОтчетов.ОписаниеВарианта(Настройки, НастройкиОтчета, "<ИмяВарианта>");
//
//   Данные функции получают соответственно настройки отчета и настройки варианта отчета следующей структуры:
//       |- Включен (Булево)
//            Если Ложь, то вариант отчета не регистрируется в подсистеме.
//              Используется для удаления технических и контекстных вариантов отчетов из всех интерфейсов.
//              Эти варианты отчета по прежнему можно открывать в форме отчета программно при помощи
//              параметров открытия (см. справку по "Расширение управляемой формы для отчета.КлючВарианта").
//       |- ВидимостьПоУмолчанию (Булево)
//            Если Ложь, то вариант отчета по умолчанию скрыт в панели отчетов.
//              Пользователь может "включить" его в режиме настройки панели отчетов
//              или открыть через форму "Все отчеты".
//       |- Описание (Строка)
//            Дополнительная информация по варианту отчета.
//              В панели отчетов выводится в качестве подсказки.
//              Должно расшифровывать для пользователя содержимое варианта отчета
//              и не должно дублировать наименование варианта отчета.
//       |- Размещение (Соответствие) Настройки размещения варианта отчета в разделах
//           |- Ключ     (ОбъектМетаданных) Подсистема, в которой размещается отчет или вариант отчета
//           |- Значение (Строка)           Необязательный. Настройки размещения в подсистеме.
//               |- ""        - Выводить отчет в своей группе обычным шрифтом.
//               |- "Важный"  - Выводить отчет в своей группе жирным шрифтом.
//               |- "СмТакже" - Выводить отчет в группе "См. также".
//       |- ФункциональныеОпции (Массив) из (Строка)
//            Имена функциональных опций варианта отчета.
//
// Например:
//
//  (1) Добавить в подсистему вариант отчета.
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Метаданные.Отчеты.ИмяОтчета, "ИмяВарианта1");
//	Вариант.Размещение.Вставить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//
//  (2) Отключить вариант отчета.
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Метаданные.Отчеты.ИмяОтчета, "ИмяВарианта1");
//	Вариант.Включен = Ложь;
//
//  (3) Отключить все варианты отчета, кроме требуемого.
//	Отчет = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.ИмяОтчета);
//	Отчет.Включен = Ложь;
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта");
//	Вариант.Включен = Истина;
//
//  (4) Результат исполнения 4.1 и 4.2 будет одинаковым:
//  (4.1)
//	Отчет = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.ИмяОтчета);
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта1");
//	Вариант.Размещение.Удалить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта2");
//	Вариант.Размещение.Удалить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//	Вариант = ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта3");
//	Вариант.Размещение.Удалить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//
//  (4.2)
//	Отчет = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.ИмяОтчета);
//	Отчет.Размещение.Удалить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//	ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта1");
//	ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта2");
//	ВариантыОтчетов.ОписаниеВарианта(Настройки, Отчет, "ИмяВарианта3");
//	Отчет.Размещение.Вставить(Метаданные.Подсистемы.ИмяРаздела.Подсистемы.ИмяПодсистемы);
//
// Важно:
//   Отчет выступает в качестве контейнера вариантов.
//     Изменяя настройки отчета можно сразу изменять настройки всех его вариантов.
//     Однако, если явно получить настройки варианта отчета, то они станут самостоятельными,
//     т.е. более не будут наследовать изменения настроек от отчета. См. примеры 3 и 4.
//   
//   Начальная настройка размещения отчетов по подсистемам зачитывается из метаданных,
//     ее дублирование в коде не требуется.
//   
//   Функциональные опции вариантов объединяются с функциональными опциями отчетов по следующим правилам:
//     (ФункциональнаяОпция1Отчета ИЛИ ФункциональнаяОпция2Отчета) И (ФункциональнаяОпция3Варианта ИЛИ ФункциональнаяОпция4Варианта).
//   Функциональные опции отчетов не зачитываются из метаданных,
//     они применяются на этапе использования подсистемы пользователем.
//   Через ОписаниеОтчета можно добавлять функциональные опции, которые будут соединяться по указанным выше правилам,
//     но надо помнить, что эти функциональные опции будут действовать только для предопределенных вариантов этого отчета.
//   Для пользовательских вариантов отчета действуют только функциональные опции отчета
//     - они отключаются только с отключением всего отчета.
//
Процедура ПриНастройкеВариантовОтчетов(Настройки) Экспорт
	
	
	
КонецПроцедуры

// Доопределяет действия, необходимые после установки пользователя
// информационной базы у пользователя или внешнего пользователя,
// т.е. при изменении реквизита ИдентификаторПользователяИБ на не пустой.
//
// Например, можно обновить роли.
// 
// Параметры:
//  Ссылка - СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи - пользователь.
//
Процедура ПослеУстановкиПользователяИБ(Ссылка, ПарольПользователяСервиса) Экспорт
	
	УправлениеДоступом.ОбновитьРолиПользователей(Ссылка, ПарольПользователяСервиса);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Обновляет список ролей пользователей информационной базы
// по их текущим принадлежностям к группам доступа.
//  Пользователи с ролью "ПолныеПрава" игнорируется.
// 
// Параметры:
//  Пользователи - СправочникСсылка.Пользователи,
//                 СправочникСсылка.ВнешниеПользователи.
//                 Массив значений указанных выше типов.
//               - Неопределено - обновить роли всех пользователей.
//               - Тип по которому будет найден объект метаданных:
//                 если будет найден Справочник.ВнешниеПользователи,
//                 то будут обновлены роли всех внешних пользователей,
//                 иначе будут обновлены роли всех пользователей.
//
//  ПарольПользователяСервиса - Строка - Пароль для авторизации в менеджере 
//                        сервиса
//  ЕстьИзменения - Булево (возвращаемое значение) - в этот параметр возвращается
//                  значение Истина, если производилась запись, иначе не изменяется.
//
Процедура ОбновитьРолиПользователей(Знач Пользователи1 = Неопределено,
                                    Знач ПарольПользователяСервиса = Неопределено,
                                    ЕстьИзменения = Ложь) Экспорт
	
	Если НЕ ПользователиСлужебный.ЗапретРедактированияРолей() Тогда
		// Роли устанавливаются механизмами подсистем Пользователи и ВнешниеПользователи.
		Возврат;
	КонецЕсли;
	
	Если Пользователи1 = Неопределено Тогда
		МассивПользователей = Неопределено;
		Пользователи.НайтиНеоднозначныхПользователейИБ(,);
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Массив") Тогда
		МассивПользователей = Пользователи1;
		Если МассивПользователей.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		Пользователи.НайтиНеоднозначныхПользователейИБ(,);
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Тип") Тогда
		МассивПользователей = Пользователи1;
	Иначе
		МассивПользователей = Новый Массив;
		МассивПользователей.Добавить(Пользователи1);
		Пользователи.НайтиНеоднозначныхПользователейИБ(Пользователи1);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекущиеСвойстваПользователей = ТекущиеСвойстваПользователей(МассивПользователей);
	
	// Параметры проверки в цикле.
	ВсеРоли                       = ПользователиСлужебный.ВсеРоли().Соответствие;
	ИдентификаторыПользователейИБ = ТекущиеСвойстваПользователей.ИдентификаторыПользователейИБ;
	НовыеРолиПользователей        = ТекущиеСвойстваПользователей.РолиПользователей;
	Администраторы                = ТекущиеСвойстваПользователей.Администраторы;
	
	ИмяРолиАдминистратораСистемы = Пользователи.РольАдминистратораСистемы().Имя;
	РолиАдминистратора = Новый Соответствие;
	РолиАдминистратора.Вставить("ПолныеПрава", Истина);
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если ИмяРолиАдминистратораСистемы <> "ПолныеПрава" Тогда
			РолиАдминистратора.Вставить(ИмяРолиАдминистратораСистемы, Истина);
		КонецЕсли;
	КонецЕсли;
	
	// Будущий итог после цикла.
	НовыеАдминистраторыИБ     = Новый Соответствие;
	ОбновляемыеПользователиИБ = Новый Соответствие;
	
	Для каждого ОписаниеПользователя Из ИдентификаторыПользователейИБ Цикл
		
		ТекущийПользователь         = ОписаниеПользователя.Пользователь;
		ИдентификаторПользователяИБ = ОписаниеПользователя.ИдентификаторПользователяИБ;
		НовыйАдминистраторИБ        = Ложь;
		
		// Поиск пользователя ИБ.
		Если ТипЗнч(ИдентификаторПользователяИБ) = Тип("УникальныйИдентификатор") Тогда
			ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				ИдентификаторПользователяИБ);
		Иначе
			ПользовательИБ = Неопределено;
		КонецЕсли;
		
		СтарыеРоли = Неопределено;
		
		Если ПользовательИБ <> Неопределено И ЗначениеЗаполнено(ПользовательИБ.Имя) Тогда
			
			НовыеРоли = НовыеРолиПользователей.Скопировать(НовыеРолиПользователей.НайтиСтроки(
				Новый Структура("Пользователь", ТекущийПользователь)), "Роль");
			
			НовыеРоли.Индексы.Добавить("Роль");
			
			// Проверка старых ролей.
			СтарыеРоли        = Новый Соответствие;
			РолиДляДобавления = Новый Соответствие;
			РолиДляУдаления   = Новый Соответствие;
			
			Если Администраторы[ТекущийПользователь] = Неопределено Тогда
				Для каждого Роль Из ПользовательИБ.Роли Цикл
					ИмяРоли = Роль.Имя;
					СтарыеРоли.Вставить(ИмяРоли, Истина);
					Если НовыеРоли.Найти(ИмяРоли, "Роль") = Неопределено Тогда
						РолиДляУдаления.Вставить(ИмяРоли, Истина);
					КонецЕсли;
				КонецЦикла;
			Иначе // Администратор.
				Для каждого Роль Из ПользовательИБ.Роли Цикл
					ИмяРоли = Роль.Имя;
					СтарыеРоли.Вставить(ИмяРоли, Истина);
					Если РолиАдминистратора[ИмяРоли] = Неопределено Тогда
						РолиДляУдаления.Вставить(ИмяРоли, Истина);
					КонецЕсли;
				КонецЦикла;
				
				Для каждого КлючИЗначение Из РолиАдминистратора Цикл
					
					Если СтарыеРоли[КлючИЗначение.Ключ] = Неопределено Тогда
						РолиДляДобавления.Вставить(КлючИЗначение.Ключ, Истина);
						
						Если КлючИЗначение.Ключ = ИмяРолиАдминистратораСистемы Тогда
							НовыйАдминистраторИБ = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			// Проверка новых ролей.
			Для каждого Строка ИЗ НовыеРоли Цикл
				
				Если СтарыеРоли = Неопределено
				 ИЛИ Администраторы[ТекущийПользователь] <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если СтарыеРоли[Строка.Роль] = Неопределено Тогда
					Если ВсеРоли.Получить(Строка.Роль) <> Неопределено Тогда
					
						РолиДляДобавления.Вставить(Строка.Роль, Истина);
						
						Если Строка.Роль = ИмяРолиАдминистратораСистемы Тогда
							НовыйАдминистраторИБ = Истина;
						КонецЕсли;
					Иначе
						// Новые роли не найденные в метаданных.
						Профили = ПрофилиПользователяСРолью(ТекущийПользователь, Строка.Роль);
						Для каждого Профиль Из Профили Цикл
							ЗаписьЖурналаРегистрации(
								НСтр("ru = 'Управление доступом.Роль не найдена в метаданных'; en = 'Access management.Role not found in metadata'",
								     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
								УровеньЖурналаРегистрации.Ошибка,
								,
								,
								СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
									НСтр("ru= 'При обновлении ролей пользователя ""%1""
									          |роль ""%2""
									          |профиля групп доступа ""%3""
									          |не найдена в метаданных.';
									          |en = 'When updating roles of user ""%1""
									          |role ""%2"" 
									          |of access group profile ""%3"" 
									          |was not found in metadata.'"),
									Строка(ТекущийПользователь),
									Строка.Роль,
									Строка(Профиль)),
								РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
		// Завершение обработки текущего пользователя.
		Если СтарыеРоли <> Неопределено
		   И (  РолиДляДобавления.Количество() <> 0
			  ИЛИ РолиДляУдаления.Количество() <> 0) Тогда
			
			ИзмененияРолей = Новый Структура;
			ИзмененияРолей.Вставить("ПользовательСсылка", ТекущийПользователь);
			ИзмененияРолей.Вставить("ПользовательИБ",     ПользовательИБ);
			ИзмененияРолей.Вставить("РолиДляДобавления",  РолиДляДобавления);
			ИзмененияРолей.Вставить("РолиДляУдаления",    РолиДляУдаления);
			
			Если НовыйАдминистраторИБ Тогда
				НовыеАдминистраторыИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
			Иначе
				ОбновляемыеПользователиИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
			КонецЕсли;
			
			ЕстьИзменения = Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Добавление новых администраторов.
	ОбновитьРолиПользователейИБ(НовыеАдминистраторыИБ, ПарольПользователяСервиса);
	
	// Удаление старых администраторов и обновление остальных пользователей.
 	ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса);
	
	// Пересчет прав по дескрипторам.
	ДокументооборотПраваДоступа.ОбновитьПраваПриИзмененииРолейПользователей(ОбновляемыеПользователиИБ);
	
КонецПроцедуры

// Проверка группы доступа Администраторы перед записью.
Процедура ПроверитьНаличиеПользователяИБВГруппеДоступаАдминистраторы(ПользователиГруппы, ОписаниеОшибки) Экспорт
	
	Пользователи.НайтиНеоднозначныхПользователейИБ(,);
	
	// Проверка пустого списка пользователей ИБ в группе доступа Администраторы.
	УстановитьПривилегированныйРежим(Истина);
	НайденПользовательИБ = Ложь;
	
	Для каждого ОписаниеПользователя ИЗ ПользователиГруппы Цикл
		
		Если ЗначениеЗаполнено(ОписаниеПользователя.Пользователь)
		   И ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
		         ОписаниеПользователя.Пользователь.ИдентификаторПользователяИБ) <> Неопределено Тогда
			
			НайденПользовательИБ = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ НайденПользовательИБ Тогда
		ОписаниеОшибки =
			НСтр("ru = 'В группе доступа Администраторы
			           |должен быть хотя бы один пользователь,
			           |которому разрешен доступ к информационной базе.';
			           |en = 'Administrators access group should contain 
			           |at least one user who is permitted to access 
			           |the infobase.'");
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП

// Возвращает соответствие имен параметров сеанса и обработчиков для их инициализации.
//
Процедура ПриДобавленииОбработчиковУстановкиПараметровСеанса(Обработчики) Экспорт
	
	Обработчики.Вставить("ОграничиватьДоступПоВиду*",               "УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	Обработчики.Вставить("ВидыДоступа*",                            "УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
КонецПроцедуры

// Заполняет массив списком имен объектов метаданных, данные которых могут содержать ссылки на различные объекты метаданных,
// но при этом эти ссылки не должны учитываться в бизнес-логике приложения.
//
// Параметры:
//  Массив       - массив строк, например, "РегистрСведений.ВерсииОбъектов".
//
Процедура ПриДобавленииИсключенийПоискаСсылок(Массив) Экспорт
	
	
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной информационной базе.
//
// Параметры:
// см. описание обработчика события ПриПолученииДанныхОтПодчиненного() в синтаксис-помощнике.
// 
Процедура ПриПолученииДанныхОтПодчиненного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		
		// Стандартная обработка не переопределяется.
		
	ИначеЕсли ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		Если ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ОграничиватьДоступНаУровнеЗаписей")
			ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа")
			ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа") Тогда
			
			// Получение данных из автономного рабочего места пропускается, а для соответствия
			// данных в узлах, текущие данные отправляются обратно в автономное рабочее место.
			ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
			ОтправкаНазад = Истина;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура-обработчик события после получения данных в главном узле от подчиненного узла распределенной ИБ.
// Вызывается в момент завершения чтения сообщения обмена, когда все данные из сообщения обмена успешно прочитаны и записаны в ИБ.
// 
//  Параметры:
// Отправитель – ПланОбменаОбъект. Объект узла плана обмена, от которого получены данные.
// Отказ – Булево. Флаг отказа. Если установить данному параметру значение Истина,
// то сообщение будет считаться не принятым. Также произойдет отмена транзакции загрузки данных,
// если все данные были загружены в одной транзакции или отмена последней транзакции загрузки данных,
// если данные были загружены порциями.
//
Процедура ПослеПолученияДанныхОтПодчиненного(Отправитель, Отказ) Экспорт
	
	ПослеПолученияДанных(Отправитель, Отказ, Истина);
	
КонецПроцедуры

// Процедура-обработчик события после получения данных в подчиненном узле от главного узла распределенной ИБ.
// Вызывается в момент завершения чтения сообщения обмена, когда все данные из сообщения обмена успешно прочитаны и записаны в ИБ.
// 
//  Параметры:
// Отправитель – ПланОбменаОбъект. Объект узла плана обмена, от которого получены данные.
// Отказ – Булево. Флаг отказа. Если установить данному параметру значение Истина,
// то сообщение будет считаться не принятым. Также произойдет отмена транзакции загрузки данных,
// если все данные были загружены в одной транзакции или отмена последней транзакции загрузки данных,
// если данные были загружены порциями.
//
Процедура ПослеПолученияДанныхОтГлавного(Отправитель, Отказ) Экспорт
	
	ПослеПолученияДанных(Отправитель, Отказ, Ложь);
	
КонецПроцедуры

// Используется для получения объектов метаданных обязательных для плана обмена.
// Если подсистема имеет объекты метаданных обязательные для включения в состав плана обмена,
// то в параметр <Объект> необходимо добавить эти объекты метаданных.
//
// Параметры:
// Объекты – Массив. Массив объектов метаданных конфигурации, которые необходимо включить в состав плана обмена.
// РаспределеннаяИнформационнаяБаза (только чтение) – Булево. Признак получения объектов для плана обмена РИБ.
// Истина – требуется получить список объектов плана обмена РИБ;
// Ложь – требуется получить список для плана обмена НЕ РИБ.
//
Процедура ПриПолученииОбязательныхОбъектовПланаОбмена(Объекты, Знач РаспределеннаяИнформационнаяБаза) Экспорт
	
	Если РаспределеннаяИнформационнаяБаза Тогда
		
		Объекты.Добавить(Метаданные.Константы.ПараметрыОграниченияДоступа);
		Объекты.Добавить(Метаданные.ПланыВидовХарактеристик.ВидыДоступа);
		Объекты.Добавить(Метаданные.РегистрыСведений.ПраваРолей);
		
	КонецЕсли;
	
КонецПроцедуры

// Используется для получения объектов метаданных, которые должны входить в состав плана обмена
// и НЕ должны входить в состав подписок на события регистрации изменений для этого плана обмена.
// Эти объекты метаданных используются только в момент создания начального образа подчиненного узла
// и не мигрируют в процессе обмена.
// Если подсистема имеет объекты метаданных, которые участвуют только в создании начального образа подчиненного узла,
// то в параметр <Объект> необходимо добавить эти объекты метаданных.
//
// Параметры:
// Объекты – Массив. Массив объектов метаданных конфигурации.
//
Процедура ПриПолученииОбъектовНачальногоОбразаПланаОбмена(Объекты) Экспорт
	
	Объекты.Добавить(Метаданные.Константы.ПараметрыОграниченияДоступа);
	Объекты.Добавить(Метаданные.ПланыВидовХарактеристик.ВидыДоступа);
	Объекты.Добавить(Метаданные.РегистрыСведений.ПраваРолей);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистемы Пользователи.

// Переопределяет текст вопроса перед записью первого администратора.
//  Вызывается из обработчика ПередЗаписью формы пользователя.
//  Вызов выполняется если установлен ЗапретРедактированияРолей() и
// количество пользователей информационной базы равно нулю.
// 
Процедура ПриОпределенииТекстаВопросаПередЗаписьюПервогоАдминистратора(ТекстВопроса) Экспорт
	
	ТекстВопроса = НСтр("ru = 'В список пользователей программы добавляется первый пользователь,
		|поэтому он будет автоматически включен в группу доступа Администраторы. 
		|Продолжить?';
		|en = 'In the list of users, the first user is added, 
		|so he will automatically included in the access group administrators. 
		|Do you want to continue?'")
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события

// Обработчик подписки ОбновитьГруппыЗначенийДоступа на событие ПередЗаписью
// вызывает метод записи групп значений доступа в
// РегистрСведений.ГруппыЗначенийДоступа, для требуемых объектов метаданных.
//
Процедура ОбновитьГруппыЗначенийДоступа(Знач Объект, Отказ) Экспорт
	
	
	
КонецПроцедуры

// Обработчик подписки ЗаписатьНаборыЗначенийДоступа на событие ПриЗаписи
// вызывает метод записи значений доступа объекта в РегистрСведений.НаборыЗначенийДоступа.
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если наборы значений доступа не применяются.
//
Процедура ЗаписатьНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	
	
КонецПроцедуры

// Обработчик подписки ЗаписатьЗависимыеНаборыЗначенийДоступа события ПриЗаписи
// вызывает перезапись зависимых наборов значений доступа в регистре сведений НаборыЗначенийДоступа.
//
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если зависимые наборы значений доступа не применяются.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьЗависимыеНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	ЗаписатьЗависимыеНаборыЗначенийДоступа(Объект);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий

// Обработчик регламентного задания ЗаполнениеДанныхДляОграниченияДоступа.
Процедура ЗаполнениеДанныхДляОграниченияДоступаОбработчикЗадания() Экспорт
	
	ЗаполнениеДанныхДляОграниченияДоступа();
	
КонецПроцедуры

// Выполняет последовательное заполнение и обновление данных, необходимых для работы
// подсистемы УправленияДоступом в режиме ограничения доступа на уровне записей.
// 
//  При включенном режиме ограничения доступа на уровне записей заполняет наборы
// значений доступа. Заполнение выполняется частями при каждом запуске, пока все
// наборы значений доступа не будут заполнены.
//  При отключении режима ограничения доступа на уровне записей наборы значений доступа
// (заполненные ранее) удаляются при перезаписи объектов, а не все сразу.
//  Независимо от режима ограничения доступа на уровне записей обновляет вторичные
// данные: группы значений доступа и дополнительные поля в существующих наборах значений доступа.
//  После завершения всех обновлений и заполнений отключает использование регламентного
// задания.
//
//  Сведения о состоянии работы записываются в журнал регистрации.
//
//  Возможно вызывать программно, например, при обновлении информационной базы.
// Также для целей обновления есть форма Справочник.ГруппыДоступа.ОбновлениеДанныхОграниченияДоступа,
// с помощью которой можно сделать интерактивное обновление данных ограничения доступа
// при обновлении информационной базы.
//
Процедура ЗаполнениеДанныхДляОграниченияДоступа(КоличествоДанных = 0) Экспорт
	
	
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с пользователями и группами пользователей

// Обновляет группировки пользователей после обновления составов групп пользователей
// используемых для выполнения проверок разрешенных пользователей.
//
// Параметры:
//  УчастникиИзменений - Массив значений типов:
//                       - СправочникСсылка.Пользователи.
//                       - СправочникСсылка.ВнешниеПользователи.
//                       Пользователи которые участвовали в изменении состава групп.
//
//  ИзмененныеГруппы   - Массив значений типов:
//                       - СправочникСсылка.РабочиеГруппы.
//                       - СправочникСсылка.ГруппыВнешнихПользователей.
//                       Группы, состав которых был изменен.
//
Процедура ПослеОбновленияСоставовГруппПользователей(УчастникиИзменений, ИзмененныеГруппы) Экспорт
	
	
	
КонецПроцедуры

// Обновляет связь для новой группы пользователей (группы внешних пользователей).
//
// Параметры:
//  Ссылка     - СправочникСсылка.Пользователи.
//             - СправочникСсылка.РабочиеГруппы.
//             - СправочникСсылка.ВнешниеПользователи.
//             - СправочникСсылка.ГруппыВнешнихПользователей.
//
//  ЭтоНовый   - Булево, если Истина, объект был добавлен, иначе изменен.
//
Процедура ПослеДобавленияИзмененияПользователяИлиГруппы(Ссылка, ЭтоНовый) Экспорт
	
	//Если ЭтоНовый Тогда
	//	Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.РабочиеГруппы")
	//	 ИЛИ ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
	//	
	//		Параметры = Новый Структура;
	//		Параметры.Вставить("ГруппыПользователей", Ссылка);
	//		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	//	КонецЕсли;
	//КонецЕсли;
	
КонецПроцедуры

// Обновляет группировки внешних пользователей по объекту авторизации.
//
// Параметры:
//  ВнешнийПользователь     - СправочникСсылка.ВнешниеПользователи.
//  СтарыйОбъектАвторизации - NULL - при добавлении внешнего пользователя.
//                            Например, СправочникСсылка.ФизическиеЛица.
//  НовыйОбъектАвторизации  - Например, СправочникСсылка.ФизическиеЛица.
//
Процедура ПослеИзмененияОбъектаАвторизацииВнешнегоПользователя(ВнешнийПользователь,
                                                               СтарыйОбъектАвторизации = Неопределено,
                                                               НовыйОбъектАвторизации) Экспорт
	
	ОбъектыАвторизации = Новый Массив;
	Если СтарыйОбъектАвторизации <> NULL Тогда
		ОбъектыАвторизации.Добавить(СтарыйОбъектАвторизации);
	КонецЕсли;
	ОбъектыАвторизации.Добавить(НовыйОбъектАвторизации);
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбъектыАвторизации", ОбъектыАвторизации);
	
	//РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с видами доступа

// Возвращает использование вида доступа.
// Параметры:
//  ВидДоступа   - ПланВидовХарактеристикСсылка.ВидыДоступа.
//
// Возвращаемое значение:
//  Булево.
//
Функция ВидДоступаИспользуется(Знач ВидДоступа) Экспорт
	
	СвойстваВидаДоступа = СвойстваВидаДоступа(ВидДоступа);
	ТипыВидаДоступа = СвойстваВидаДоступа.Таблицы;
	
	Используется = Ложь;
	
	Для Каждого ТипВидаДоступа Из ТипыВидаДоступа Цикл
		ВидДоступаОМД = Метаданные.НайтиПоПолномуИмени(ТипВидаДоступа);
		
		Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ВидДоступаОМД) Тогда
			Используется = Истина;
		КонецЕсли;
	КонецЦикла;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииИспользованияВидаДоступа");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаполненииИспользованияВидаДоступа(ВидДоступа, Используется);
	КонецЦикла;
	
	УправлениеДоступомПереопределяемый.ЗаполнитьИспользованиеВидаДоступа(ВидДоступа, Используется);
	
	Возврат Используется;
	
КонецФункции

// Возвращает свойства вида доступа или всех видов доступа.
//
// Параметры:
//  ВидДоступа   - Строка, ПланВидовХарактеристикСсылка.ВидыДоступа, Неопределено.
//
// Возвращаемое значение:
//  Неопределено - когда для вида доступа свойств не найдено,
//  ТаблицаЗначений или Структура со свойствами,
//      описание которых см. в комментарии к функции
//      ПланыВидовХарактеристик.ВидыДоступа.СвойстваВидовДоступа().
//
Функция СвойстваВидаДоступа(Знач ВидДоступа = Неопределено) Экспорт
	
	Свойства = УправлениеДоступомСлужебныйПовтИсп.Параметры().СвойстваВидовДоступа;
	
	Если ВидДоступа = Неопределено Тогда
		Возврат Свойства.Таблица.Получить();
		
	ИначеЕсли ТипЗнч(ВидДоступа) = Тип("Строка") Тогда
		Возврат Свойства.ПоИменам.Получить(ВидДоступа);
		
	КонецЕсли;
	
	Возврат Свойства.ПоСсылкам.Получить(ВидДоступа);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с наборами значений доступа

// Заполняет вспомогательные данные, ускоряющие работу шаблонов ограничений доступа.
//  Выполняется перед записью в регистр НаборыЗначенийДоступа или
// перед записью объекта с табличной частью НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаНаОбъект - СправочникСсылка.*, ДокументСсылка.*, ...
//  Таблица        - ТабличнаяЧасть (или ТаблицаЗначений), РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа
//
Процедура ПодготовкаНаборовЗначенийДоступаПередЗаписью(СсылкаНаОбъект, Таблица) Экспорт
	
	
	
КонецПроцедуры

// Возвращает новые наборы для заполнения табличной части.
Функция ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект) Экспорт
	
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если Объект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверные параметры.
				           |Тип объекта ""%1""
				           |не найдена табличная часть ""Наборы значений доступа"".';
				           |en = 'Invalid parameters. 
				           |Object type ""%1"" 
				           |is not found the tabular section ""Sets of accsess values"".'"),
				ТипЗначенияОбъект));
	КонецЕсли;
	
	Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		
		НаборыЗаполняются = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
			"ЗаписатьНаборыЗначенийДоступа
			|ЗаписатьЗависимыеНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
		
		Если НЕ НаборыЗаполняются Тогда
			ВызватьИсключение(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден ни в одной из подписок на события
					           |""Записать наборы значений доступа"",
					           |""Записать зависимые наборы значений доступа"".';
					           |en = 'Invalid parameters.
					           |Object type ""%1""
					           |was not found in any of the event subscriptions
					           |""Write access value sets"",
					           |""Write dependent sets of values"".'"),
					ТипЗначенияОбъект));
		КонецЕсли;
		
		Объект.ЗаполнитьНаборыЗначенийДоступа(Таблица);
		
		Если Таблица.Количество() = 0 Тогда
			// Если это условие отключить, тогда зациклится регламентное задание
			// заполнения данных для ограничения доступа.
			ВызватьИсключение(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Объект ""%1"" сформировал пустой набор значений доступа.'; en = 'Object ""%1"" formed an empty set of values access.'"),
					ТипЗначенияОбъект));
		КонецЕсли;
		
		УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
		
		ПодготовкаНаборовЗначенийДоступаПередЗаписью(СсылкаНаОбъект, Таблица);
		
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Перезаписывает наборы значений доступа проверяемого объекта
// в РегистрСведений.НаборыЗначенийДоступа, используя процедуру
// УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа().
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьНаборыЗначенийДоступа(),
// но может быть вызвана из любого места, например,
// при включении ограничения доступа на уровне записей.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
Процедура ЗаписатьНаборыЗначенийДоступа(Знач Объект) Экспорт
	
	
	
КонецПроцедуры

// Перезаписывает наборы значений доступа зависимых объектов.
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьЗависимыеНаборыЗначенийДоступа(),
// состав типов подписки дополняет (без пересечения) состав типов подписки ЗаписатьНаборыЗначенийДоступа,
// теми типами, для которых выполнять запись наборов в регистр сведений НаборыЗначенийДоступа
// не требуется, но сами наборы входят в состав других наборов, например, наборы некоторых файлов
// из справочника "Файлы" могут входить в состав некоторых бизнес-процессов "Задание", созданных
// на основании файлов, при этом наборы файлов записывать в регистр не требуется.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа,
// то есть организуется рекурсия.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступа(Знач Объект) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	ЭтоВедущийОбъект = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьЗависимыеНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ ЭтоВедущийОбъект Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверные параметры.
				           |Тип объекта ""%1""
				           |не найден в подписке на события
				           |""Записать зависимые наборы значений доступа"".';
				           |en = 'Invalid parameters.
				           |Object type ""%1""
				           |is not found in the subscription to events,
				           |""Record the dependent sets of values access"".'"),
				ТипЗначенияОбъект));
	КонецЕсли;
	
	ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект);
	
КонецПроцедуры

// Проверяет, что наборы в табличной части отличаются от новых наборов.
Функция НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, НовыеНаборы) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СтарыеНаборы", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "НаборыЗначенийДоступа"));
	Запрос.УстановитьПараметр("НовыеНаборы",  НовыеНаборы);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НовыеНаборы.НомерНабора,
	|	НовыеНаборы.ВидДоступа,
	|	НовыеНаборы.ЗначениеДоступа,
	|	НовыеНаборы.Чтение,
	|	НовыеНаборы.Добавление,
	|	НовыеНаборы.Изменение,
	|	НовыеНаборы.Удаление
	|ПОМЕСТИТЬ НовыеНаборы
	|ИЗ
	|	&НовыеНаборы КАК НовыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СтарыеНаборы.НомерНабора,
	|	СтарыеНаборы.ВидДоступа,
	|	СтарыеНаборы.ЗначениеДоступа,
	|	СтарыеНаборы.Чтение,
	|	СтарыеНаборы.Добавление,
	|	СтарыеНаборы.Изменение,
	|	СтарыеНаборы.Удаление
	|ПОМЕСТИТЬ СтарыеНаборы
	|ИЗ
	|	&СтарыеНаборы КАК СтарыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	СтарыеНаборы КАК СтарыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовыеНаборы КАК НовыеНаборы
	|		ПО СтарыеНаборы.НомерНабора = НовыеНаборы.НомерНабора
	|			И СтарыеНаборы.ВидДоступа = НовыеНаборы.ВидДоступа
	|			И СтарыеНаборы.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа
	|			И СтарыеНаборы.Чтение = НовыеНаборы.Чтение
	|			И СтарыеНаборы.Добавление = НовыеНаборы.Добавление
	|			И СтарыеНаборы.Изменение = НовыеНаборы.Изменение
	|			И СтарыеНаборы.Удаление = НовыеНаборы.Удаление
	|ГДЕ
	|	НовыеНаборы.НомерНабора ЕСТЬ NULL 
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	НовыеНаборы КАК НовыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ СтарыеНаборы КАК СтарыеНаборы
	|		ПО (СтарыеНаборы.НомерНабора = НовыеНаборы.НомерНабора)
	|			И (СтарыеНаборы.ВидДоступа = НовыеНаборы.ВидДоступа)
	|			И (СтарыеНаборы.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа)
	|			И (СтарыеНаборы.Чтение = НовыеНаборы.Чтение)
	|			И (СтарыеНаборы.Добавление = НовыеНаборы.Добавление)
	|			И (СтарыеНаборы.Изменение = НовыеНаборы.Изменение)
	|			И (СтарыеНаборы.Удаление = НовыеНаборы.Удаление)
	|ГДЕ
	|	СтарыеНаборы.НомерНабора ЕСТЬ NULL ";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для действий при изменений настроек подсистемы

// Если необходимо, включает заполнение данных для ограничения доступа и
// обновляет некоторые данные сразу.
//
// Вызывается из обработчика ПриЗаписи константы ОграничиватьДоступаНаУровнеЗаписей.
//
Процедура ПриИзмененииОграниченияДоступаНаУровнеЗаписей(ОграничениеДоступаНаУровнеЗаписейВключено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОграничениеДоступаНаУровнеЗаписейВключено Тогда
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Started filling in data for access restrictions.'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Начато заполнение данных для ограничения доступа.'; en = 'Started filling in data for access restrictions.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			ПриВключенииЗаполненияДанныхДляОграниченияДоступа(Истина);
		Иначе
			//Задание = РегламентныеЗадания.НайтиПредопределенное(
			//	Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
			//Задание.Использование = Истина;
			//Задание.Записать();
		КонецЕсли;
	КонецЕсли;
	
	// Обновление параметров сеанса.
	// Требуется для того, чтобы администратор не выполнял перезапуск.
	УстановленныеПараметры = Новый Массив;
	УстановкаПараметровСеанса("ОграничиватьДоступПоВиду", УстановленныеПараметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы интерфейсов пользователей

// Возвращает список значений доступа не помеченных на удаление.
//  Используется в обработчиках событий ОкончаниеВводаТекста и АвтоПодбор.
//
// Параметры:
//  Текст         - Строка, символы введенные пользователем.
//  ВключаяГруппы - Булево, если Истина, включать группы пользователей и внешних пользователей.
//  ВидДоступа    - ПланыВидовХарактеристикСсылка.ВидыДоступа, значения доступа которого выбираются.
//
Функция СформироватьДанныеВыбораЗначенияДоступа(Знач Текст, Знач ВидДоступа, ВключаяГруппы = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Текст", Текст + "%");
	Запрос.УстановитьПараметр("ВключаяГруппы", ВключаяГруппы);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПредставленияПеречислений.Ссылка,
	|	ПредставленияПеречислений.Наименование КАК Наименование
	|ПОМЕСТИТЬ ПредставленияПеречислений
	|ИЗ
	|	&ПредставленияПеречислений КАК ПредставленияПеречислений
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	НЕОПРЕДЕЛЕНО КАК Ссылка,
	|	"""" КАК Наименование
	|ГДЕ
	|	ЛОЖЬ";
	
	ЗапросПредставленийПеречислений = Новый Запрос;
	ЗапросПредставленийПеречислений.Текст =
	"ВЫБРАТЬ
	|	"""" КАК Ссылка,
	|	"""" КАК Наименование
	|ГДЕ
	|	ЛОЖЬ";
	
	Для каждого Тип Из ВидДоступа.ТипЗначения.Типы() Цикл
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		
		ПолноеИмяТаблицы = МетаданныеТипа.ПолноеИмя();
		
		Если (     Метаданные.Справочники.Содержит(МетаданныеТипа)
		       ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеТипа) )
		   И МетаданныеТипа.Иерархический
		   И МетаданныеТипа.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
		   И НЕ ВключаяГруппы Тогда
			
			УсловиеДляГруппы = "НЕ Таблица.ЭтоГруппа";
		Иначе
			УсловиеДляГруппы = "Истина";
		КонецЕсли;
		
		Если Метаданные.Перечисления.Содержит(МетаданныеТипа) Тогда
			//
			ЗапросПредставленийПеречислений.Текст = ЗапросПредставленийПеречислений.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
			ЗапросПредставленийПеречислений.Текст = ЗапросПредставленийПеречислений.Текст + СтрЗаменить(
			"ВЫБРАТЬ
			|	Таблица.Ссылка,
			|	ПРЕДСТАВЛЕНИЕ(Таблица.Ссылка) КАК Наименование
			|ИЗ
			|	&ПолноеИмяТаблицы КАК Таблица", "&ПолноеИмяТаблицы", ПолноеИмяТаблицы);
		Иначе
			Запрос.Текст = Запрос.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
			Запрос.Текст = Запрос.Текст + СтрЗаменить(СтрЗаменить(
			"ВЫБРАТЬ
			|	Таблица.Ссылка,
			|	Таблица.Наименование
			|ИЗ
			|	&ПолноеИмяТаблицы КАК Таблица
			|ГДЕ
			|	(НЕ Таблица.ПометкаУдаления)
			|	И Таблица.Наименование ПОДОБНО &Текст
			|	И &УсловиеДляГруппы", "&ПолноеИмяТаблицы", ПолноеИмяТаблицы), "&УсловиеДляГруппы", УсловиеДляГруппы);
		КонецЕсли;
	КонецЦикла;
	
	Запрос.УстановитьПараметр("ПредставленияПеречислений", ЗапросПредставленийПеречислений.Выполнить().Выгрузить());
	Запрос.Текст = Запрос.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
	Запрос.Текст = Запрос.Текст +
	"ВЫБРАТЬ
	|	ПредставленияПеречислений.Ссылка,
	|	ПредставленияПеречислений.Наименование
	|ИЗ
	|	ПредставленияПеречислений КАК ПредставленияПеречислений
	|ГДЕ
	|	ПредставленияПеречислений.Наименование ПОДОБНО &Текст";
	
	ДанныеВыбора = Новый СписокЗначений;
	

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ДанныеВыбора.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
	Возврат ДанныеВыбора;
	
КонецФункции

// Возвращает название объекта метаданных с учетом заданных свойств в порядке:
//  - РасширенноеПредставлениеОбъекта,
//  - ПредставлениеОбъекта,
//  - Синоним,
//  - Имя.
//
// Параметры:
//  МетаданныеОбъекта - ОбъектМетаданных.
//
// Возвращаемое значение:
//  Строка.
//
Функция НазваниеОбъектаИзМетаданных(МетаданныеОбъекта) Экспорт
	
	Если ЗначениеЗаполнено(МетаданныеОбъекта.РасширенноеПредставлениеОбъекта) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.РасширенноеПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.ПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(МетаданныеОбъекта.Синоним) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.Синоним;
	Иначе
		НазваниеОбъекта = МетаданныеОбъекта.Имя;
	КонецЕсли;
	
	Возврат НазваниеОбъекта;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

// Возвращает ссылку старого объекта или ссылку нового объекта.
//
// Параметры:
//  Объект       - СправочникОбъект, ...
//  ЭтоНовый     - Булево (Возвращаемое значение).
//
Функция СсылкаОбъекта(Знач Объект, ЭтоНовый = Неопределено) Экспорт
	
	Ссылка = Объект.Ссылка;
	ЭтоНовый = НЕ ЗначениеЗаполнено(Ссылка);
	
	Если ЭтоНовый Тогда
		Ссылка = Объект.ПолучитьСсылкуНового();
		
		Если НЕ ЗначениеЗаполнено(Ссылка) Тогда
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
			Ссылка = Менеджер.ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ссылка;
	
КонецФункции

// Только для внутреннего использования
Процедура УстановитьУсловиеОтбораВЗапросе(Знач Запрос, Знач Значения, Знач ИмяПараметраЗначений, Знач ИмяПараметраУсловияОтбораИмяПоля) Экспорт
	
	Если Значения = Неопределено Тогда
		
	ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
	        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
		
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
		
	ИначеЕсли Значения.Количество() = 1 Тогда
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения[0]);
	Иначе
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
	КонецЕсли;
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(ИмяПараметраУсловияОтбораИмяПоля) Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(ИмяПараметраУсловияОтбораИмяПоля, НомерСтроки);
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока) Тогда
			Продолжить;
		КонецЕсли;
		ИндексРазделителя = Найти(ТекущаяСтрока, ":");
		Если ИндексРазделителя = 0 Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении процедуры УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |В параметре ИмяПараметраУсловияОтбораИмяПоля не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".';
				           |en = 'Error occurred while executing procedure AccessManagement.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |In the parameter ИмяПараметраУсловияОтбораИмяПоля not found separator (colon) in the following format string ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".'"),
				ТекущаяСтрока);
		КонецЕсли;
		ИмяПараметраУсловияОтбора = Лев(ТекущаяСтрока, ИндексРазделителя-1);
		ИмяПоля = Сред(ТекущаяСтрока, ИндексРазделителя+1);
		Если Значения = Неопределено Тогда
			УсловиеОтбора = "Истина";
			
		ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
		        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
			
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
			
		ИначеЕсли Значения.Количество() = 1 Тогда
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
		Иначе
			УсловиеОтбора = ИмяПоля + " В (&" + ИмяПараметраЗначений + ")";
		КонецЕсли;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ИмяПараметраУсловияОтбора, УсловиеОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет набор записей в базе данных,
// если записи набора отличаются от записей в базе данных.
//
// Параметры:
//  НаборЗаписей          - НаборЗаписей пустой или прочитанный с заданным отбором или без отбора.
//                          Менеджер регистра для создания набора записей.
//
//  НовыеЗаписи           - ТаблицаЗначений в формате регистра.
//
//  ПоляСравнения         - Строка - содержит список полей по значениям которых требуется вычислять
//                          отличие записей набора. Например, "Измерение1, Измерение2, Ресурс1",
//                          а реквизит ДатаИзмерения не входит в список.
//
//  ПолеОтбора            - Неопределено - записывается весь регистр или
//                                         отбор уже задан в наборе записей.
//                          Строка       - имя поля по которому нужно установить отбор.
//
//  ЗначениеОтбора        - значение, которое будет установлено в качестве отбора по полю отбора,
//                          если поле отбора задано.
//
//  ИзмененныеЗаписи      - Неопределено - никаких действий, иначе
//                          возвращает таблицу значений в формате регистра с полем ВидИзмененияСтроки
//                          типа Число (-1 запись удалена, 1 запись добавлена).
//
//  ТранзакцияОткрыта     - Неопределено    - не открывать транзакцию.
//                          Истина          - транзакция уже открыта, её не требуется открывать.
//                          Другое значение - требуется открыть транзакцию и
//                                            установить ТранзакцияОткрыта в Истина.
//
//  НаборЗаписейПрочитан  - Булево, если Истина, тогда не заданный набор записей уже содержит
//                          прочитанные записи блокировка данных этих записей установлена и
//                          транзакция открыта.
//
//  ЕстьИзменения         - Булево (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
//  ТолькоПроверка        - Булево - если Истина, тогда не выполнять запись,
//                          а лишь выявить необходимость записи и установить
//                          свойство ЕстьИзменения.
//
// ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                          объекты <Регистр*>НаборЗаписей в свойство
//                          ДополнительныеСвойства будут вставлены все параметры структуры.
//
Процедура ОбновитьНаборЗаписей(Знач НаборЗаписей,
                               Знач НовыеЗаписи,
                               Знач ПоляСравнения          = Неопределено,
                               Знач ПолеОтбора             = Неопределено,
                               Знач ЗначениеОтбора         = Неопределено,
                               ЕстьИзменения               = Неопределено,
                               ИзмененныеЗаписи            = Неопределено,
                               ТранзакцияОткрыта           = Неопределено,
                               Знач НаборЗаписейПрочитан   = Ложь,
                               Знач БезПерезаписи          = Ложь,
                               Знач ТолькоПроверка         = Ложь,
                               Знач ДополнительныеСвойства = Неопределено) Экспорт
	
	ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	МенеджерРегистра = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяРегистра);
	Если НаборЗаписей = МенеджерРегистра Тогда
		НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолеОтбора) Тогда
		УстановитьОтбор(НаборЗаписей.Отбор[ПолеОтбора], ЗначениеОтбора);
	КонецЕсли;
	
	Если НЕ НаборЗаписейПрочитан Тогда
		ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра);
		НаборЗаписей.Прочитать();
	КонецЕсли;
	
	ПоляСравнения = ?(ПоляСравнения = Неопределено, ПоляНабораЗаписей(НаборЗаписей), ПоляСравнения);
	
	Если БезПерезаписи Тогда
		НаборЗаписи = МенеджерРегистра.СоздатьНаборЗаписей();
		ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(ПолноеИмяРегистра);
		ОтборЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
		ПоляОстальныхИзмерений = Новый Массив;
		Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
			Если Поле <> ПолеОтбора Тогда
				ПоляОстальныхИзмерений.Добавить(Поле);
			КонецЕсли;
		КонецЦикла;
		УдаляемыеЗаписи = Новый ТаблицаЗначений;
		Для каждого Поле Из ПоляОстальныхИзмерений Цикл
			УдаляемыеЗаписи.Колонки.Добавить(Поле);
		КонецЦикла;
		НовыеЗаписи = НовыеЗаписи.Скопировать();
	КонецЕсли;
	
	ЕстьТекущиеИзменения = Ложь;
	Если ИзмененныеЗаписи = Неопределено Тогда
		Если НаборЗаписей.Количество() = НовыеЗаписи.Количество() ИЛИ БезПерезаписи Тогда
			Отбор = Новый Структура(ПоляСравнения);
			НовыеЗаписи.Индексы.Добавить(ПоляСравнения);
			Для каждого Запись Из НаборЗаписей Цикл
				ЗаполнитьЗначенияСвойств(Отбор, Запись);
				НайденныеСтроки = НовыеЗаписи.НайтиСтроки(Отбор);
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЕстьТекущиеИзменения = Истина;
					ЕстьИзменения = Истина;
					Если БезПерезаписи Тогда
						ЗаполнитьЗначенияСвойств(ОтборЗаписи, Запись);
						Если НовыеЗаписи.НайтиСтроки(ОтборЗаписи).Количество() = 0 Тогда
							ЗаполнитьЗначенияСвойств(УдаляемыеЗаписи.Добавить(), ОтборЗаписи);
						КонецЕсли;
					Иначе
						Прервать;
					КонецЕсли;
				ИначеЕсли БезПерезаписи Тогда
					НовыеЗаписи.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			КонецЦикла;
			Если БезПерезаписи И НовыеЗаписи.Количество() > 0 Тогда
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			КонецЕсли;
		Иначе
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
	Иначе
		Если НаборЗаписей.Количество() <> НовыеЗаписи.Количество() Тогда
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
		Если НаборЗаписей.Количество() > НовыеЗаписи.Количество() Тогда
			ИзмененныеЗаписи = НаборЗаписей.Выгрузить();
			ИскомыеЗаписи   = НовыеЗаписи;
			ВидИзмененияСтроки = -1;
		Иначе
			ИзмененныеЗаписи = НовыеЗаписи.Скопировать();
			ИскомыеЗаписи   = НаборЗаписей.Выгрузить();
			ВидИзмененияСтроки = 1;
		КонецЕсли;
		ИзмененныеЗаписи.Колонки.Добавить("ВидИзмененияСтроки", Новый ОписаниеТипов("Число"));
		ИзмененныеЗаписи.ЗаполнитьЗначения(ВидИзмененияСтроки, "ВидИзмененияСтроки");
		ВидИзмененияСтроки = ?(ВидИзмененияСтроки = 1, -1, 1);
		Отбор = Новый Структура(ПоляСравнения);
		
		Для каждого Строка Из ИскомыеЗаписи Цикл
			ЗаполнитьЗначенияСвойств(Отбор, Строка);
			Строки = ИзмененныеЗаписи.НайтиСтроки(Отбор);
			Если Строки.Количество() = 0 Тогда
				НоваяСтрока = ИзмененныеЗаписи.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Отбор);
				НоваяСтрока.ВидИзмененияСтроки = ВидИзмененияСтроки;
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			Иначе
				ИзмененныеЗаписи.Удалить(Строки[0]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьТекущиеИзменения Тогда
		Если ТолькоПроверка Тогда
			Возврат;
		КонецЕсли;
		Если ТранзакцияОткрыта <> Неопределено // Требуется использовать внешнюю транзакцию
		   И ТранзакцияОткрыта <> Истина Тогда // Внешняя транзакция ещё не открыта
			// Открытие внешней транзакции
			НачатьТранзакцию();
			ТранзакцияОткрыта = Истина;
		КонецЕсли;
		Если БезПерезаписи Тогда
			УстановитьДополнительныеСвойства(НаборЗаписи, ДополнительныеСвойства);
			Для каждого Строка Из УдаляемыеЗаписи Цикл
				Если ЗначениеЗаполнено(ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[ПолеОтбора], ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				НаборЗаписи.Записать();
			КонецЦикла;
			НаборЗаписи.Добавить();
			Для каждого Строка Из НовыеЗаписи Цикл
				Если ЗначениеЗаполнено(ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[ПолеОтбора], ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаполнитьЗначенияСвойств(НаборЗаписи[0], Строка);
				НаборЗаписи.Записать();
			КонецЦикла;
		Иначе
			УстановитьДополнительныеСвойства(НаборЗаписей, ДополнительныеСвойства);
			НаборЗаписей.Загрузить(НовыеЗаписи);
			НаборЗаписей.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет строки регистра с отбором по нескольким значениям для одного или
// для двух измерений регистра, выполняется проверка наличия изменений,
// если изменений нет, перезапись не производится.
//
// Параметры:
//  МенеджерРегистра          - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  НовыеЗаписи               - ТаблицаЗначений в формате регистра.
//
//  ПоляСравнения             - Строка - содержит список полей по значениям которых требуется
//                              вычислять отличие записей набора, например, "Измерение1, Измерение2,
//                              Ресурс1", а реквизит ДатаИзменения не входит в список.
//
//  ИмяПервогоИзмерения       - Неопределено - нет отбора по измерению.
//                              Строка       - содержит имя первого измерения, для которого задано
//                                             несколько значений.
//
//  ЗначенияПервогоИзмерения  - Неопределено - нет отбора по измерению, аналогично,
//                                             ИмяПервогоИзмерения = Неопределено.
//                              ЛюбаяСсылка  - содержит одно значение отбора регистра для
//                                             обновляемых записей.
//                              Массив       - содержит массив значений отбора регистра для
//                                             обновляемых записей, пустой массив - значит
//                                             действий не требуется.
//
//  ИмяВторогоИзмерения       - аналогично ИмяПервогоИзмерения.
//  ЗначенияВторогоИзмерения  - аналогично ЗначенияПервогоИзмерения.
//  ИмяТретьегоИзмерения      - аналогично ИмяПервогоИзмерения.
//  ЗначенияТретьегоИзмерения - аналогично ЗначенияПервогоИзмерения.
//
//  ЕстьИзменения             - Булево (возвращаемое значение) - если производилась запись,
//                              устанавливается Истина, иначе не изменяется.
//
//  ТолькоПроверка            - Булево - если Истина, тогда не выполнять запись,
//                              а лишь выявить необходимость записи и установить
//                              свойство ЕстьИзменения.
//
// ДополнительныеСвойства     - Неопределено, Структура. Если Структура, тогда в
//                              объекты <Регистр*>НаборЗаписей в свойство
//                              ДополнительныеСвойства будут вставлены все параметры структуры.
//
Процедура ОбновитьНаборыЗаписей(Знач МенеджерРегистра,
                                Знач НовыеЗаписи,
                                Знач ПоляСравнения                     = Неопределено,
                                Знач ИмяПервогоИзмерения               = Неопределено,
                                Знач ЗначенияПервогоИзмерения          = Неопределено,
                                Знач ИмяВторогоИзмерения               = Неопределено,
                                Знач ЗначенияВторогоИзмерения          = Неопределено,
                                Знач ИмяТретьегоИзмерения              = Неопределено,
                                Знач ЗначенияТретьегоИзмерения         = Неопределено,
                                Знач НовыеЗаписиСодержатТолькоРазличия = Ложь,
                                Знач ФиксированныйОтбор                = Неопределено,
                                ЕстьИзменения                          = Неопределено,
                                Знач ТолькоПроверка                    = Ложь,
                                Знач ДополнительныеСвойства            = Неопределено) Экспорт
	
	// Предварительная обработка параметров.
	
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяПервогоИзмерения, ЗначенияПервогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяВторогоИзмерения, ЗначенияВторогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяТретьегоИзмерения, ЗначенияТретьегоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	
	УпорядочитьГруппыПараметровИзмерений(
		ИмяПервогоИзмерения,
		ЗначенияПервогоИзмерения,
		ИмяВторогоИзмерения,
		ЗначенияВторогоИзмерения,
		ИмяТретьегоИзмерения,
		ЗначенияТретьегоИзмерения);
	
	// Проверка и обновление данных.
	Параметры = Новый Структура;
	Параметры.Вставить("НовыеЗаписи",        НовыеЗаписи);
	Параметры.Вставить("ПоляСравнения",      ПоляСравнения);
	Параметры.Вставить("ФиксированныйОтбор", ФиксированныйОтбор);
	Параметры.Вставить("ТранзакцияОткрыта",  ?(ТранзакцияАктивна(), Неопределено, Ложь));
	Параметры.Вставить("НаборЗаписей",       МенеджерРегистра.СоздатьНаборЗаписей());
	Параметры.Вставить("МетаданныеРегистра", Метаданные.НайтиПоТипу(ТипЗнч(Параметры.НаборЗаписей)));
	Параметры.Вставить("ПолноеИмяРегистра",  Параметры.МетаданныеРегистра.ПолноеИмя());
	
	Если НовыеЗаписиСодержатТолькоРазличия Тогда
		Параметры.Вставить("НаборДляОднойЗаписи",  МенеджерРегистра.СоздатьНаборЗаписей());
	КонецЕсли;
	
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УстановитьОтбор(Параметры.НаборЗаписей.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Попытка
		Если НовыеЗаписиСодержатТолькоРазличия Тогда
			
			Если ИмяПервогоИзмерения = Неопределено Тогда
				ВызватьИсключение
					НСтр("ru = 'Некорректные параметры в процедуре ОбновитьНаборыЗаписей.'; en = 'Incorrect parameters in the procedure ОбновитьНаборыЗаписей.'");
			Иначе
				Если ИмяВторогоИзмерения = Неопределено Тогда
					ЗаписьНесколькимиНаборами = Ложь;
				Иначе
					ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
						Параметры, Новый Структура, ИмяПервогоИзмерения, ЗначенияПервогоИзмерения);
				КонецЕсли;
				
				Если ЗаписьНесколькимиНаборами Тогда
					СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения;
					НовыеЗаписи.Индексы.Добавить(СписокПолей);
					
					КоличествоПоЗначениямПервогоИзмерения = Параметры.КоличествоПоЗначениям;
					
					Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
						Отбор = Новый Структура(ИмяПервогоИзмерения, ПервоеЗначение);
						УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
						
						Если ИмяТретьегоИзмерения = Неопределено Тогда
							ЗаписьНесколькимиНаборами = Ложь;
						Иначе
							ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
								Параметры, Отбор, ИмяВторогоИзмерения, ЗначенияВторогоИзмерения);
						КонецЕсли;
						
						Если ЗаписьНесколькимиНаборами Тогда
							Для каждого ВтороеЗначение Из ЗначенияВторогоИзмерения Цикл
								Отбор.Вставить(ИмяВторогоИзмерения, ВтороеЗначение);
								УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения], ВтороеЗначение);
								
								// Обновление по трем измерениям.
								ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(
									Параметры, Отбор, ЕстьИзменения, ТолькоПроверка, ДополнительныеСвойства);
							КонецЦикла;
							Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения].Использование = Ложь;
						Иначе
							// Обновление по двум измерениям.
							Параметры.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениямПервогоИзмерения);
							ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(
								Параметры, Отбор, ЕстьИзменения, ТолькоПроверка, ДополнительныеСвойства);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Обновление по одному измерению.
					ПрочитатьКоличествоДляЧтения(Параметры);
					ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(
						Параметры, Новый Структура, ЕстьИзменения, ТолькоПроверка, ДополнительныеСвойства);
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если ИмяПервогоИзмерения = Неопределено Тогда
				// Обновление всех записей.
				ОбновитьНаборЗаписей(
					Параметры.НаборЗаписей,
					НовыеЗаписи,
					ПоляСравнения,
					,
					,
					ЕстьИзменения,
					,
					Параметры.ТранзакцияОткрыта,
					,
					,
					ТолькоПроверка,
					ДополнительныеСвойства);
				
			ИначеЕсли ИмяВторогоИзмерения = Неопределено Тогда
				// Обновление по одному измерению.
				Отбор = Новый Структура(ИмяПервогоИзмерения);
				Для каждого Значение Из ЗначенияПервогоИзмерения Цикл
					
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], Значение);
					Отбор[ИмяПервогоИзмерения] = Значение;
					
					Если ЗначенияПервогоИзмерения.Количество() = 1 Тогда
						НовыеЗаписиНабора = НовыеЗаписи;
					Иначе
						НовыеЗаписиНабора = НовыеЗаписи.Скопировать(Отбор);
					КонецЕсли;
					
					ОбновитьНаборЗаписей(
						Параметры.НаборЗаписей,
						НовыеЗаписиНабора,
						ПоляСравнения,
						,
						,
						ЕстьИзменения,
						,
						Параметры.ТранзакцияОткрыта,
						,
						,
						ТолькоПроверка,
						ДополнительныеСвойства);
				КонецЦикла;
				
			ИначеЕсли ИмяТретьегоИзмерения = Неопределено Тогда
				// Обновление по двум измерениям.
				СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения;
				НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[ИмяПервогоИзмерения] = ПервоеЗначение;
					
					ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
						Параметры,
						Отбор,
						СписокПолей,
						ИмяВторогоИзмерения,
						ЗначенияВторогоИзмерения,
						ЕстьИзменения,
						ТолькоПроверка,
						ДополнительныеСвойства);
				КонецЦикла;
			Иначе
				// Обновление по трем измерениям.
				СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения + ", " + ИмяТретьегоИзмерения;
				НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[ИмяПервогоИзмерения] = ПервоеЗначение;
					
					Для каждого ВтороеЗначение Из ЗначенияВторогоИзмерения Цикл
						УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения], ВтороеЗначение);
						Отбор[ИмяВторогоИзмерения] = ВтороеЗначение;
						
						ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
							Параметры,
							Отбор,
							СписокПолей,
							ИмяВторогоИзмерения,
							ЗначенияВторогоИзмерения,
							ЕстьИзменения,
							ТолькоПроверка,
							ДополнительныеСвойства);
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если Параметры.ТранзакцияОткрыта = Истина Тогда
			ЗафиксироватьТранзакцию();
		КонецЕсли;
	Исключение
		Если Параметры.ТранзакцияОткрыта = Истина Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет строки регистра сведений по данным в таблице значений РазличныеСтроки.
//
// Параметры:
//  МенеджерРегистра      - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  РазличныеСтроки       - ТаблицаЗначений, содержащей поля регистра и
//                          поле ВидИзмененияСтроки (Число):
//                             1 - значит, что строку нужно добавить,
//                            -1 - значит, что строку нужно удалить.
//
//  ЕстьИзменения         - Булево (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
//  ФиксированныйОтбор    - Структура, содержащая имя измерения в ключе и значение
//                          отбора в значении. Может быть указана, когда измерений
//                          более 3-х и заранее известно, что по измерениям сверх 3-х
//                          будет единственное значение. Измерения указанные в
//                          фиксированном отборе не используются при формировании
//                          наборов записей для выполнения обновления.
//
//  ИзмеренияОтбора       - Строка измерений перечисленных через запятую, которые
//                          нужно использовать при формировании наборов записей
//                          для выполнения обновления (не более 3-х). Не указанные
//                          измерения будут превращены в фиксированный отбор,
//                          если по ним все значения совпадают.
//
//  ТолькоПроверка        - Булево - если Истина, тогда не выполнять запись,
//                          а лишь выявить необходимость записи и установить
//                          свойство ЕстьИзменения.
//
// ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                          объекты <Регистр*>НаборЗаписей в свойство
//                          ДополнительныеСвойства будут вставлены все параметры структуры.
//
Процедура ОбновитьРегистрСведений(Знач МенеджерРегистра,
                                  Знач ОбновляемыеСтроки,
                                  ЕстьИзменения               = Неопределено,
                                  Знач ФиксированныйОтбор     = Неопределено,
                                  Знач ИзмеренияОтбора        = Неопределено,
                                  Знач ТолькоПроверка         = Ложь,
                                  Знач ДополнительныеСвойства = Неопределено) Экспорт
	
	Если ОбновляемыеСтроки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗнч(МенеджерРегистра.ПустойКлюч()));
	
	Если ФиксированныйОтбор = Неопределено Тогда
		ФиксированныйОтбор = Новый Структура;
	КонецЕсли;
	
	ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(
		МетаданныеРегистра.ПолноеИмя());
	
	Если ИзмеренияОтбора = Неопределено Тогда
		ОтборКлючаЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
	Иначе
		ИзмеренияОтбора = Новый Структура(ИзмеренияОтбора);
	КонецЕсли;
	
	МассивИзмеренийОтбора   = Новый Массив;
	ЗначенияИзмеренийОтбора = Новый Структура;
	
	Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
		Если НЕ ФиксированныйОтбор.Свойство(Поле) Тогда
			Значения = ЗначенияКолонкиТаблицы(ОбновляемыеСтроки, Поле);
			
			Если ИзмеренияОтбора = Неопределено
			 ИЛИ ИзмеренияОтбора.Свойство(Поле) Тогда
				
				МассивИзмеренийОтбора.Добавить(Поле);
				ЗначенияИзмеренийОтбора.Вставить(Поле, Значения);
				
			ИначеЕсли Значения.Количество() = 1 Тогда
				ФиксированныйОтбор.Вставить(Поле, Значения[0]);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ИмяПервогоИзмерения      = МассивИзмеренийОтбора[0];
	ЗначенияПервогоИзмерения = ЗначенияИзмеренийОтбора[ИмяПервогоИзмерения];
	
	Если МассивИзмеренийОтбора.Количество() > 1 Тогда
		ИмяВторогоИзмерения      = МассивИзмеренийОтбора[1];
		ЗначенияВторогоИзмерения = ЗначенияИзмеренийОтбора[ИмяВторогоИзмерения];
	Иначе
		ИмяВторогоИзмерения      = Неопределено;
		ЗначенияВторогоИзмерения = Неопределено;
	КонецЕсли;
	
	Если МассивИзмеренийОтбора.Количество() > 2 Тогда
		ИмяТретьегоИзмерения      = МассивИзмеренийОтбора[2];
		ЗначенияТретьегоИзмерения = ЗначенияИзмеренийОтбора[ИмяТретьегоИзмерения];
	Иначе
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	ОбновитьНаборыЗаписей(
		МенеджерРегистра,
		ОбновляемыеСтроки,
		ОписаниеКлючаЗаписи.СтрокаПолей,
		ИмяПервогоИзмерения,
		ЗначенияПервогоИзмерения,
		ИмяВторогоИзмерения,
		ЗначенияВторогоИзмерения,
		ИмяТретьегоИзмерения,
		ЗначенияТретьегоИзмерения,
		Истина,
		ФиксированныйОтбор,
		ЕстьИзменения,
		ТолькоПроверка,
		ДополнительныеСвойства);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Создает запрос выбора различий между строками регистра в заданной области данных
// (на основе отборов в параметре ПоляИОтбор).
//
// Параметры:
//  ТекстЗапросаВыбораНовых - Строка.
//
//  ПоляИОтбор   - Массив элементов типа Структура("ИмяПоля", ИмяПараметраУсловияОтбора).
//
//  ПолноеИмяРегистра
//               - Строка       - запрос старых формируется автоматически.
//                 Неопределено - запрос старых берется из следующего параметра.
//
//  ТекстЗапросаВыбораСтарых
//               - Строка       - запрос старых, с учетом нестандартных отборов.
//               - Неопределено - когда полное имя регистра определено.
//
// Возвращаемое значение:
//  Строка - текст запрос с учетом оптимизации для СУБД PostgreSQL.
//
Функция ТекстЗапросаВыбораИзменений(ТекстЗапросаВыбораНовых,
                                    ПоляИОтбор,
                                    ПолноеИмяРегистра            = Неопределено,
                                    ТекстЗапросовВременныхТаблиц = Неопределено,
                                    ТекстЗапросаВыбораСтарых     = Неопределено) Экспорт
	
	// Подготовка текста запроса старых данных.
	Если ПолноеИмяРегистра <> Неопределено Тогда
		ТекстЗапросаВыбораСтарых =
		"ВЫБРАТЬ
		|	&ВыбираемыеПоля,
		|	&ПодстановкаПоляВидИзмененияСтроки
		|ИЗ
		|	ПолноеИмяРегистра КАК СтарыеДанные
		|ГДЕ
		|	&УсловияОтбора";
	КонецЕсли;
	
	ВыбираемыеПоля = "";
	УсловияОтбора = "Истина";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	СтарыеДанные.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
			
		// Сборка условий отбора.
		Если ЗначениеЗаполнено(КлючИЗначение(ОписаниеПоля).Значение) Тогда
			УсловияОтбора = УсловияОтбора + СтрЗаменить(
				"
				|	И &ИмяПараметраУсловияОтбора", "&ИмяПараметраУсловияОтбора",
				КлючИЗначение(ОписаниеПоля).Значение);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&УсловияОтбора",    УсловияОтбора);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "ПолноеИмяРегистра", ПолноеИмяРегистра);
	
	Если Найти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораСтарых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораСтарых = СтрЗаменить(
		ТекстЗапросаВыбораСтарых, "&ПодстановкаПоляВидИзмененияСтроки", "-1 КАК ВидИзмененияСтроки");
	
	Если Найти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораНовых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораНовых = СтрЗаменить(
		ТекстЗапросаВыбораНовых,  "&ПодстановкаПоляВидИзмененияСтроки", "1 КАК ВидИзмененияСтроки");
	
	// Подготовка текста запроса выбора изменений.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&ВыбираемыеПоля,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ТекстЗапросаВыбораНовых
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ТекстЗапросаВыбораСтарых) КАК ВсеСтроки
	|	
	|СГРУППИРОВАТЬ ПО
	|	&ПоляГруппировки
	|	
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0";
	
	ВыбираемыеПоля = "";
	ПоляГруппировки = "";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
		
		// Сборка полей соединения.
		ПоляГруппировки = ПоляГруппировки + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
	КонецЦикла;
	ПоляГруппировки = Лев(ПоляГруппировки, СтрДлина(ПоляГруппировки)-1);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляГруппировки", ПоляГруппировки);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораНовых",  ТекстЗапросаВыбораНовых);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораСтарых", ТекстЗапросаВыбораСтарых);
	
	Если ЗначениеЗаполнено(ТекстЗапросовВременныхТаблиц) Тогда
		ТекстЗапроса = ТекстЗапросовВременныхТаблиц +
		"
		|;
		|" + ТекстЗапроса;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы

// Возвращает менеджер временных таблиц, содержащий временную таблицу пользователей
// некоторых дополнительных групп пользователей, например, пользователей групп
// исполнителей задач, которые соответствуют ключам адресации
// (РольИсполнителя + ОсновнойОбъектАдресации + ДополнительныйОбъектАдресации).
//
//  При изменении состава дополнительных групп пользователей, необходимо вызвать
// процедуру ОбновитьПользователейГруппИсполнителей в модуле УправлениеДоступом,
// чтобы применить изменения к внутренним данным подсистемы.
//
// Параметры:
//  МенеджерВременныхТаблиц - МенеджерВременныхТаблиц, в который можно поместить таблицу:
//                            ТаблицаГруппИсполнителей с полями:
//                              ГруппаИсполнителей - Например,
//                                                   СправочникСсылка.ГруппыИсполнителейЗадач.
//                              Пользователь       - СправочникСсылка.Пользователи,
//                                                   СправочникСсылка.ВнешниеПользователи.
//
//  СодержаниеПараметра     - Неопределено - параметр не указан, вернуть все данные.
//                            Строка, когда
//                              "ГруппыИсполнителей" требуется вернуть
//                               только составы указанных групп исполнителей.
//                              "Исполнители" требуется вернуть
//                               только составы групп исполнителей, которые
//                               в которые входят указанные исполнители.
//
//  ЗначениеПараметра       - Неопределено, когда СодержаниеПараметра = Неопределено,
//                          - Например, СправочникСсылка.ГруппыИсполнителейЗадач,
//                            когда СодеражаниеПараметра = "ГруппыИсполнителей".
//                          - СправочникСсылка.Пользователи,
//                            СправочникСсылка.ВнешниеПользователи,
//                            когда СодеражаниеПараметра = "Исполнители".
//                            Массив указанных выше типов.
//
//  НетГруппИсполнителей    - Булево, если Ложь, МенеджерВременныхТаблиц содержит временную таблицу, иначе нет.
//
Процедура ПриОпределенииГруппИсполнителей(МенеджерВременныхТаблиц, СодержаниеПараметра, ЗначениеПараметра, НетГруппИсполнителей) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.БизнесПроцессыИЗадачи") Тогда
		МодульБизнесПроцессыИЗадачиСервер = ОбщегоНазначения.ОбщийМодуль("БизнесПроцессыИЗадачиСервер");
		МодульБизнесПроцессыИЗадачиСервер.ПриОпределенииГруппИсполнителей(МенеджерВременныхТаблиц, СодержаниеПараметра, ЗначениеПараметра);
		НетГруппИсполнителей = Ложь;
	Иначе
		НетГруппИсполнителей = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает использование регламентного задания заполнения данных управления доступом.
//
// Параметры:
// Использование - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура ПриВключенииЗаполненияДанныхДляОграниченияДоступа(Знач Использование)
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.УправлениеДоступомВМоделиСервиса") Тогда
		МодульУправлениеДоступомСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступомСлужебныйВМоделиСервиса");
		МодульУправлениеДоступомСлужебныйВМоделиСервиса.ВключитьЗаполнениеДанныхДляОграниченияДоступа(Использование);
	КонецЕсли;
	
КонецПроцедуры

// Создает / обновляет запись запись пользователя сервиса.
// 
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи/СправочникОбъект.Пользователи
//  СоздатьПользователяСервиса - Булево - Истина - создать нового пользователя
//   сервиса, Ложь - обновить существующего.
//  ПарольПользователяСервиса - Строка - пароль текущего пользователя
//   для доступа к менеджеру сервиса
//
Процедура ПриЗаписиПользователяСервиса(Знач Пользователь, Знач СоздатьПользователяСервиса, Знач ПарольПользователяСервиса) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПользователиВМоделиСервиса") Тогда
		МодульПользователиСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("ПользователиСлужебныйВМоделиСервиса");
		МодульПользователиСлужебныйВМоделиСервиса.ЗаписатьПользователяСервиса(Пользователь, СоздатьПользователяСервиса, ПарольПользователяСервиса);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает доступные текущему пользователю действия с указанным пользователем сервиса.
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь, доступные
//   действия с которым требуется получить. Если параметр не указан, проверяются
//   доступные действия с текущим пользователем.
//  ПарольПользователяСервиса - Строка - пароль текущего пользователя для
//   доступа в сервис.
//  
Процедура ПриПолученииДействийСПользователемСервиса(ДоступныеДействия, Знач Пользователь = Неопределено) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПользователиВМоделиСервиса") Тогда
		МодульПользователиСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("ПользователиСлужебныйВМоделиСервиса");
		ДоступныеДействия = МодульПользователиСлужебныйВМоделиСервиса.ПолучитьДействияСПользователемСервиса(Пользователь);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

Процедура ПриИзмененииНаборовЗначенийДоступа(Знач СсылкаНаОбъект)
	
	СсылкиНаЗависимыеОбъекты = Новый Массив;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.УправлениеДоступом\ПриИзмененииНаборовЗначенийДоступа");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	КонецЦикла;
	
	УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(
		СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	
	Для каждого СсылкаНаЗависимыйОбъект Из СсылкиНаЗависимыеОбъекты Цикл
		
		Если СсылкаНаЗависимыйОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			// Изменение объекта не требуется.
			ЗаписатьНаборыЗначенийДоступа(СсылкаНаЗависимыйОбъект);
		Иначе
			// Изменение объекта требуется.
			Объект = СсылкаНаЗависимыйОбъект.ПолучитьОбъект();
			Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
			Если НЕ НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаЗависимыйОбъект, Таблица) Тогда
				Продолжить;
			КонецЕсли;
			Попытка
				ЗаблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект, Объект.ВерсияДанных);
				Объект.ОбменДанными.Загрузка = Истина;
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
				Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
				Объект.Записать();
				РазблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект);
			Исключение
				КраткоеПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2';
					           |en = 'When upgrading from a set of values of the dependent object
					           |""%1"" an error occurred:
					           |
					           |%2'"),
					Строка(СсылкаНаЗависимыйОбъект),
					КраткоеПредставлениеОшибки);
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция НаборыЗначенийДоступаРегистраИзменены(СсылкаНаОбъект, НаборЗаписей)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
	Запрос.УстановитьПараметр("НовыеНаборы",    НаборЗаписей.Выгрузить());
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НовыеНаборы.Объект,
	|	НовыеНаборы.НомерНабора,
	|	НовыеНаборы.ВидДоступа,
	|	НовыеНаборы.ЗначениеДоступа,
	|	НовыеНаборы.Чтение,
	|	НовыеНаборы.Добавление,
	|	НовыеНаборы.Изменение,
	|	НовыеНаборы.Удаление,
	|	НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа,
	|	НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
	|	НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа,
	|	НовыеНаборы.ВидДоступаПравоЧтения,
	|	НовыеНаборы.ВидДоступаПравоДобавления,
	|	НовыеНаборы.ВидДоступаПравоИзменения,
	|	НовыеНаборы.ТипОбъекта,
	|	НовыеНаборы.ТипЗначенияДоступа
	|ПОМЕСТИТЬ НовыеНаборы
	|ИЗ
	|	&НовыеНаборы КАК НовыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовыеНаборы КАК НовыеНаборы
	|		ПО НаборыЗначенийДоступа.Объект = НовыеНаборы.Объект
	|			И НаборыЗначенийДоступа.НомерНабора = НовыеНаборы.НомерНабора
	|			И НаборыЗначенийДоступа.ВидДоступа = НовыеНаборы.ВидДоступа
	|			И НаборыЗначенийДоступа.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа
	|			И НаборыЗначенийДоступа.Чтение = НовыеНаборы.Чтение
	|			И НаборыЗначенийДоступа.Добавление = НовыеНаборы.Добавление
	|			И НаборыЗначенийДоступа.Изменение = НовыеНаборы.Изменение
	|			И НаборыЗначенийДоступа.Удаление = НовыеНаборы.Удаление
	|			И НаборыЗначенийДоступа.ВидДоступаБезГруппЗначенияДоступа = НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа = НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа = НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаПравоЧтения = НовыеНаборы.ВидДоступаПравоЧтения
	|			И НаборыЗначенийДоступа.ВидДоступаПравоДобавления = НовыеНаборы.ВидДоступаПравоДобавления
	|			И НаборыЗначенийДоступа.ВидДоступаПравоИзменения = НовыеНаборы.ВидДоступаПравоИзменения
	|			И НаборыЗначенийДоступа.ТипОбъекта = НовыеНаборы.ТипОбъекта
	|			И НаборыЗначенийДоступа.ТипЗначенияДоступа = НовыеНаборы.ТипЗначенияДоступа
	|ГДЕ
	|	НаборыЗначенийДоступа.Объект = &СсылкаНаОбъект
	|	И НовыеНаборы.Объект ЕСТЬ NULL 
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	НовыеНаборы КАК НовыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
	|		ПО (НаборыЗначенийДоступа.Объект = НовыеНаборы.Объект)
	|			И (НаборыЗначенийДоступа.НомерНабора = НовыеНаборы.НомерНабора)
	|			И (НаборыЗначенийДоступа.ВидДоступа = НовыеНаборы.ВидДоступа)
	|			И (НаборыЗначенийДоступа.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа)
	|			И (НаборыЗначенийДоступа.Чтение = НовыеНаборы.Чтение)
	|			И (НаборыЗначенийДоступа.Добавление = НовыеНаборы.Добавление)
	|			И (НаборыЗначенийДоступа.Изменение = НовыеНаборы.Изменение)
	|			И (НаборыЗначенийДоступа.Удаление = НовыеНаборы.Удаление)
	|			И (НаборыЗначенийДоступа.ВидДоступаБезГруппЗначенияДоступа = НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа = НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа = НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоЧтения = НовыеНаборы.ВидДоступаПравоЧтения)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоДобавления = НовыеНаборы.ВидДоступаПравоДобавления)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоИзменения = НовыеНаборы.ВидДоступаПравоИзменения)
	|			И (НаборыЗначенийДоступа.ТипОбъекта = НовыеНаборы.ТипОбъекта)
	|			И (НаборыЗначенийДоступа.ТипЗначенияДоступа = НовыеНаборы.ТипЗначенияДоступа)
	|ГДЕ
	|	НаборыЗначенийДоступа.Объект ЕСТЬ NULL ";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Для процедур ВключитьПользователяВГруппуДоступа, ИсключитьПользователяИзГруппыДоступа
// и функции НайтиПользователяВГруппеДоступа.

Функция ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Включить = Неопределено)
	
	Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.РабочиеГруппы")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ИдентификаторПоставляемогоПрофиля = Неопределено;
	
	Если ТипЗнч(ПоставляемыйПрофиль) = Тип("Строка") Тогда
		Если СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ПоставляемыйПрофиль) Тогда
			
			ИдентификаторПоставляемогоПрофиля = ПоставляемыйПрофиль;
			
			ПоставляемыйПрофиль = Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(
				ИдентификаторПоставляемогоПрофиля);
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ПоставляемыйПрофиль) <> Тип("СправочникСсылка.ПрофилиГруппДоступа") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Неопределено Тогда
		ИдентификаторПоставляемогоПрофиля =
			Справочники.ПрофилиГруппДоступа.ИдентификаторПоставляемогоПрофиля(ПоставляемыйПрофиль);
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Справочники.ПрофилиГруппДоступа.ИдентификаторПрофиляАдминистратор() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваПрофиля = УправлениеДоступомСлужебныйПовтИсп.Параметры(
		).ПоставляемыеПрофилиГруппДоступа.ОписанияПрофилей.Получить(ИдентификаторПоставляемогоПрофиля);
	
	Если СвойстваПрофиля = Неопределено
	 ИЛИ СвойстваПрофиля.ВидыДоступа.Количество() <> 0 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ГруппаДоступа = Неопределено;
	
	Если УправлениеДоступомПереопределяемый.УпрощенныйИнтерфейсНастройкиПравДоступа() Тогда
		
		Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
		   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи") Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Профиль", ПоставляемыйПрофиль);
		Запрос.УстановитьПараметр("Пользователь", Пользователь);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &Профиль
		|	И ГруппыДоступа.Пользователь = &Пользователь";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка;
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль      = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователь = Пользователь;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ПоставляемыйПрофиль", ПоставляемыйПрофиль);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка,
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &ПоставляемыйПрофиль
		|
		|УПОРЯДОЧИТЬ ПО
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля УБЫВ";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка;
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", ГруппаДоступа);
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппы
	|ГДЕ
	|	УчастникиГруппы.Ссылка = &Ссылка
	|	И УчастникиГруппы.Пользователь = &Пользователь";
	ПользовательНайден = НЕ Запрос.Выполнить().Пустой();
	
	Если Включить = Неопределено Тогда
		Возврат ПользовательНайден;
	КонецЕсли;
	
	Если Включить И ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ Включить И НЕ ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	ГруппаДоступа = ГруппаДоступа.ПолучитьОбъект();
	
	Если НЕ УправлениеДоступомПереопределяемый.УпрощенныйИнтерфейсНастройкиПравДоступа()
	   И НЕ ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля Тогда
		
		ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
	КонецЕсли;
	
	Если Включить Тогда
		ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
	Иначе
		Отбор = Новый Структура("Пользователь", Пользователь);
		Строки = ГруппаДоступа.Пользователи.НайтиСтроки(Отбор);
		Для каждого Строка Из Строки Цикл
			ГруппаДоступа.Пользователи.Удалить(Строка);
		КонецЦикла;
	КонецЕсли;
	
	ГруппаДоступа.Записать();
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ОбновитьРолиПользователей.

Функция ТекущиеСвойстваПользователей(МассивПользователей) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
	
	Если МассивПользователей = Неопределено Тогда
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|ГДЕ
		|	Пользователи.Служебный = ЛОЖЬ
		|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор
		// ТСК Близнюк С.И.; 12.09.2018; task#465{
		|
		|ОБЪЕДИНИТЬ
		|
		|ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ра_ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|ГДЕ
		|	Пользователи.Служебный = ЛОЖЬ
		|	И Пользователи.ра_ИдентификаторПользователяИБ <> &ПустойИдентификатор
		// ТСК Близнюк С.И.; 12.09.2018; task#465}
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|ГДЕ
		|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		
	ИначеЕсли ТипЗнч(МассивПользователей) = Тип("Тип") Тогда
		Если Метаданные.НайтиПоТипу(МассивПользователей) = Метаданные.Справочники.ВнешниеПользователи Тогда
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ВнешниеПользователи.Ссылка КАК Пользователь,
			|	ВнешниеПользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
			|ГДЕ
			|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		Иначе
			Запрос.Текст =
			"ВЫБРАТЬ
			|	Пользователи.Ссылка КАК Пользователь,
			|	Пользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.Пользователи КАК Пользователи
			|ГДЕ
			|	Пользователи.Служебный = ЛОЖЬ
			|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор
			// ТСК Близнюк С.И.; 12.09.2018; task#465{
			|
			|ОБЪЕДИНИТЬ
			|
			|ВЫБРАТЬ
			|	Пользователи.Ссылка КАК Пользователь,
			|	Пользователи.ра_ИдентификаторПользователяИБ
			|ИЗ
			|	Справочник.Пользователи КАК Пользователи
			|ГДЕ
			|	Пользователи.Служебный = ЛОЖЬ
			|	И Пользователи.ра_ИдентификаторПользователяИБ <> &ПустойИдентификатор";
			// ТСК Близнюк С.И.; 12.09.2018; task#465}
		КонецЕсли;
	Иначе
		ИсходныеПользователи = Новый ТаблицаЗначений;
		ИсходныеПользователи.Колонки.Добавить("Пользователь", Новый ОписаниеТипов(
			"СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи"));
		
		Для каждого Пользователь Из МассивПользователей Цикл
			ИсходныеПользователи.Добавить().Пользователь = Пользователь;
		КонецЦикла;
		
		Запрос.УстановитьПараметр("ИсходныеПользователи", ИсходныеПользователи);
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ИсходныеПользователи.Пользователь
		|ПОМЕСТИТЬ ИсходныеПользователи
		|ИЗ
		|	&ИсходныеПользователи КАК ИсходныеПользователи
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО Пользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (Пользователи.Служебный = ЛОЖЬ)
		|			И (Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)
		// ТСК Близнюк С.И.; 12.09.2018; task#465{
		|
		|ОБЪЕДИНИТЬ
		|
		|ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ра_ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО Пользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (Пользователи.Служебный = ЛОЖЬ)
		|			И (Пользователи.ра_ИдентификаторПользователяИБ <> &ПустойИдентификатор)
		// ТСК Близнюк С.И.; 12.09.2018; task#465}
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО ВнешниеПользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)";
	КонецЕсли;
	
	Запрос.Текст = Запрос.Текст + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" +
	"ВЫБРАТЬ
	|	ПользователиВКонтейнерах.Пользователь КАК Ссылка,
	|	ПользователиВКонтейнерах.Пользователь.ИдентификаторПользователяИБ
	|ИЗ
	|	РегистрСведений.ПолномочияПользователей КАК ПолномочияПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ПользователиВКонтейнерах КАК ПользователиВКонтейнерах
	|		ПО (ПолномочияПользователей.Полномочия = ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор))
	|			И ПолномочияПользователей.Владелец = ПользователиВКонтейнерах.Контейнер
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПроверяемыеПользователи.Пользователь,
	|	ПроверяемыеПользователи.ИдентификаторПользователяИБ
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПроверяемыеПользователи.Пользователь КАК Пользователь,
	|	ПолномочияПользователей.Полномочия КАК Профиль
	|ПОМЕСТИТЬ ПрофилиПользователей
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ПользователиВКонтейнерах КАК ПользователиВКонтейнерах
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ПолномочияПользователей КАК ПолномочияПользователей
	|			ПО ПользователиВКонтейнерах.Контейнер = ПолномочияПользователей.Владелец
	|		ПО ПроверяемыеПользователи.Пользователь = ПользователиВКонтейнерах.Пользователь
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиПользователей.Пользователь,
	|	Роли.Роль.Имя КАК Роль
	|ИЗ
	|	ПрофилиПользователей КАК ПрофилиПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ПрофилиПользователей.Профиль)
	|			И (НЕ Роли.Ссылка.ПометкаУдаления)";
	
	Если ПолучитьФункциональнуюОпцию("ИспользоватьВнешнихПользователей") Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей", "Истина");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей",
			"ТИПЗНАЧЕНИЯ(ПроверяемыеПользователи.Пользователь) = ТИП(Справочник.Пользователи)");
	КонецЕсли;
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	ПоследнийРезультат = РезультатыЗапросов.Количество()-1;
	Итог = Новый Структура;
	
	Итог.Вставить("Администраторы", Новый Соответствие);
	
	Для каждого Строка Из РезультатыЗапросов[ПоследнийРезультат-3].Выгрузить() Цикл
		Итог.Администраторы.Вставить(Строка.Ссылка, Истина);
	КонецЦикла;
	
	Итог.Вставить("ИдентификаторыПользователейИБ", РезультатыЗапросов[ПоследнийРезультат-2].Выгрузить());
	Итог.ИдентификаторыПользователейИБ.Индексы.Добавить("Пользователь");
	
	Итог.Вставить("РолиПользователей", РезультатыЗапросов[ПоследнийРезультат].Выгрузить());
	Итог.РолиПользователей.Индексы.Добавить("Пользователь");
	
	Возврат Итог;
	
КонецФункции

Функция ПрофилиПользователяСРолью(ТекущийПользователь, Роль)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", ТекущийПользователь);
	Запрос.УстановитьПараметр("Роль", Роль);
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Роли.Ссылка КАК Профиль
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|			И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
	|			И (СоставыГруппПользователей.Используется)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.ПометкаУдаления)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ГруппыДоступаПользователи.Ссылка.Профиль)
	|			И (НЕ Роли.Ссылка.ПометкаУдаления)
	|			И (Роли.Роль.Имя = &Роль)";
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Профиль");
	
КонецФункции

Процедура ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса)
	
	Для каждого КлючИЗначение Из ОбновляемыеПользователиИБ Цикл
		РолиДляДобавления  = КлючИЗначение.Значение.РолиДляДобавления;
		РолиДляУдаления    = КлючИЗначение.Значение.РолиДляУдаления;
		// ТСК Близнюк С.И.; 26.09.2018; task#657{
		//ПользовательИБ     = КлючИЗначение.Значение.ПользовательИБ;
		ТекущийПользователь = КлючИЗначение.Ключ;
		ПользовательИБ      = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ТекущийПользователь.ИдентификаторПользователяИБ);
		Естьра_ПользовательИБ = ТекущийПользователь.ра_ИдентификаторПользователяИБ <> Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
		Если Естьра_ПользовательИБ Тогда
			ра_ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ТекущийПользователь.ра_ИдентификаторПользователяИБ);
		КонецЕсли;
		// ТСК Близнюк С.И.; 26.09.2018; task#657}
		ПользовательСсылка = КлючИЗначение.Значение.ПользовательСсылка;
		
		БылиПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
		
		Для каждого КлючИЗначение Из РолиДляДобавления Цикл
			ПользовательИБ.Роли.Добавить(Метаданные.Роли[КлючИЗначение.Ключ]);
			// ТСК Близнюк С.И.; 26.09.2018; task#657{
			Если Естьра_ПользовательИБ Тогда
				ра_ПользовательИБ.Роли.Добавить(Метаданные.Роли[КлючИЗначение.Ключ]);			
			КонецЕсли;
			// ТСК Близнюк С.И.; 26.09.2018; task#657}		
		КонецЦикла;
		
		Для каждого КлючИЗначение Из РолиДляУдаления Цикл
			ПользовательИБ.Роли.Удалить(Метаданные.Роли[КлючИЗначение.Ключ]);
			// ТСК Близнюк С.И.; 26.09.2018; task#657{
			Если Естьра_ПользовательИБ Тогда
				ра_ПользовательИБ.Роли.Удалить(Метаданные.Роли[КлючИЗначение.Ключ]);			
			КонецЕсли;
			// ТСК Близнюк С.И.; 26.09.2018; task#657}
		КонецЦикла;
		
		ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса);
		// ТСК Близнюк С.И.; 26.09.2018; task#657{
		Если Естьра_ПользовательИБ Тогда
			ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ра_ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса);			
		КонецЕсли;
		// ТСК Близнюк С.И.; 26.09.2018; task#657}
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса)
	
	НачатьТранзакцию();
	
	Попытка
		ПользователиСлужебный.ЗаписатьПользователяИнформационнойБазы(ПользовательИБ, ПользовательСсылка);
		
		Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			ЗафиксироватьТранзакцию();
			Возврат;
		КонецЕсли;
		
		ЕстьПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
		Если ЕстьПолныеПрава = БылиПолныеПрава Тогда
			ЗафиксироватьТранзакцию();
			Возврат;
		КонецЕсли;
		
		Если ПарольПользователяСервиса = Неопределено Тогда
			
			Если ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
				ЗафиксироватьТранзакцию();
				Возврат;
			КонецЕсли;
			
			ВызватьИсключение
				НСтр("ru = 'Для изменения административного доступа
				           |требуется пароль пользователя сервиса.
				           |
				           |Операция может быть выполнена только интерактивно.';
				           |en = 'To change the administrative accsess
				           |required the password of service user.
				           |
				           |Operation can only be performed interactively.'");
		КонецЕсли;
		
		ПриЗаписиПользователяСервиса(ПользовательСсылка, Ложь, ПарольПользователяСервиса);
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ТекстЗапросаВыбораИзменений.

Функция КлючИЗначение(Структура)
	
	Для каждого КлючИЗначение Из Структура Цикл
		Возврат КлючИЗначение;
	КонецЦикла;
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей и ОбновитьНаборыЗаписей

Функция ГруппаПараметровИзмеренияОбработана(ИмяИзмерения, ЗначенияИзмерения)
	
	Если ИмяИзмерения = Неопределено Тогда
		ЗначенияИзмерения = Неопределено;
		
	ИначеЕсли ЗначенияИзмерения = Неопределено Тогда
		ИмяИзмерения = Неопределено;
		
	ИначеЕсли ТипЗнч(ЗначенияИзмерения) <> Тип("Массив")
	        И ТипЗнч(ЗначенияИзмерения) <> Тип("ФиксированныйМассив") Тогда
		
		ЗначениеИзмерения = ЗначенияИзмерения;
		ЗначенияИзмерения = Новый Массив;
		ЗначенияИзмерения.Добавить(ЗначениеИзмерения);
		
	ИначеЕсли ЗначенияИзмерения.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура УпорядочитьГруппыПараметровИзмерений(ИмяПервогоИзмерения,
                                               ЗначенияПервогоИзмерения,
                                               ИмяВторогоИзмерения,
                                               ЗначенияВторогоИзмерения,
                                               ИмяТретьегоИзмерения,
                                               ЗначенияТретьегоИзмерения)
	
	Если ИмяВторогоИзмерения = Неопределено Тогда
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если ИмяПервогоИзмерения = Неопределено Тогда
		ИмяПервогоИзмерения       = ИмяВторогоИзмерения;
		ЗначенияПервогоИзмерения  = ЗначенияВторогоИзмерения;
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если ЗначенияВторогоИзмерения  <> Неопределено
	   И ЗначенияТретьегоИзмерения <> Неопределено
	   И ЗначенияВторогоИзмерения.Количество()
	   > ЗначенияТретьегоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = ИмяВторогоИзмерения;
		ЗначенияИзмерения = ЗначенияВторогоИзмерения;
		
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = ИмяИзмерения;
		ЗначенияТретьегоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
	Если ЗначенияПервогоИзмерения <> Неопределено
	   И ЗначенияВторогоИзмерения <> Неопределено
	   И ЗначенияПервогоИзмерения.Количество()
	   > ЗначенияВторогоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = ИмяПервогоИзмерения;
		ЗначенияИзмерения = ЗначенияПервогоИзмерения;
		
		ИмяПервогоИзмерения      = ИмяВторогоИзмерения;
		ЗначенияПервогоИзмерения = ЗначенияВторогоИзмерения;
		ИмяВторогоИзмерения      = ИмяИзмерения;
		ЗначенияВторогоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
КонецПроцедуры

Функция ПоляНабораЗаписей(НаборЗаписей)
	
	ПоляСравнения = "";
	Таблица = НаборЗаписей.Выгрузить(Новый Массив);
	Для каждого Колонка Из Таблица.Колонки Цикл
		ПоляСравнения = ПоляСравнения + "," + Колонка.Имя;
	КонецЦикла;
	ПоляСравнения = Сред(ПоляСравнения, 2);
	
	Возврат ПоляСравнения;
	
КонецФункции

Функция ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(Знач Параметры,
                                                    Знач Отбор,
                                                    Знач СписокПолей,
                                                    Знач ИмяИзмерения,
                                                    Знач ЗначенияИзмерения,
                                                    ЕстьИзменения,
                                                    Знач ТолькоПроверка,
                                                    Знач ДополнительныеСвойства)
	
	// Открытие транзакции, если её нет или она ещё не открыта
	// для выполнения управляемой блокировки на читаемый набор записей.
	// Может быть ситуации, когда транзакция будет зафиксирована без
	// фактического изменения данных, т.е. если заблокированные данные совпадут.
	Если Параметры.ТранзакцияОткрыта = Ложь Тогда
		Параметры.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборЗаписей, Параметры.ПолноеИмяРегистра);
	
	Параметры.НаборЗаписей.Прочитать();
	НовыеЗаписиНабора = Параметры.НаборЗаписей.Выгрузить();
	НовыеЗаписиНабора.Индексы.Добавить(СписокПолей);
	
	Для каждого Значение Из ЗначенияИзмерения Цикл
		Отбор[ИмяИзмерения] = Значение;
		НайденныеЗаписи = НовыеЗаписиНабора.НайтиСтроки(Отбор);
		Для каждого НайденнаяЗапись Из НовыеЗаписиНабора.НайтиСтроки(Отбор) Цикл
			НовыеЗаписиНабора.Удалить(НайденнаяЗапись);
		КонецЦикла;
		Для каждого НайденнаяЗапись Из Параметры.НовыеЗаписи.НайтиСтроки(Отбор) Цикл
			ЗаполнитьЗначенияСвойств(НовыеЗаписиНабора.Добавить(), НайденнаяЗапись);
		КонецЦикла;
	КонецЦикла;
	
	ОбновитьНаборЗаписей(
		Параметры.НаборЗаписей,
		НовыеЗаписиНабора,
		Параметры.ПоляСравнения,
		,
		,
		ЕстьИзменения,
		,
		Параметры.ТранзакцияОткрыта,
		Истина,
		,
		ТолькоПроверка,
		ДополнительныеСвойства);
	
КонецФункции

Процедура ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Знач Параметры,
                                                           Знач Отбор,
                                                           ЕстьИзменения,
                                                           Знач ТолькоПроверка,
                                                           Знач ДополнительныеСвойства)
	
	Если Параметры.ТранзакцияОткрыта = Ложь Тогда
		Параметры.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	// Получение количества записей для чтения.
	
	Если Отбор.Количество() = 0 Тогда
		ТекущиеНовыеЗаписи = Параметры.НовыеЗаписи.Скопировать();
		КоличествоДляЧтения = Параметры.КоличествоДляЧтения;
	Иначе
		ТекущиеНовыеЗаписи = Параметры.НовыеЗаписи.Скопировать(Отбор);
		
		ИмяПоля = Параметры.КоличествоПоЗначениям.Колонки[0].Имя;
		СтрокаКоличества = Параметры.КоличествоПоЗначениям.Найти(Отбор[ИмяПоля], ИмяПоля);
		КоличествоДляЧтения = ?(СтрокаКоличества = Неопределено, 0, СтрокаКоличества.Количество);
	КонецЕсли;
	
	ОтборНовойЗаписи = Новый Структура("ВидИзмененияСтроки, " + Параметры.ПоляСравнения, 1);
	ТекущиеНовыеЗаписи.Индексы.Добавить("ВидИзмененияСтроки, " + Параметры.ПоляСравнения);

	КлючиЗаписей = ТекущиеНовыеЗаписи.Скопировать(, "ВидИзмененияСтроки, " + Параметры.ПоляСравнения);
	КлючиЗаписей.Свернуть("ВидИзмененияСтроки, " + Параметры.ПоляСравнения);
	КлючиЗаписей.Свернуть(Параметры.ПоляСравнения, "ВидИзмененияСтроки");
	
	ОтборПоКлючуЗаписи = Новый Структура(Параметры.ПоляСравнения);
	
	Если КоличествоДляЧтения < 1000
	 ИЛИ (  КоличествоДляЧтения < 100000
	      И КлючиЗаписей.Количество() * 50 > КоличествоДляЧтения) Тогда
		// Блочное обновление.
		ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборЗаписей, Параметры.ПолноеИмяРегистра);
		Параметры.НаборЗаписей.Прочитать();
		НовыеЗаписиНабора = Параметры.НаборЗаписей.Выгрузить();
		НовыеЗаписиНабора.Индексы.Добавить(Параметры.ПоляСравнения);
		
		Для каждого Строка Из КлючиЗаписей Цикл
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			НайденныеСтроки = НовыеЗаписиНабора.НайтиСтроки(ОтборПоКлючуЗаписи);
			Если Строка.ВидИзмененияСтроки = -1 Тогда
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Удаление старой строки.
					НовыеЗаписиНабора.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			Иначе
				// Добавление новой или обновление старой строки.
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЗаполняемаяСтрока = НовыеЗаписиНабора.Добавить();
				Иначе
					ЗаполняемаяСтрока = НайденныеСтроки[0];
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Параметры);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ЗаполняемаяСтрока, НоваяЗапись);
			КонецЕсли;
		КонецЦикла;
		// Изменение набора записей, чтобы он отличался от новых записей набора.
		Если Параметры.НаборЗаписей.Количество() = НовыеЗаписиНабора.Количество() Тогда
			Параметры.НаборЗаписей.Добавить();
		КонецЕсли;
		ОбновитьНаборЗаписей(
			Параметры.НаборЗаписей,
			НовыеЗаписиНабора,
			Параметры.ПоляСравнения,
			,
			,
			ЕстьИзменения,
			,
			Параметры.ТранзакцияОткрыта,
			Истина,
			,
			ТолькоПроверка,
			ДополнительныеСвойства);
	Иначе
		// Построчное обновление.
		УстановитьДополнительныеСвойства(Параметры.НаборДляОднойЗаписи, ДополнительныеСвойства);
		Для каждого Строка Из КлючиЗаписей Цикл
			Параметры.НаборДляОднойЗаписи.Очистить();
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			Для каждого КлючИЗначение ИЗ ОтборПоКлючуЗаписи Цикл
				УстановитьОтбор(
					Параметры.НаборДляОднойЗаписи.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
			КонецЦикла;
			ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборДляОднойЗаписи, Параметры.ПолноеИмяРегистра);
			Если Строка.ВидИзмененияСтроки > -1 Тогда
				// Добавление новой или обновление существующей строки.
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Параметры);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Параметры.НаборДляОднойЗаписи.Добавить(), НоваяЗапись);
			КонецЕсли;
			ЕстьИзменения = Истина;
			Если ТолькоПроверка Тогда
				Возврат;
			КонецЕсли;
			Параметры.НаборДляОднойЗаписи.Записать();
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ИсключениеПриОшибкеПоискаЗаписи(Параметры)
	
	Для каждого СтрокаИзменений Из Параметры.НовыеЗаписи Цикл
		Если СтрокаИзменений.ВидИзмененияСтроки <>  1
		   И СтрокаИзменений.ВидИзмененияСтроки <> -1 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
				           |общего модуля УправлениеДоступомСлужебный.
				           |
				           |Неверное значение параметра НовыеЗаписи - колонка
				           |ВидИзмененияСтроки содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'"),
				Строка(СтрокаИзменений.ВидИзмененияСтроки));
		КонецЕсли;
	КонецЦикла;
	
	ВызватьИсключение
		НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
		           |общего модуля УправлениеДоступомСлужебный.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра НовыеЗаписи.'");
	
КонецПроцедуры

Процедура ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра = Неопределено)
	
	Если НЕ ТранзакцияАктивна() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПолноеИмяРегистра = Неопределено Тогда
		ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	Для каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЭлементБлокировки.УстановитьЗначение(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	Блокировка.Заблокировать();
	
КонецПроцедуры

Процедура УстановитьОтбор(ЭлементОтбора, ЗначениеОтбора)
	
	ЭлементОтбора.Значение = ЗначениеОтбора;
	ЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

Функция ЗаписьНесколькимиНаборами(Параметры, Отбор, ИмяПоля, ЗначенияПоля)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначенияПоля", ЗначенияПоля);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТекущаяТаблица.ИмяПоля КАК ИмяПоля,
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|
	|СГРУППИРОВАТЬ ПО
	|	ТекущаяТаблица.ИмяПоля";
	
	УсловиеОтбора = "Истина";
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	ОтборДобавляемых = Новый Структура;
	ОтборДобавляемых.Вставить("ВидИзмененияСтроки", 1);
	ОтборУдаляемых = Новый Структура;
	ОтборУдаляемых.Вставить("ВидИзмененияСтроки", -1);
	
	Для каждого КлючИЗначение Из Отбор Цикл
		УсловиеОтбора = УсловиеОтбора + "
		|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборДобавляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборУдаляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоля", ИмяПоля);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Параметры.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	// Количество всех без отбора.
	КоличествоВсех = РезультатыЗапросов[0].Выгрузить()[0].Количество;
	Параметры.Вставить("КоличествоДляЧтения", КоличествоВсех);
	
	// Количество обновляемых с отбором.
	КоличествоОбновляемых = РезультатыЗапросов[1].Выгрузить()[0].Количество;
	
	КоличествоДобавляемых = Параметры.НовыеЗаписи.НайтиСтроки(ОтборДобавляемых).Количество();
	Если КоличествоДобавляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоДобавляемых;
	КонецЕсли;
	
	КоличествоУдаляемых = Параметры.НовыеЗаписи.НайтиСтроки(ОтборУдаляемых).Количество();
	Если КоличествоУдаляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоУдаляемых;
	КонецЕсли;
	
	// Количество для чтения по значениям отбора.
	КоличествоПоЗначениям = РезультатыЗапросов[2].Выгрузить();
	КоличествоПоЗначениям.Индексы.Добавить(ИмяПоля);
	Параметры.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениям);
	
	Возврат КоличествоВсех * 0.7 > КоличествоОбновляемых;
	
КонецФункции

Процедура ПрочитатьКоличествоДляЧтения(Параметры)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора";
	
	УсловиеОтбора = "Истина";
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Параметры.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	Параметры.Вставить("КоличествоДляЧтения", Запрос.Выполнить().Выгрузить()[0].Количество);
	
КонецПроцедуры

Процедура УстановитьДополнительныеСвойства(НаборЗаписей, ДополнительныеСвойства)
	
	Если ТипЗнч(ДополнительныеСвойства) = Тип("Структура") Тогда
		Для каждого КлючИЗначение Из ДополнительныеСвойства Цикл
			НаборЗаписей.ДополнительныеСвойства.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьРегистрСведений

Функция ЗначенияКолонкиТаблицы(Таблица, ИмяКолонки)
	
	НоваяТаблица = Таблица.Скопировать(, ИмяКолонки);
	
	НоваяТаблица.Свернуть(ИмяКолонки);
	
	Возврат НоваяТаблица.ВыгрузитьКолонку(ИмяКолонки);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных.
//
// Параметры:
//   Обработчики - ТаблицаЗначений, Неопределено - см. описание 
//    функции НоваяТаблицаОбработчиковОбновления общего модуля 
//    ОбновлениеИнформационнойБазы..
//    В случае прямого вызова (не через механизм обновления 
//    версии ИБ) передается Неопределено.
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено И ЕстьИзмененияПараметровОграниченияДоступа() Тогда
		Обработчики = Параметры.РазделенныеОбработчики;
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	КонецЕсли;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят только
// от конфигурации.
// Записывает изменения этих данных по версиям конфигурации
// (если изменения есть), чтобы использовать эти изменения
// при обновлении остальных вспомогательных данных, например,
// в обработчике ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации.
//
Процедура ОбновитьПараметрыОграниченияДоступа(ЕстьИзменения = Неопределено, ТолькоПроверка = Ложь) Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Константа.ПараметрыОграниченияДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваРолей");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	Если ТолькоПроверка ИЛИ МонопольныйРежим() Тогда
		СнятьМонопольныйРежим = Ложь;
	Иначе
		СнятьМонопольныйРежим = Истина;
		УстановитьМонопольныйРежим(Истина);
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		Константы.ПараметрыОграниченияДоступа.СоздатьМенеджерЗначения().ОбновитьОбщиеПараметры(ЕстьИзменения, ТолькоПроверка);
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			РегистрыСведений.ПраваРолей.ОбновитьДанныеРегистра(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		//Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
		//	РегистрыСведений.ЗависимостиПравДоступа.ОбновитьДанныеРегистра(ЕстьИзменения, ТолькоПроверка);
		//КонецЕсли;
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			ПланыВидовХарактеристик.ВидыДоступа.ОбновитьОписаниеСвойств(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			Справочники.ПрофилиГруппДоступа.ОбновитьОписаниеПоставляемыхПрофилей(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			Справочники.ПрофилиГруппДоступа.ОбновитьСоставПредопределенныхПрофилей(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		//Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
		//	РегистрыСведений.ПраваПоЗначениямДоступа.ОбновитьВозможныеПраваПоЗначенияДоступа(ЕстьИзменения, ТолькоПроверка);
		//КонецЕсли;
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			УправлениеДоступомДокументооборот.ОбновитьВозможныеПраваДляНастройкиПравОбъектов(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;

		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		Если СнятьМонопольныйРежим Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Если СнятьМонопольныйРежим Тогда
		УстановитьМонопольныйРежим(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Очищает вспомогательные данные, которые зависят только
// от конфигурации.
// Используется как обработчик очистки вспомогательных данных,
// которые зависят только от конфигурации, чтобы вызвать проверку и
// обновление остальных вспомогательных данных при обновлении ИБ,
// например, в обработчике ОбновитьВспомогательныеДанныеПриОбновленииИБ.
//
Процедура ОчиститьПараметрыОграниченияДоступа() Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Константа.ПараметрыОграниченияДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваРолей");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗависимостиПравДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	Если МонопольныйРежим() Тогда
		СнятьМонопольныйРежим = Ложь;
	Иначе
		СнятьМонопольныйРежим = Истина;
		УстановитьМонопольныйРежим(Истина);
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		// Очистка прав ролей.
		НаборЗаписей = РегистрыСведений.ПраваРолей.СоздатьНаборЗаписей();
		НаборЗаписей.Записать();
		
		// Очистка зависимостей прав.
		//НаборЗаписей = РегистрыСведений.ЗависимостиПравДоступа.СоздатьНаборЗаписей();
		//НаборЗаписей.Записать();
		
		// Очистка остальных данных построенных по метаданным и их изменений.
		Константы.ПараметрыОграниченияДоступа.Установить(Новый ХранилищеЗначения(Неопределено));
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		Если СнятьМонопольныйРежим Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Если СнятьМонопольныйРежим Тогда
		УстановитьМонопольныйРежим(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Проверяет были ли изменения неразделенных данных для какой-нибудь области данных.
Функция ЕстьИзмененияПараметровОграниченияДоступа() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПроверяемыеПараметры = Новый Массив;
	ПроверяемыеПараметры.Добавить("ОбъектыМетаданныхПравРолей");
	//ПроверяемыеПараметры.Добавить("ВозможныеПраваПоЗначениямДоступа");
	ПроверяемыеПараметры.Добавить("ВозможныеПраваДляНастройкиПравОбъектов");
	ПроверяемыеПараметры.Добавить("ПоставляемыеПрофилиГруппДоступа");
	ПроверяемыеПараметры.Добавить("ПредопределенныеПрофилиГруппДоступа");
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	
	Для каждого ПроверяемыйПараметр Из ПроверяемыеПараметры Цикл
		
		ПоследниеИзменения = СтандартныеПодсистемыСервер.ИзмененияПараметраРаботыПрограммы(
			Параметры, ПроверяемыйПараметр);
		
		Если ПоследниеИзменения = Неопределено
		 ИЛИ ПоследниеИзменения.Количество() > 0 Тогда
			
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Обновляет вспомогательные данные, которые зависят от конфигурации частично.
//
// Обновляется при наличии изменений конфигурации, записанных в параметры
// ограничения доступа при обновлении базы данных на текущую версию конфигурации.
//
Процедура ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено
	   И НЕ Параметры.МонопольныйРежим
	   И ЕстьИзмененияПараметровОграниченияДоступа() Тогда
		
		Параметры.МонопольныйРежим = Истина;
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	//ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
	//ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	//ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваПоЗначениямДоступа");
	//ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	//ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
	//ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		//РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистраПоИзменениямКонфигурации();
		//РегистрыСведений.ПраваПоЗначениямДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		Справочники.ПрофилиГруппДоступа.ОбновитьПоставляемыеПрофилиПоИзменениямКонфигурации();
		//Справочники.ГруппыДоступа.ПометитьНаУдалениеГруппыДоступаПомеченныхПрофилей();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Преобразует реквизит УдалитьРоль в реквизит Роль в табличной части Роли
// справочника Профили групп доступа.
//
Процедура ПреобразоватьИменаРолейВИдентификаторы() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Роли.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|ГДЕ
	|	НЕ(Роли.Роль <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|				И Роли.УдалитьРоль = """")";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Индекс = Объект.Роли.Количество()-1;
		Пока Индекс >= 0 Цикл
			Строка = Объект.Роли[Индекс];
			Если ЗначениеЗаполнено(Строка.Роль) Тогда
				Строка.УдалитьРоль = "";
			ИначеЕсли ЗначениеЗаполнено(Строка.УдалитьРоль) Тогда
				МетаданныеРоли = Метаданные.Роли.Найти(Строка.УдалитьРоль);
				Если МетаданныеРоли <> Неопределено Тогда
					Строка.УдалитьРоль = "";
					Строка.Роль = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
						МетаданныеРоли);
				Иначе
					Объект.Роли.Удалить(Индекс);
				КонецЕсли;
			Иначе
				Объект.Роли.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс-1;
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;
	
КонецПроцедуры

Процедура ПередПроверкойДоступностиРолей(МассивИменРолей) Экспорт
	
КонецПроцедуры

// Заполняет назначение профилей групп доступа.
Процедура ЗаполнитьНазначениеПрофилейГруппДоступа() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПрофилиГруппДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
	|ГДЕ
	|	НЕ(ПрофилиГруппДоступа.ИдентификаторПоставляемыхДанных <> &ПустойУникальныйИдентификатор
	|				И НЕ ПрофилиГруппДоступа.ПоставляемыйПрофильИзменен)
	|	И НЕ ПрофилиГруппДоступа.ЭтоГруппа
	|	И НЕ ПрофилиГруппДоступа.Ссылка В
	|				(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|					ПрофилиГруппДоступаНазначение.Ссылка
	|				ИЗ
	|					Справочник.ПрофилиГруппДоступа.Назначение КАК ПрофилиГруппДоступаНазначение)";
	
	Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
		
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		ПрофильОбъект = Выборка.Ссылка.ПолучитьОбъект();
		НоваяСтрока = ПрофильОбъект.Назначение.Добавить();
		НоваяСтрока.ТипПользователей = Справочники.Пользователи.ПустаяСсылка();
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрофильОбъект);
	КонецЦикла;
	
КонецПроцедуры

// Заменят удаленные роли на новые
Процедура ЗаменитьУдаленныеРолиВПрофиляхГруппДоступа() Экспорт
	
	// Заполнение списка удаленных ролей и соответствующих новых ролей.
	МассивУдаленныхРолей = Новый Массив;
	СоответствиеРолей = Новый Соответствие;
	
	// ДобавлениеИзменениеБазовойНСИ
	ИмяРоли = "ДобавлениеИзменениеБазовойНСИДокументооборот";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Свойства") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеДополнительныхРеквизитовИСведений"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Валюты") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеКурсовВалют"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ГрафикиРаботы") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеГрафиковРаботы"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КонтактнаяИнформация") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ДобавлениеИзменениеОбщейБазовойНСИ
	ИмяРоли = "? ДобавлениеИзменениеОбщейБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.АдресныйКлассификатор") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеАдресныхСведений"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Банки") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеБанков"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КалендарныеГрафики") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеКалендарныхГрафиков"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ИзменениеТекущегоПользователя
	ИмяРоли = "? ИзменениеТекущегоПользователя";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ИзменениеТекущегоВнешнегоПользователя
	ИмяРоли = "? ИзменениеТекущегоВнешнегоПользователя";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ЧтениеБазовойНСИ
	ИмяРоли = "ЧтениеБазовойНСИДокументооборот";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ГрафикиРаботы") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ЧтениеГрафиковРаботы"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Валюты") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ЧтениеКурсовВалют"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ЧтениеОбщейБазовойНСИ
	ИмяРоли = "? ЧтениеОбщейБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ДобавлениеИзменениеСтранМира
	ИмяРоли = "? ДобавлениеИзменениеСтранМира";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КонтактнаяИнформация") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// Найти профили, использующие удаленные роли
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	РолиПрофилей.Ссылка КАК Профиль,
	|	ИдентификаторыУдаленныхРолей.Ссылка КАК ИдентификаторРоли,
	|	ИдентификаторыУдаленныхРолей.Имя
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК РолиПрофилей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыУдаленныхРолей
	|		ПО РолиПрофилей.Роль = ИдентификаторыУдаленныхРолей.Ссылка
	|		И ИдентификаторыУдаленныхРолей.Имя В (&МассивУдаленныхРолей)
	|ИТОГИ ПО
	|	Профиль";
	
	Запрос.УстановитьПараметр("МассивУдаленныхРолей", МассивУдаленныхРолей);
	ДеревоПрофилей = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Для Каждого СтрокаПрофиля Из ДеревоПрофилей.Строки Цикл
		
		ПрофильОбъект = СтрокаПрофиля.Профиль.ПолучитьОбъект();
		РолиПрофиля = ПрофильОбъект.Роли;
		
		Для Каждого СтрокаРоли Из СтрокаПрофиля.Строки Цикл
			
			// Удаляем роль из профиля
			Если СтрНачинаетсяС(СтрокаРоли.ИдентификаторРоли, "? ") Тогда
				Отбор = Новый Структура("Роль", СтрокаРоли.ИдентификаторРоли);
				СтрокаТабличнойЧасти = РолиПрофиля.НайтиСтроки(Отбор)[0];
				РолиПрофиля.Удалить(СтрокаТабличнойЧасти);
			КонецЕсли;
			
			// Добавляем новые роли
			ДобавляемыеРоли = СоответствиеРолей.Получить(СтрокаРоли.Имя);
			Для Каждого ДобавляемаяРоль Из ДобавляемыеРоли Цикл
				
				Отбор = Новый Структура;
				Отбор.Вставить("Роль", ДобавляемаяРоль);
				Если РолиПрофиля.НайтиСтроки(Отбор).Количество() = 0 Тогда
					НоваяСтрока = РолиПрофиля.Добавить();
					НоваяСтрока.Роль = ДобавляемаяРоль;
				КонецЕсли;
			
			КонецЦикла;
			
		КонецЦикла;
		
		Отбор = Новый Структура;
		Отбор.Вставить("Роль", ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
		НайденныеРоли = РолиПрофиля.НайтиСтроки(Отбор);
		Если НайденныеРоли.Количество() > 1 Тогда
			РолиПрофиля.Удалить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
		КонецЕсли;
		
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрофильОбъект,, Истина);
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет принадлежность роли специальной группе профильных ролей.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПрофильнаяРоль(ИмяРоли) Экспорт
	
	Возврат ВРег(Лев(ИмяРоли, СтрДлина("Профиль"))) = ВРег("Профиль");
	
КонецФункции


