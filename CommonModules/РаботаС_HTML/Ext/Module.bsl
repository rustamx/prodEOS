////////////////////////////////////////////////////////////////////////////////
// Работа с HTML.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Возвращает ДокументHTML.
//
// Параметры:
// - ТекстHTML (Строка) - в формате HTML
// - Кодировка (Строка) - необязательный
//
Функция ПолучитьДокументHTMLИзТекстаHTML(Знач ТекстHTML, Знач Кодировка = Неопределено) Экспорт
	
	Если ПустаяСтрока(ТекстHTML) Тогда
		Возврат Новый ДокументHTML;
	КонецЕсли;
	
	ЧтениеHTML = Новый ЧтениеHTML;
	Если ЗначениеЗаполнено(Кодировка) Тогда
		Попытка
			ЧтениеHTML.УстановитьСтроку(ТекстHTML, Кодировка);
		Исключение	
			ЧтениеHTML.УстановитьСтроку(ТекстHTML); // кодировка могла быть некорректная - ставим без кодировки
		КонецПопытки;	
	Иначе
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
	КонецЕсли;
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
	
	Возврат ДокументHTML;
	
КонецФункции

// Возвращает ДокументHTML.
//
// Параметры:
// - Текст (Строка)
//
Функция ПолучитьДокументHTMLИзПростогоТекста(Знач Текст, Знач Кодировка = Неопределено) Экспорт
	
	ДокументHTML = Новый ДокументHTML;
	ЭлементHead = ДокументHTML.СоздатьЭлемент("head");
	ЭлементMeta = ДокументHTML.СоздатьЭлемент("meta");
	
	Атрибут = ДокументHTML.СоздатьАтрибут("content");
	Атрибут.ТекстовоеСодержимое = ?(ЗначениеЗаполнено(Кодировка), "text/html; charset=" + Кодировка, "text/html");
	ЭлементMeta.Атрибуты.УстановитьИменованныйЭлемент(Атрибут);
	
	Атрибут = ДокументHTML.СоздатьАтрибут("http-equiv");
	Атрибут.ТекстовоеСодержимое = "Content-Type";
	ЭлементMeta.Атрибуты.УстановитьИменованныйЭлемент(Атрибут);
	
	ЭлементHead.ДобавитьДочерний(ЭлементMeta);
	ДокументHTML.ЭлементДокумента.ДобавитьДочерний(ЭлементHead);
	
	ЭлементТело = ДокументHTML.СоздатьЭлемент("body");
	ДокументHTML.Тело = ЭлементТело;
	ЭлементБлок = РаботаС_HTML.ДобавитьЭлементСАтрибутами(
		ЭлементТело,
		"div",
		Новый Структура("style", "font-family:Arial;font-size:12px;"));
	
	Текст = СтрЗаменить(Текст, Символы.ВК + Символы.ПС, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(7), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(8), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символы.ВТаб, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(12), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символы.ВК, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(14), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(28), " ");
	Текст = СтрЗаменить(Текст, Символ(29), " ");
	Текст = СтрЗаменить(Текст, Символ(30), " ");
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Текст);
	Для К = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		Строка = ТекстовыйДокумент.ПолучитьСтроку(К);
		Строка = СтрЗаменить(Строка, Символы.ВТаб, "    ");
		Строка = СтрЗаменить(Строка, Символы.Таб, "    ");
		Строка = СтрЗаменить(Строка, "  ", Символы.НПП + " ");
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
		Абзац = РаботаС_HTML.СоздатьЭлементСАтрибутами(
			ДокументHTML,
			"p",
			Новый Структура("style", "margin-top:2px;margin-bottom:2px;"));
		Абзац.ДобавитьДочерний(ДокументHTML.СоздатьТекстовыйУзел(Строка));
		ЭлементБлок.ДобавитьДочерний(Абзац);
	КонецЦикла;
	
	Возврат ДокументHTML;
	
КонецФункции

// Возвращает текст HTML для отображения переданного текста.
//
Функция ПолучитьHTMLИзТекста(
	Знач Текст,
	Знач Кодировка = Неопределено,
	Знач БезОсновныхТегов = Ложь) Экспорт
	
	ТекстHTML =
		"<html>
		|<head>
		|<meta %content% http-equiv=""Content-Type"">
		|</head>
		|<body style=""margin-top:1px; padding-top:1px; overflow:auto; "">
		|<div>%Текст%</div>
		|</body>
		|</html>";
	
	Если ЗначениеЗаполнено(Кодировка) Тогда
		ТекстHTML = СтрЗаменить(ТекстHTML, "%content%", "content=""text/html; charset=" + Кодировка + """");
	Иначе
		ТекстHTML = СтрЗаменить(ТекстHTML, "%content%", "content=""text/html");
	КонецЕсли;
	
	ЗаменитьУправляющиеСимволы(Текст);
	ТекстИсточника = Новый ТекстовыйДокумент;
	ТекстИсточника.УстановитьТекст(Текст);
	КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
	ТекстРезультата = Новый ТекстовыйДокумент;
	
	Для К = 1 По КоличествоСтрок Цикл
		
		Строка = ТекстИсточника.ПолучитьСтроку(К);
		
		Если Не ПустаяСтрока(Строка) Тогда
			ЗаменитьТабуляцииИПробелы(Строка);
			ЗаменитьСпецСимволыHTML(Строка);
		КонецЕсли;
		
		Если К = КоличествоСтрок Тогда
			ТекстРезультата.ДобавитьСтроку(Строка);
		Иначе
			ТекстРезультата.ДобавитьСтроку(Строка + "<br>");
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстВставки = ТекстРезультата.ПолучитьТекст();
	Если Не ЗначениеЗаполнено(ТекстВставки) Тогда
		ТекстВставки = "&nbsp;";
	КонецЕсли;
	
	ТекстВставки = ПолучитьТекстHTMLСВыделениемТекстовыхЦитат(ТекстВставки);
	
	Если БезОсновныхТегов Тогда
		Возврат ТекстВставки;
	КонецЕсли;
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "%Текст%", ТекстВставки);
	
	Возврат ТекстHTML;
	
КонецФункции

// Заменяет в строке все спецсимволы на соответствующие им имена,
// возвращает измененную строку.
//
Функция ЗаменитьСпецСимволыHTML(Строка, СпецСимволыСоотв = Неопределено) Экспорт
	
	СоответствиеСпецСимволов = РаботаС_HTMLПовтИсп.ПолучитьСоответствиеСпецСимволов();
	
	ЗаменитьСпецСимволHTML(Строка, 38, "amp");
	
	НоваяСтрока = "";
	
	Для Поз = 1 По СтрДлина(Строка) Цикл
		
		Код = КодСимвола(Строка, Поз);
		ИмяСимвола = СоответствиеСпецСимволов.Получить(Код);
		
		Если ИмяСимвола = Неопределено Тогда
			НоваяСтрока = НоваяСтрока + Символ(Код);
		Иначе
			НоваяСтрока = НоваяСтрока + "&" + ИмяСимвола + ";";
		КонецЕсли;
		
	КонецЦикла;
	
	Строка = НоваяСтрока;
	
	Возврат Строка;
	
КонецФункции

// Добавляет текстовый узел к ДокументуHTML.
//
Процедура ДобавитьТекстовыйУзел(
	ЭлементРодитель,
	Текст,
	ВыделятьЖирным = Ложь,
	ДобавлятьПереносСтроки = Ложь) Экспорт
	
	ДокументВладелец = ЭлементРодитель.ДокументВладелец;
	ТекстовыйУзел = ДокументВладелец.СоздатьТекстовыйУзел(Текст);
	
	Если ВыделятьЖирным Тогда
		ЭлементЖирный = ДокументВладелец.СоздатьЭлемент("b");
		ЭлементЖирный.ДобавитьДочерний(ТекстовыйУзел);
		ЭлементРодитель.ДобавитьДочерний(ЭлементЖирный);
	Иначе
		ЭлементРодитель.ДобавитьДочерний(ТекстовыйУзел);
	КонецЕсли;
	
	Если ДобавлятьПереносСтроки Тогда
		ЭлементРодитель.ДобавитьДочерний(ДокументВладелец.СоздатьЭлемент("br"));
	КонецЕсли;
	
КонецПроцедуры 

// Получает текстовое содержимое из ДокументаHTML.
//
Функция ПолучитьТекстHTMLИзОбъектаДокументHTML(ДокументHTML) Экспорт
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	Возврат ЗаписьHTML.Закрыть();
	
КонецФункции

// Добавляет элемент в ДокументHTML.
//
Функция СоздатьЭлементСАтрибутами(ДокументHTML, Имя, Атрибуты) Экспорт
	
	ЭлементHTML = ДокументHTML.СоздатьЭлемент(Имя);
	Для каждого Атрибут Из Атрибуты Цикл
		УстановитьАтрибутЭлементаHTML(ЭлементHTML, Атрибут.Ключ, Атрибут.Значение);
	КонецЦикла;
	
	Возврат ЭлементHTML;
	
КонецФункции

// Добавляет элемент в ДокументHTML.
//
Функция ДобавитьЭлементСАтрибутами(ЭлементРодитель, Имя, Атрибуты) Экспорт
	
	ЭлементHTML = СоздатьЭлементСАтрибутами(ЭлементРодитель.ДокументВладелец, Имя, Атрибуты);
	ЭлементРодитель.ДобавитьДочерний(ЭлементHTML);
	
	Возврат ЭлементHTML;
	
КонецФункции

// Устанавливает атрибуты элементу ДокументаHTML.
//
Процедура УстановитьАтрибутЭлементаHTML(ЭлементHTML, Имя, ТекстовоеСодержимое) Экспорт
	
	АтрибутHTML = ЭлементHTML.ДокументВладелец.СоздатьАтрибут(Имя);
	АтрибутHTML.ТекстовоеСодержимое = ТекстовоеСодержимое;
	ЭлементHTML.Атрибуты.УстановитьИменованныйЭлемент(АтрибутHTML);
	
КонецПроцедуры

// Вставляет ЭлементHTML на первое место в массив дочерних элементов ДокументаHTML.
//
Процедура ВставитьЭлементHTMLПервымДочернимЭлементом(
	ЭлементРодитель,
	ВставляемыйЭлемент) Экспорт
	
	Если ЭлементРодитель.ДочерниеУзлы.Количество() > 0 Тогда
		ЭлементРодитель.ВставитьПеред(ВставляемыйЭлемент, ЭлементРодитель.ДочерниеУзлы[0]);
	Иначе
		ЭлементРодитель.ДобавитьДочерний(ВставляемыйЭлемент);
	КонецЕсли;
	
КонецПроцедуры

// Преобразовывает HTML текст в текст
Функция ПолучитьТекстИзHTML(Знач ТекстHTML, Знач Кодировка = Неопределено, Знач ВыделятьСсылки = Истина) Экспорт
	
	ВыполнятьОсобуюОбработку = (СтрДлина(ТекстHTML) <= 250000);
	Если ВыполнятьОсобуюОбработку Тогда
		ТекстHTML = ПолучитьТекстHTMLСВыделениемУровнейЦитат(ТекстHTML);
		Если ВыделятьСсылки Тогда
			ТекстHTML = ПолучитьТекстHTMLСВыделениемСсылок(ТекстHTML);
		КонецЕсли;
	КонецЕсли;
	
	ИспользоватьInternetExplorer = Истина;
	#Если Сервер Тогда
		ИспользоватьInternetExplorer 
			= ВстроеннаяПочтаСерверПовтИсп.ПолучитьИспользоватьInternetExplorerДляПолученияТекстаИзHTML();
	#КонецЕсли
	
	Если ИспользоватьInternetExplorer = Истина Тогда
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
			
			Попытка
				
				HTMLФайл = Новый COMОбъект("htmlfile");
				HTMLФайл.Open("text/html");
				HTMLФайл.write(ТекстHTML);
				
				Текст = HTMLФайл.documentElement.document.body.innerText;
				
				Если ВыполнятьОсобуюОбработку Тогда
					Текст = ПолучитьТекстСВыделениемЦитатПоУровням(Текст);
				КонецЕсли;
				
				Возврат Текст;
				
			Исключение
				// На сервере этот объект может быть недоступен
			КонецПопытки;
			
		КонецЕсли;
	КонецЕсли;
	
	ПереводСтроки = Символы.ВК + Символы.ПС;
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>", "</o:p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>" + ПереводСтроки + ПереводСтроки, "</o:p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>", "</p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>" + ПереводСтроки + ПереводСтроки, "</p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</div>", "</div>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</div>" + ПереводСтроки + ПереводСтроки, "</div>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "<br>", ПереводСтроки + ПереводСтроки);
	
	Построитель = Новый ПостроительDOM;
	ЧтениеHTML = Новый ЧтениеHTML;
	Если ЗначениеЗаполнено(Кодировка) Тогда
		Попытка
			ЧтениеHTML.УстановитьСтроку(ТекстHTML, Кодировка);
		Исключение	
			ЧтениеHTML.УстановитьСтроку(ТекстHTML); // кодировка могла быть некорректная - ставим без кодировки
		КонецПопытки;	
	Иначе
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
	КонецЕсли;
	
	ДокументHTML = Построитель.Прочитать(ЧтениеHTML);
	
	УдалитьТегиИзЭлементаHTML(ДокументHTML, "style");
	
	Если ДокументHTML.Тело = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Текст = ДокументHTML.Тело.ТекстовоеСодержимое;
	Если ВыполнятьОсобуюОбработку Тогда
		Текст = ПолучитьТекстСВыделениемЦитатПоУровням(Текст);
	КонецЕсли;
	
	Возврат Текст;
	
КонецФункции

// Получает текстовое содержимое ДокументаHTML.
//
Функция ПолучитьПростойТекстИзHTML(Знач ТекстHTML, Знач Кодировка = Неопределено) Экспорт
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>", "</o:p>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>" + Символы.ПС + Символы.ПС, "</o:p>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>", "</p>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>" + Символы.ПС + Символы.ПС, "</p>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</div>", "</div>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</div>" + Символы.ПС + Символы.ПС, "</div>" + Символы.ПС);
	ТекстHTML = СтрЗаменить(ТекстHTML, "<br>", Символы.ПС + Символы.ПС);
	
	Построитель = Новый ПостроительDOM;
	ЧтениеHTML = Новый ЧтениеHTML;
	Если ЗначениеЗаполнено(Кодировка) Тогда
		Попытка
			ЧтениеHTML.УстановитьСтроку(ТекстHTML, Кодировка);
		Исключение	
			ЧтениеHTML.УстановитьСтроку(ТекстHTML); // кодировка могла быть некорректная - ставим без кодировки
		КонецПопытки;	
	Иначе
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
	КонецЕсли;
	
	ДокументHTML = Построитель.Прочитать(ЧтениеHTML);
	
	Если ДокументHTML.Тело = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат ДокументHTML.Тело.ТекстовоеСодержимое;
	
КонецФункции

// Возвращает текст HTML.
//
Функция ПолучитьТекстHTMLДляИсходящегоПисьмаИзПростогоТекста(Знач Текст, Знач Кодировка = Неопределено) Экспорт
	
	ЗаменитьУправляющиеСимволы(Текст);
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Текст);
	
	ТекстДляВставки = "";
	КоличествоСтрок = ТекстовыйДокумент.КоличествоСтрок();
	
	Для К = 1 По КоличествоСтрок Цикл
		
		Строка = ТекстовыйДокумент.ПолучитьСтроку(К);
		Если ПустаяСтрока(Строка) Тогда
			ТекстДляВставки = ТекстДляВставки + ?(К = 1, "", Символы.ПС) + "<br>";
			Продолжить;
		КонецЕсли;
		
		ЗаменитьТабуляцииИПробелы(Строка);
		ЗаменитьСпецСимволыHTML(Строка);
		ДобавитьТегиКСсылкам(Строка);
		Если К <> КоличествоСтрок Тогда
			Строка = Строка + "<br>";
		КонецЕсли;
		
		ТекстДляВставки = ТекстДляВставки + ?(К = 1, "", Символы.ПС) + Строка;
		
	КонецЦикла;
	
	ТекстHTML =
		"<html>
		|<head>
		|<meta content=""text/html; charset=[charset]"" http-equiv=""Content-Type"">
		|</head>
		|<body>
		|<div>[ТекстДляВставки]</div>
		|</body>
		|</html>";
	
	Если ЗначениеЗаполнено(Кодировка) Тогда
		ТекстHTML = СтрЗаменить(ТекстHTML, "[charset]", Кодировка);
	Иначе
		ТекстHTML = СтрЗаменить(ТекстHTML, "; charset=[charset]", "");
	КонецЕсли;
	
	ТекстДляВставки = ПолучитьТекстHTMLСВыделениемТекстовыхЦитат(ТекстДляВставки);
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "[ТекстДляВставки]", ТекстДляВставки);
	
	Возврат ТекстHTML;
	
КонецФункции

// Добавляет к тексту в формате HTML другой текст в формате HTML
// Из добавляемого текста берется только внутренность тега <body>, если он там присутствует
// иначе добавляется весь ДобавляемыйТекстHTML.
Процедура ДобавитьТекстHTML(ТекстHTML, ДобавляемыйТекстHTML) Экспорт
	
	РазложенныйТекстHTML = РазложитьТекстHTML(ТекстHTML);
	РазложенныйДобавляемыйТекстHTML = РазложитьТекстHTML(ДобавляемыйТекстHTML);
	
	ТекстHTML = РазложенныйТекстHTML.Заголовок
		+ РазложенныйТекстHTML.Тело
		+ РазложенныйДобавляемыйТекстHTML.Тело
		+ РазложенныйТекстHTML.Окончание;
	
КонецПроцедуры

// Возвращает структуру "Заголовок, Тело, Окончание",
// где ТекстHTML = Заголовок + Тело + Окончание
// и Тело - содержимое тега body
//
Функция РазложитьТекстHTML(ТекстHTML) Экспорт
	
	НРегТекстHTML = НРег(ТекстHTML);
	
	ПозицияНачалаТела = 1;
	ПозицияОкончанияТела = СтрДлина(ТекстHTML);
	
	ПозицияНачалаТегаHTML = СтрНайти(НРегТекстHTML, "<html");
	Если ПозицияНачалаТегаHTML > 0 Тогда
		ПозицияОкончанияТегаHTML = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, ">", ПозицияНачалаТегаHTML);
		Если ПозицияОкончанияТегаHTML > 0 Тогда
			ПозицияНачалаТела = ПозицияОкончанияТегаHTML + 1;
		КонецЕсли;
	КонецЕсли;
	
	ПозицияНачалаТегаBODY = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, "<body", ПозицияНачалаТела - 1);
	Если ПозицияНачалаТегаBODY > 0 Тогда
		ПозицияОкончанияТегаBODY = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, ">", ПозицияНачалаТегаBODY);
		Если ПозицияОкончанияТегаBODY > 0 Тогда
			ПозицияНачалаТела = ПозицияОкончанияТегаBODY + 1;
		КонецЕсли;
	КонецЕсли;
	
	ПозицияНачалаЗакрывающегоТегаBODY = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, "</body>", ПозицияНачалаТела - 1);
	Если ПозицияНачалаЗакрывающегоТегаBODY > 0 Тогда
		ПозицияОкончанияТела = ПозицияНачалаЗакрывающегоТегаBODY - 1;
	Иначе
		ПозицияНачалаЗакрывающегоТегаHTML = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, "</html>", ПозицияНачалаТела - 1);
		Если ПозицияНачалаЗакрывающегоТегаHTML > 0 Тогда
			ПозицияОкончанияТела = ПозицияНачалаЗакрывающегоТегаHTML - 1;
		КонецЕсли;
	КонецЕсли;
	
	Заголовок = Лев(ТекстHTML, ПозицияНачалаТела - 1);
	Тело = Сред(ТекстHTML, ПозицияНачалаТела, ПозицияОкончанияТела - ПозицияНачалаТела + 1);
	Окончание = Сред(ТекстHTML, ПозицияОкончанияТела + 1);
	
	Результат = Новый Структура("Заголовок, Тело, Окончание", Заголовок, Тело, Окончание);
	
	Возврат Результат;
	
КонецФункции

// Добавляет теги ко всем ссылкам, находящимся в строке.
// Обрабатываются следующие схемы обращения к ресурсу:
// http://, https://, ftp://, mailto:, file://, file:, e1c://, e1cib/
// Кроме того обрабатываются с использованием схемы http:// ссылки начинающиеся с www. без схемы.
// Строки размером 250000 больше  не обрабатываются.
Процедура ДобавитьТегиКСсылкам(ТекстHTML) Экспорт
	
	Если СтрДлина(ТекстHTML) > 250000 Тогда
		Возврат;
	КонецЕсли;
	
	// Ссылки со схемой
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "http://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "https://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "ftp://");
	
	// Ссылки без схемы
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "www.", "http://www.");
	
	// Навигационные ссылки
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "e1c://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "e1cib/", "v8doc:e1cib/");
	
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "file://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "\\", "file://\\");
	СписокТомовДисков = РаботаС_HTMLПовтИсп.СписокТомовДисков();
	Для Каждого ЭлементТомДиска Из СписокТомовДисков Цикл
		ТомДиска = ЭлементТомДиска.Значение;
		ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, ТомДиска + ":\", "file://" + ТомДиска + ":\");
		ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, ТомДиска + ":/", "file://" + ТомДиска + ":\");
	КонецЦикла;
	
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "mailto:");
	
	// Скорректировать ссылки со схемами e1c<<ВНЕШНЕЕСОЕДИНЕНИЕ>> и v8doc:e1cib/
	СкорректироватьСсылки(ТекстHTML, "e1c://");
	СкорректироватьСсылки(ТекстHTML, "e1cib/", "v8doc:e1cib/");
	
	// Заполнить title у ссылок
	ЗаполнитьСвойствоTitleУСсылок(ТекстHTML);
	
КонецПроцедуры

// Проверяет нахождение переданной позиции внутри тега (в параметрах или содержании)
// Если тег не закрыт, то проверяет только в параметрах тега.
Функция ПозицияНаходитсяВТеге(ТекстHTML, НазваниеЭлемента, Позиция, Тег = Неопределено) Экспорт
	
	НачалоОткрывающегоТега = "<" + НРег(НазваниеЭлемента);
	ДлинаОткрывающегоТега = СтрДлина(НачалоОткрывающегоТега);
	
	ПозицияНаходитсяВТеге = Ложь;
	
	НачалоТекстаHTML = Лев(НРег(ТекстHTML), Позиция - 1);
	НайденнаяПозицияНачалаОткрывающегоТега = 0;
	ПозицияОкончанияОткрывающегоТега = 0;
	
	ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоОткрывающегоТега);
	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл
		
		НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияНачалаОткрывающегоТега + 1);
		НайденнаяПозицияНачалаОткрывающегоТега =
			НайденнаяПозицияНачалаОткрывающегоТега
			+ ПозицияОкончанияОткрывающегоТега
			+ ПозицияНачалаОткрывающегоТега;
		
		ПозицияОкончанияОткрывающегоТега = СтрНайти(НачалоТекстаHTML, ">");
		Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда
			
			НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияОкончанияОткрывающегоТега + 1);
			
		КонецЕсли;
		
		ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоОткрывающегоТега);
		
	КонецЦикла;
	
	Если НайденнаяПозицияНачалаОткрывающегоТега <> 0 Тогда
		
		// Если есть незакрытый открывающий тег до искомой позиции, ищем тег в исходном тексте HTML.
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, НазваниеЭлемента, НайденнаяПозицияНачалаОткрывающегоТега);
		
		Если ЗаполненаСтруктураТега(Тег) Тогда
			
			Если Позиция > Тег.ПозицияНачалаТега И Позиция < Тег.ПозицияОкончанияТега Тогда
				
				ПозицияНаходитсяВТеге = Истина;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ПозицияНаходитсяВТеге;
	
КонецФункции

// Возвращает HTML код внутренней ссылки на предмет
Функция ПолучитьСсылкуНаПредмет(Предмет) Экспорт
	
	СсылкаНаПредмет = "";
	Если НЕ ЗначениеЗаполнено(Предмет) Тогда
		Возврат СсылкаНаПредмет;
	КонецЕсли;
	
	ПредставлениеСсылки = РаботаСРабочимКалендаремСервер.ПолучитьПредставлениеПредмета(Предмет);
	
	Если ЗначениеЗаполнено(ПредставлениеСсылки) Тогда
		НавигационнаяСсылка = "v8doc:" + ПолучитьНавигационнуюСсылку(Предмет);
		СсылкаНаПредмет =
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<a href=""%1"">%2</a>",
				НавигационнаяСсылка, ПредставлениеСсылки);
	КонецЕсли;
	
	Возврат СсылкаНаПредмет;
	
КонецФункции

// Удаляет схему v8doc: из текста ссылки.
//
// Параметры:
//  Ссылка - Строка - Ссылка из которой следует удалить схему v8doc:.
//
// Возвращаемое значение:
//  Строка - Ссылка без схемы v8doc:
//
Функция УдалитьСхемуДокументооборота(Ссылка) Экспорт
	
	Возврат УдалитьСхему(Ссылка, "v8doc:");
	
КонецФункции

// Удаляет схему из текста ссылки.
//
// Параметры:
//  Ссылка - Строка - Ссылка из которой следует удалить схему mailto:.
//  Схема - Строка - Схема, которую следует удалить.
//
// Возвращаемое значение:
//  Строка - Ссылка без схемы.
//
Функция УдалитьСхему(Ссылка, Схема) Экспорт
	
	СсылкаБезСхемы = Ссылка;
	
	Если ПустаяСтрока(Схема) Тогда
		Возврат СсылкаБезСхемы;
	КонецЕсли;
	
	Если СтрНачинаетсяС(НРег(СсылкаБезСхемы), НРег(Схема)) Тогда
		СсылкаБезСхемы = Сред(СсылкаБезСхемы, СтрДлина(Схема) + 1);
	КонецЕсли;
	
	Возврат СсылкаБезСхемы;
	
КонецФункции

// Формирует описание стиля цитирования
//
// Параметры:
//  ВидЦитированияПриОтвете - Перечисления.ВидыЦитированияПриОтвете - Вид цитирования, для которого
//                                                                    необходимо сформировать стиль.
//  ДляВключенияВСтиль - Булево - Признак способа формирования стиля.
//                                Если установлен в Истина, то формирует многострочное описание стиля.
//                                Если установлен в Ложь, то формирует строковое описание стиля.
//
// Возвращаемое значение:
//  Строка - Описание стиля цитирования.
//
Функция ПолучитьСтильЦитированияПриОтвете(ВидЦитированияПриОтвете, ДляВключенияВСтиль = Ложь) Экспорт
	
	ТекстСтиля = "";
	
	Если ВидЦитированияПриОтвете = ПредопределенноеЗначение("Перечисление.ВидыЦитированияПриОтвете.ВертикальнаяПолоса") Тогда
		Если ДляВключенияВСтиль Тогда
			ТекстСтиля =
				"	border:none;
				|	border-left:solid #7eaae3 1.5pt;
				|	padding:0cm 0cm 0cm 4pt;
				|	margin:0cm;";
		Иначе
			ТекстСтиля = "style = 'border:none;border-left:solid #7eaae3 1.5pt;padding:0cm 0cm 0cm 4pt;margin:0cm;'";
		КонецЕсли;
	Иначе
		Если ДляВключенияВСтиль Тогда
			ТекстСтиля =
				"	border:none;
					|padding:0cm 0cm 0cm 36pt;
					|margin:0cm;";
		Иначе
			ТекстСтиля = "style = 'border:none;padding:0cm 0cm 0cm 36pt;margin:0cm;'";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТекстСтиля;
	
КонецФункции

// Указывает стиль отображения для всех шрифтов, если шрифт отображения установлен.
//
// Параметры:
//  ТекстHTML - Строка - Текст, в который следует добавить описание стиля.
//  ШрифтОтображения - Список типов - Текстовое описание параметра
//  ШрифтОтображенияУстановлен - Список типов - Текстовое описание параметра
//
Процедура ПрименитьИзменениеНастройкиОтображенияПисьма(ТекстHTML, ШрифтОтображения = Неопределено, ШрифтОтображенияУстановлен = Ложь) Экспорт
	
	Если ШрифтОтображенияУстановлен Тогда
		ПрименитьНастройкиОтображениеПисьма(ТекстHTML, ШрифтОтображения, Ложь, Истина);
	КонецЕсли;
	
КонецПроцедуры

// Дописывает описание стиля отображения текста письма в HTML текст. Стиль формируется
// в соответствии с пользовательскими настройками или переданными параметрами. Если в
// переданном тексте не хватает тегов <html>, <head>, <body>, то они будут добавлены.
// Стиль будет добавлен в <head> в тег <style class=v8doc-style type=text/css>.
//
// Параметры:
//  ТекстHTML - Строка - Текст, в который следует добавить описание стиля.
//  ШрифтОтображения - Шрифт - Шрифт, который следует использовать в стиле. 
//                             Если не указан, то шрифт будет браться из пользовательских настроек.
//  ОтображатьДругиеШрифты - Булево - Указание к необходимости подменять все шрифты.
//                                    Если не указан, то берется значение из пользовательских настроек.
//  ЗаменитьСтиль - Булево - Указание к необходимости заменять стиль v8doc-style в тексте,
//                           если он уже существует.
//
Процедура ПрименитьНастройкиОтображениеПисьма(ТекстHTML, ШрифтОтображения = Неопределено,
	ОтображатьДругиеШрифты = Неопределено, ЗаменитьСтиль = Ложь,
	ДляКарточкиВходящегоПисьма = Ложь) Экспорт
	
	НРегТекстHTML = НРег(ТекстHTML);
	
	// Если уже есть стиль v8doc-style, то не добавлять его еще раз.
	Если Не ЗаменитьСтиль И СтрНайти(НРегТекстHTML, "v8doc-style") <> 0 Тогда
		Возврат;
	КонецЕсли;
	
	ОписаниеСтиля = ПолучитьОписаниеСтиля(ШрифтОтображения, ОтображатьДругиеШрифты, ДляКарточкиВходящегоПисьма);
	Если ЗначениеЗаполнено(ОписаниеСтиля) Тогда
		
		Если ЗаменитьСтиль И СтрНайти(НРегТекстHTML, "v8doc-style") <> 0 Тогда
			
			// Удаляем уже существующие теги стиля v8doc-style
			ТегStyle = ПолучитьТегВТекстеHTML(ТекстHTML, "style");
			
			Пока ЗаполненаСтруктураТега(ТегStyle) <> 0 Цикл
				
				СвойствоClass = ПолучитьЗначениеПараметраТега(ТегStyle, "class");
				Если НРег(СвойствоClass) = "v8doc-style" Тогда
					ТекстHTML = 
						Лев(ТекстHTML, ТегStyle.ПозицияНачалаТега - 1) + Сред(ТекстHTML, ТегStyle.ПозицияОкончанияТега + 1);
					ТегStyle = ПолучитьТегВТекстеHTML(ТекстHTML, "style", ТегStyle.ПозицияНачалаТега);
					Продолжить;
				КонецЕсли;
				
				ТегStyle = ПолучитьТегВТекстеHTML(ТекстHTML, "style", ТегStyle.ПозицияОкончанияТега + 1);
				
			КонецЦикла;
			
		КонецЕсли;
		
		ДобавитьВТегHead(ТекстHTML, ОписаниеСтиля);
		
	КонецЕсли;
	
КонецПроцедуры

// В случае отстутствия у текста HTML тэгов <html></html>,  <body></body> добавляет их.
// Модифицирует параметр ТекстHTML
//
Процедура ДобавитьНеобходимыеТэгиHTML(ТекстHTML) Экспорт
	
	НРегТекстHTML = НРег(ТекстHTML);
	ПозицияТэгаHTML = Найти(НРегТекстHTML, "<html");
	ПозицияТэгаBODY = Найти(НРегТекстHTML, "<body");
	Если ПозицияТэгаHTML = 0 И ПозицияТэгаBODY = 0 Тогда
		ТекстHTML = "<html><body style=""margin-top:1px; padding-top:1px"">" + ТекстHTML + "</body></html>";
	ИначеЕсли ПозицияТэгаHTML = 0 И ПозицияТэгаBODY > 0 Тогда
		ТекстHTML = "<html>" + ТекстHTML + "</html>";
	ИначеЕсли ПозицияТэгаHTML > 0 И ПозицияТэгаBODY = 0 Тогда
		ПозицияОкончанияТэгаHTML = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, ">", ПозицияТэгаHTML);
		Голова = Лев(ТекстHTML, ПозицияОкончанияТэгаHTML);
		ПозицияЗакрывающегосяТэгаHTML = Найти(НРегТекстHTML, "</html>");
		Хвост = Сред(ТекстHTML, ПозицияЗакрывающегосяТэгаHTML);
		Середина = Сред(ТекстHTML, ПозицияОкончанияТэгаHTML + 1, ПозицияЗакрывающегосяТэгаHTML - ПозицияОкончанияТэгаHTML - 1);
		ТекстHTML = Голова + "<body style=""margin-top:1px; padding-top:1px"">" + Середина + "</body>" + Хвост;
	КонецЕсли;
	
КонецПроцедуры

// При работе с веб сервером вставляет картинки письма в тело HTML,
// иначе помещает их во временное хранилище и заменяет ссылки на временное хранилище.
//
// Параметры
//  ТекстHTML - html текст - тела письма - входной и выходной параметр (туда же и пишутся изменения)
//  Письмо - ссылка на письмо (вх или исх)
//  УникальныйИдентификаторФормы - идентификатор формы
//  ИдентификаторыКартинокИсходящегоПисьма - список значений, в нем структуры "ИсточникФайла, НавигационнаяСсылка"
//      ИсточникФайла - это "id" в теге <img src=id....
//		НавигационнаяСсылка - навигационная ссылка на картинку у нас во временном хранилище
//
Процедура ВставитьКартинкиВТекстHTML(
	ТекстHTML,
	Картинки,
	УникальныйИдентификаторФормы) Экспорт
	
	Для Каждого ФайлПисьма Из Картинки Цикл 
		
		ИсточникФайла = ФайлПисьма.Идентификатор;
		
		Если СтрЧислоВхождений(ТекстHTML, ИсточникФайла) > 0 Тогда
			
			ДвоичныеДанныеФайла = ПолучитьИзВременногоХранилища(ФайлПисьма.Адрес);
			
			Расширение = ФайлПисьма.Расширение;
			
			Если ПустаяСтрока(Расширение) Тогда
				Картинка = Новый Картинка(ДвоичныеДанныеФайла);
				Расширение = Строка(Картинка.Формат());
			КонецЕсли;
			
			СтрокаИсточника = "data:image/" + Расширение + ";base64," + Base64Строка(ДвоичныеДанныеФайла);
			ТекстHTML = СтрЗаменить(ТекстHTML, "cid:" + ИсточникФайла, СтрокаИсточника);
			ТекстHTML = СтрЗаменить(ТекстHTML, "CID:" + ИсточникФайла, СтрокаИсточника);
			Если СтрДлина(ИсточникФайла) > 18 Тогда
				ТекстHTML = СтрЗаменить(ТекстHTML, ИсточникФайла, СтрокаИсточника);
			КонецЕсли;	
			
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры

// Удаляет теги IMG из тела письма
Процедура УдалитьВложенныеКартинки(ТекстПисьмаHTML) Экспорт
	
	ИмяТега  = "img";
	
	НРегТекстHTML = НРег(ТекстПисьмаHTML);
	ПозицияОкончанияТегаHTML = 0;
	ПозицияОкончанияТегаHTMLПредыдущая = 0;
	
	Пока РаботаСоСтроками.НайтиПосле(НРегТекстHTML, "<" + ИмяТега , ПозицияОкончанияТегаHTML) <> 0 Цикл
		
		ПозицияОкончанияТегаHTMLПредыдущая = ПозицияОкончанияТегаHTML;
		
		ПозицияНачалаТегаHTML = Найти(НРегТекстHTML, "<" + ИмяТега);
		ПозицияОкончанияТегаHTML = 0;
		Если ПозицияНачалаТегаHTML > 0 Тогда
			ПозицияОкончанияТегаHTML = РаботаСоСтроками.НайтиПосле(НРегТекстHTML, ">", ПозицияНачалаТегаHTML);
		КонецЕсли;
		
		Если ПозицияНачалаТегаHTML <> 0 И ПозицияОкончанияТегаHTML <> 0 Тогда
			
			СодержимоеТега = Сред(ТекстПисьмаHTML, ПозицияНачалаТегаHTML, 
				ПозицияОкончанияТегаHTML - ПозицияНачалаТегаHTML);
			
			// удаляем только если в теге IMG есть src=cid 
			Если СтрНайти(СодержимоеТега, "src=""cid")
				Или СтрНайти(СодержимоеТега, "src=cid") Тогда
			
				ТекстПисьмаHTML = Лев(ТекстПисьмаHTML, ПозицияНачалаТегаHTML - 1) 
					+ Сред(ТекстПисьмаHTML, ПозицияОкончанияТегаHTML + 1);
				НРегТекстHTML = НРег(ТекстПисьмаHTML);
				
			КонецЕсли;		
			
		Иначе
			Возврат;	
		КонецЕсли;		
		
		// зацикливание
		Если ПозицияОкончанияТегаHTMLПредыдущая = ПозицияОкончанияТегаHTML Тогда
			Возврат;	
		КонецЕсли;		
		
	КонецЦикла;	
	
КонецПроцедуры	

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЗаменитьСпецСимволHTML(Строка, КодСимвола, ИмяСимвола)
	
	Строка = СтрЗаменить(Строка, Символ(КодСимвола), "&" + ИмяСимвола + ";");
	
КонецПроцедуры

Процедура ЗаменитьТабуляцииИПробелы(Строка)
	
	Строка = СтрЗаменить(Строка, Символы.ВТаб, "    ");
	Строка = СтрЗаменить(Строка, Символы.Таб, "    ");
	Строка = СтрЗаменить(Строка, "  ", Символы.НПП + " ");
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	
КонецПроцедуры

Процедура ЗаменитьУправляющиеСимволы(Строка)
	
	Текст = СтрЗаменить(Текст, Символы.ВК + Символы.ПС, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(7), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(8), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символы.ВТаб, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(12), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символы.ВК, Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(14), Символы.ПС);
	Текст = СтрЗаменить(Текст, Символ(28), " ");
	Текст = СтрЗаменить(Текст, Символ(29), " ");
	Текст = СтрЗаменить(Текст, Символ(30), " ");
	
КонецПроцедуры

Процедура УдалитьТегиИзЭлементаHTML(ЭлементHTML, Тег)
	
	Для каждого Узел Из ЭлементHTML.ДочерниеУзлы Цикл
		Если НРег(Узел.ИмяУзла) = НРег(Тег) Тогда
			ЭлементHTML.УдалитьДочерний(Узел);
		Иначе
			// Рекурсия
			УдалитьТегиИзЭлементаHTML(Узел, Тег);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет теги ко всем ссылкам, находящимся в строке.
//
Процедура ДобавитьТегиКСсылкамСоСхемой(
	ТекстHTML,
	Схема,
	НовоеЗначениеСхемы = "")
	
	СхемаПоиска = НРег(Схема);
	ТекстHTMLПоиска = НРег(ТекстHTML);
	Длина = СтрДлина(ТекстHTML);
	
	НоваяСтрока = "";
	НазваниеЭлементаСсылки = "a";
	Смещение = 0;
	
	ЯвляетсяТегомЯкоря = Ложь;
	КонецТега = ">";
	ДлинаКонцаТега = СтрДлина(КонецТега);
	
	ЗакрывающийТегЯкоря = "</a>";
	ДлинаЗакрывающегоТегаЯкоря = СтрДлина(ЗакрывающийТегЯкоря);
	
	НачалоСсылки = РаботаСоСтроками.НайтиПосле(ТекстHTMLПоиска, СхемаПоиска);
	СписокОграничителейURI = РаботаС_HTMLПовтИсп.СписокОграничителейURI();
	
	Пока НачалоСсылки <> 0 Цикл
		
		// Проверять что позиция не в параметрах какого-либо тега
		Если ПозицияНаходитсяВПараметреТега(ТекстHTMLПоиска, НачалоСсылки, НазваниеЭлементаСсылки, ЯвляетсяТегомЯкоря) Тогда
			
			ПозицияОкончанияОткрывающегоТега = 0;
			
			Если ЯвляетсяТегомЯкоря Тогда
				
				// Если тег является якорем - ищем 
				ПозицияОкончанияОткрывающегоТега = РаботаСоСтроками.НайтиПосле(ТекстHTMLПоиска, ЗакрывающийТегЯкоря, НачалоСсылки);
				ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + ДлинаЗакрывающегоТегаЯкоря;
				ДлинаСмещения = ДлинаЗакрывающегоТегаЯкоря;
				
			КонецЕсли;
			
			Если ПозицияОкончанияОткрывающегоТега = 0 Тогда
				
				ПозицияОкончанияОткрывающегоТега = РаботаСоСтроками.НайтиПосле(ТекстHTMLПоиска, КонецТега, НачалоСсылки);
				
				Если ПозицияОкончанияОткрывающегоТега = 0 Тогда
					
					// Если нет окончания тега - не выделяем больше ссылок
					Прервать;
					
				КонецЕсли;
				
				ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + ДлинаКонцаТега;
				ДлинаСмещения = ДлинаКонцаТега;
				
			КонецЕсли;
			
			// Если есть окончание тега - выделяем ссылки после тега
			Смещение = Смещение + (ПозицияОкончанияОткрывающегоТега - 1);
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, ПозицияОкончанияОткрывающегоТега);
			НачалоСсылки = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
			
			Продолжить;
			
		КонецЕсли;
		
		Если ПозицияНаходитсяВТеге(ТекстHTMLПоиска, НазваниеЭлементаСсылки, НачалоСсылки) Тогда
			
			ПозицияЗакрывающегоТегаЯкоря = РаботаСоСтроками.НайтиПосле(ТекстHTMLПоиска, ЗакрывающийТегЯкоря, НачалоСсылки);
			Если ПозицияЗакрывающегоТегаЯкоря = 0 Тогда
				
				// Если нет закрывающего "якорь" тега - не выделяем больше ссылок
				Прервать;
				
			КонецЕсли;
			
			ПозицияЗакрывающегоТегаЯкоря = ПозицияЗакрывающегоТегаЯкоря + ДлинаЗакрывающегоТегаЯкоря;
			// Если есть закрывающий "якорь" тег - выделяем ссылки после закрывающего тега
			Смещение = Смещение + (ПозицияЗакрывающегоТегаЯкоря - 1);
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, ПозицияЗакрывающегоТегаЯкоря);
			НачалоСсылки = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
			
			Продолжить;
			
		КонецЕсли;
		
		Если НачалоСсылки = 1 Тогда
			
			СимволПередСсылкой = "";
			
		Иначе
			
			СимволПередСсылкой = Сред(ТекстHTMLПоиска, НачалоСсылки - 1, 1);
			
			Если СимволПередСсылкой = ";" Тогда
				ЗакодированныеКавычки = "&quot;";
				ДлинаКавычек = СтрДлина(ЗакодированныеКавычки);
				Если НачалоСсылки - ДлинаКавычек > 0 Тогда
					ВозможныеКавычки = Сред(ТекстHTMLПоиска, НачалоСсылки - ДлинаКавычек, ДлинаКавычек);
					Если ВозможныеКавычки = ЗакодированныеКавычки Тогда
						СимволПередСсылкой = ЗакодированныеКавычки;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если СписокОграничителейURI.НайтиПоЗначению(СимволПередСсылкой) <> Неопределено Тогда
				
				СимволПередСсылкой = "";
				
			ИначеЕсли СимволПередСсылкой = ">" Тогда
				
				// Тег перед ссылкой
				СимволПередСсылкой = "";
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПустаяСтрока(СимволПередСсылкой) Тогда
			
			КонецСсылки = НайтиКонецСсылки(ТекстHTMLПоиска, НачалоСсылки + СтрДлина(СхемаПоиска), СписокОграничителейURI);
			
			// Добавляем теги к оригинальному тексту, т.к. текст поиска в нижнем регистре
			ДобавитьТегСсылки(
				ТекстHTML,
				НачалоСсылки,
				КонецСсылки,
				Схема,
				НовоеЗначениеСхемы,
				Смещение);
			
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, КонецСсылки + 1);
			НачалоСсылки = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
			
			Продолжить;
			
		ИначеЕсли СимволПередСсылкой = """" ИЛИ СимволПередСсылкой = "&quot;" Тогда
			
			СимволКонцаСсылки = """";
			КонецСсылки = НайтиКонецСсылки(ТекстHTMLПоиска, НачалоСсылки + СтрДлина(СхемаПоиска), СписокОграничителейURI, Истина, СимволКонцаСсылки);
			
			// Добавляем теги к оригинальному тексту, т.к. текст поиска в нижнем регистре
			ДобавитьТегСсылки(
				ТекстHTML,
				НачалоСсылки - СтрДлина(СимволПередСсылкой), // Включаем открывающие кавычки в ссылку
				КонецСсылки,
				Схема,
				НовоеЗначениеСхемы,
				Смещение,
				Истина,
				СимволПередСсылкой,
				СимволКонцаСсылки);
			
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, КонецСсылки + 1);
			НачалоСсылки = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
			
			Продолжить;
			
		КонецЕсли;
		
		Смещение = Смещение + НачалоСсылки;
		ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, НачалоСсылки + 1);
		НачалоСсылки = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает позицию конца ссылки в строке - первый незначащий символ
Функция НайтиКонецСсылки(ТекстHTML, НачальнаяПозиция, СписокНезначащихСимволов,
	РазрешитьПробелВСсылке = Ложь, СимволКонцаСсылки = Неопределено)
	
	ДопустимыеВURIСпецСимволы = РаботаС_HTMLПовтИсп.ДопустимыеВURIСпецСимволы();
	ЗначимыеВURIСпецСимволы = РаботаС_HTMLПовтИсп.ЗначимыеВURIСпецСимволы();
	ОбратноеСоответствиеСпецСимволов = РаботаС_HTMLПовтИсп.ПолучитьОбратноеСоответствиеСпецСимволов();
	СписокДопустимыхВСсылкеТегов = РаботаС_HTMLПовтИсп.СписокДопустимыхВСсылкеТегов();
	СписокОткрывающихСкобок = РаботаС_HTMLПовтИсп.СписокОткрывающихСкобок();
	СписокЗакрывающихСкобок = РаботаС_HTMLПовтИсп.СписокЗакрывающихСкобок();
	СоответствиеОткрывающихСкобок = РаботаС_HTMLПовтИсп.СоответствиеОткрывающихСкобок();
	
	ОткрытыеСкобки = Новый Соответствие;
	Для Каждого ОткрывающаяСкобка Из СписокОткрывающихСкобок Цикл
		ОткрытыеСкобки[ОткрывающаяСкобка.Значение] = 0;
	КонецЦикла;
	
	НайденНезначащийСимвол = Ложь;
	ОбрабатываемаяСтрока = Сред(ТекстHTML, НачальнаяПозиция);
	ПоложениеПервогоНеЗначащегоСимвола = 0;
	
	Пока Не НайденНезначащийСимвол Цикл
		
		ПервыйСимвол = Лев(ОбрабатываемаяСтрока, 1);
		
		Если ЗначениеЗаполнено(СимволКонцаСсылки) И ПервыйСимвол = СимволКонцаСсылки Тогда
			
			НайденНезначащийСимвол = Истина;
			ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + 1;
			Прервать;
			
		ИначеЕсли ЗначениеЗаполнено(СимволКонцаСсылки) И ПервыйСимвол = "&" Тогда
			
			ВозможныйСпецСимвол = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			СпецСимвол = ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол);
			Если СпецСимвол <> Неопределено И Символ(СпецСимвол) = СимволКонцаСсылки Тогда
				НайденНезначащийСимвол = Истина;
				СимволКонцаСсылки = "&" + ВозможныйСпецСимвол + ";";
				ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + СтрДлина(СимволКонцаСсылки);
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПервыйСимвол = "&" Тогда
			
			ВозможныйСпецСимвол = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			ДлинаВозможногоСпецСимвола = СтрДлина(ВозможныйСпецСимвол);
			
			Если СписокЗакрывающихСкобок.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				ОткрывающаяСкобка = СоответствиеОткрывающихСкобок[ВозможныйСпецСимвол];
				Если ОткрытыеСкобки[ОткрывающаяСкобка] > 0 Тогда
					ОткрытыеСкобки[ОткрывающаяСкобка] = ОткрытыеСкобки[ОткрывающаяСкобка] - 1;
					ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
					ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + ДлинаВозможногоСпецСимвола + 2;
					Продолжить;
				КонецЕсли;
				
			ИначеЕсли ЗначимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				Если СписокОткрывающихСкобок.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
					ОткрытыеСкобки[ВозможныйСпецСимвол] = ОткрытыеСкобки[ВозможныйСпецСимвол] + 1;
				КонецЕсли;
				
				ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
				ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + ДлинаВозможногоСпецСимвола + 2;
				Продолжить;
				
			ИначеЕсли ДопустимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				ЕстьЗначимыйСимволДоКонцаСсылки = ЕстьЗначимыйСимволДоКонцаСсылки(
					ОбрабатываемаяСтрока,
					СписокНезначащихСимволов,
					РазрешитьПробелВСсылке,
					ДлинаВозможногоСпецСимвола + 2);
				
				Если ЕстьЗначимыйСимволДоКонцаСсылки Тогда
					
					Если СписокОткрывающихСкобок.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
						ОткрытыеСкобки[ВозможныйСпецСимвол] = ОткрытыеСкобки[ВозможныйСпецСимвол] + 1;
					КонецЕсли;
					
					ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
					ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + ДлинаВозможногоСпецСимвола + 2;
					Продолжить;
					
				Иначе
					
					ПервыйСимвол = "";
					
				КонецЕсли;
				
			ИначеЕсли ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				ПервыйСимвол = "";
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПервыйСимвол = "<" Тогда
			
			СтруктураТега = ПолучитьТегВТекстеHTML(ОбрабатываемаяСтрока);
			Если ЗаполненаСтруктураТега(СтруктураТега) Тогда
				
				Если СтруктураТега.ПозицияНачалаОткрывающегоТега = 1 Тогда
					
					Если ТегСодержитсяВСписке(СтруктураТега, СписокДопустимыхВСсылкеТегов) Тогда
						
						ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);
						ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + СтруктураТега.ПозицияОкончанияОткрывающегоТега;
						Продолжить;
						
					Иначе
						
						ПервыйСимвол = "";
						
					КонецЕсли;
					
				Иначе
					
					ПервыйСимвол = "";
					
				КонецЕсли;
				
			Иначе
				
				ПервыйСимвол = "";
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если СписокЗакрывающихСкобок.НайтиПоЗначению(ПервыйСимвол) <> Неопределено Тогда
			ОткрывающаяСкобка = СоответствиеОткрывающихСкобок[ПервыйСимвол];
			Если ОткрытыеСкобки[ОткрывающаяСкобка] > 0 Тогда
				ОткрытыеСкобки[ОткрывающаяСкобка] = ОткрытыеСкобки[ОткрывающаяСкобка] - 1;
				ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
				ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + 1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Если СписокНезначащихСимволов.НайтиПоЗначению(ПервыйСимвол) <> Неопределено 
			И Не ЕстьЗначимыйСимволДоКонцаСсылки(ОбрабатываемаяСтрока, СписокНезначащихСимволов, РазрешитьПробелВСсылке) Тогда
			
			ПервыйСимвол = "";
			
		КонецЕсли;
		
		Если ПервыйСимвол = " " И РазрешитьПробелВСсылке Тогда
			
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
			ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + 1;
			Продолжить;
			
		КонецЕсли;
		
		Если ПустаяСтрока(ПервыйСимвол) Тогда
			
			НайденНезначащийСимвол = Истина;
			Прервать;
			
		КонецЕсли;
		
		Если СписокОткрывающихСкобок.НайтиПоЗначению(ПервыйСимвол) <> Неопределено Тогда
			ОткрытыеСкобки[ПервыйСимвол] = ОткрытыеСкобки[ПервыйСимвол] + 1;
		КонецЕсли;
		
		ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
		ПоложениеПервогоНеЗначащегоСимвола = ПоложениеПервогоНеЗначащегоСимвола + 1;
		
	КонецЦикла;
	
	// Если не был найден не значащий символ - все равно возвращаем позицию конца строки.
	Возврат НачальнаяПозиция + ПоложениеПервогоНеЗначащегоСимвола;
	
КонецФункции

// Добавляет тег в конкретную позицию. Меняет значение Строка и Смещение.
Процедура ДобавитьТегСсылки(
	Строка,
	НачальнаяПозиция,
	КонечнаяПозиция,
	Схема,
	НовоеЗначениеСхемы,
	Смещение,
	ОбрезатьГраничныеСимволыСсылки = Ложь,
	СимволПередСсылкой = "",
	СимволКонцаСсылки = "")
	
	НачалоСтроки = Лев(Строка, Смещение + НачальнаяПозиция - 1);
	
	// Обрезание граничных символов
	Если ОбрезатьГраничныеСимволыСсылки Тогда
		Ссылка = Сред(Строка,
			Смещение + НачальнаяПозиция + СтрДлина(СимволПередСсылкой),
			КонечнаяПозиция - НачальнаяПозиция - СтрДлина(СимволПередСсылкой) - СтрДлина(СимволКонцаСсылки));
	Иначе
		Ссылка = Сред(Строка, Смещение + НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция);
	КонецЕсли;
	
	КонецСтроки = Прав(Строка, СтрДлина(Строка) - (Смещение + КонечнаяПозиция - 1));
	
	СсылкаСТегом = СформироватьСсылкуСТегом(Ссылка, Схема, НовоеЗначениеСхемы);
	
	Строка = НачалоСтроки + СсылкаСТегом + КонецСтроки;
	Смещение = СтрДлина(НачалоСтроки + СсылкаСТегом) + 1;
	
КонецПроцедуры

// Проверяет наличие значащего символа до конца ссылки. 
// Концом ссылки считаются стандартные незначащие символы.
Функция ЕстьЗначимыйСимволДоКонцаСсылки(Строка, СписокНезначащихСимволов,
	РазрешитьПробелВСсылке = Ложь, НачальнаяПозиция = 0)
	
	ОбратноеСоответствиеСпецСимволов = РаботаС_HTMLПовтИсп.ПолучитьОбратноеСоответствиеСпецСимволов();
	ДопустимыеВURIСпецСимволы = РаботаС_HTMLПовтИсп.ДопустимыеВURIСпецСимволы();
	ЗначимыеВURIСпецСимволы = РаботаС_HTMLПовтИсп.ЗначимыеВURIСпецСимволы();
	СписокДопустимыхВСсылкеТегов = РаботаС_HTMLПовтИсп.СписокДопустимыхВСсылкеТегов();
	
	ОбрабатываемаяСтрока = Сред(Строка, НачальнаяПозиция + 1);
	НайденЗначащийСимвол = Ложь;
	
	Итерация = 0;
	ГлубинаАнализа = 50;
	Пока Не НайденЗначащийСимвол Цикл
		
		Итерация = Итерация + 1;
		Если Итерация > ГлубинаАнализа Тогда
			Прервать;
		КонецЕсли;
		
		ПервыйСимвол = Лев(ОбрабатываемаяСтрока, 1);
		
		Если ПервыйСимвол = " " И РазрешитьПробелВСсылке Тогда
			
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
			
		ИначеЕсли ПустаяСтрока(ПервыйСимвол) Тогда
			
			Прервать;
			
		ИначеЕсли ПервыйСимвол = "&" Тогда
			
			ВозможныйСпецСимвол = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			ДлинаВозможногоСпецСимвола = СтрДлина(ВозможныйСпецСимвол);
			
			Если ЗначимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				НайденЗначащийСимвол = Истина;
				
			ИначеЕсли ДопустимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено
				ИЛИ ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол) <> Неопределено Тогда
				
				ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
				
			Иначе
				
				НайденЗначащийСимвол = Истина;
				
			КонецЕсли;
			
			
		ИначеЕсли ПервыйСимвол = "<" Тогда
			
			СтруктураТега = ПолучитьТегВТекстеHTML(ОбрабатываемаяСтрока);
			Если ЗаполненаСтруктураТега(СтруктураТега) Тогда
				
				Если СтруктураТега.ПозицияНачалаОткрывающегоТега = 1 Тогда
					
					Если ТегСодержитсяВСписке(СтруктураТега, СписокДопустимыхВСсылкеТегов) Тогда
						
						ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);
						Продолжить;
						
					Иначе
						Прервать;
					КонецЕсли;
					
				Иначе
					Прервать;
				КонецЕсли;
				
			Иначе
				Прервать;
			КонецЕсли;
			
		ИначеЕсли СписокНезначащихСимволов.НайтиПоЗначению(ПервыйСимвол) <> Неопределено Тогда
			
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
			
		Иначе
			
			НайденЗначащийСимвол = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НайденЗначащийСимвол;
	
КонецФункции

// Возвращает спецсимвол HTML (&СпецСимвол;), если он присутствует.
// Возвращает Неопределено, если нет возможных спецсимволов.
Функция ПолучитьВозможныйСпецСимвол(Строка, ПозицияСпецСимвола = 0)
	
	ОбрабатываемаяСтрока = Сред(Строка, ПозицияСпецСимвола + 1);
	ПервыйСимвол = Лев(ОбрабатываемаяСтрока, 1);
	
	Если ПервыйСимвол = "&" Тогда
		
		КонецСпецСимвола = СтрНайти(ОбрабатываемаяСтрока, ";");
		
		Если КонецСпецСимвола <> 0 Тогда
			
			СпецСимвол = Сред(ОбрабатываемаяСтрока, 2, КонецСпецСимвола - 2);
			
			Возврат СпецСимвол;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает структуру первого тега данного элемента в тексте HTML.
// Если не указано название элемента то возвращает первый встреченный тег.
// Поиск тега ведется с переданной начальной позиции
//  Структура тега: 
//		НазваниеЭлемента - название элемента найденного тега
//		ПараметрыОткрывающегоТега - строка, содержащая параметры открывающего тега
//		Содержание - стока, содержащие данные, находящие между открывающим и закрывающим тегом
//		ПозицияНачалаОткрывающегоТега - позиция символа "<" открывающего тега
//		ПозицияОкончанияОткрывающегоТега - позиция символа ">" открывающего тега
//		ПозицияНачалаЗакрывающегоТега - позиция символа "<" закрывающего тега
//		ПозицияОкончанияЗакрывающегоТега - позиция символа ">" закрывающего тега
//		ПозицияНачалаТега - позиция символа "<" открывающего тега
//		ПозицияОкончанияТега - если есть закрывающий тег, то позиция символа ">" закрывающего тега
//							   если нет закрывающего тега, то позиция символа ">" открывающего тега
//
Функция ПолучитьТегВТекстеHTML(ТекстHTML, НазваниеЭлемента = "", НачальнаяПозиция = 1)
	
	// Определение первого тега
	Если Не ЗначениеЗаполнено(НазваниеЭлемента) Тогда
		
		НачалоОткрывающегоТега = "<";
		НазваниеТега = "";
		
		ОбрабатываемыйТекстHTML = ТекстHTML;
		
		ПозицияНачалаОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
		Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл
			
			ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, ПозицияНачалаОткрывающегоТега + 1);
			ПервыйСимволНазванияТега = Лев(ОбрабатываемыйТекстHTML, 1);
			
			Если ЗначениеЗаполнено(ПервыйСимволНазванияТега) Тогда
				
				ОчереднойСимволНазванияТега = ПервыйСимволНазванияТега;
				
				Пока ЗначениеЗаполнено(ОчереднойСимволНазванияТега)
					И ОчереднойСимволНазванияТега <> ">" Цикл
					
					НазваниеТега = НазваниеТега + ОчереднойСимволНазванияТега;
					ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, 2);
					ОчереднойСимволНазванияТега = Лев(ОбрабатываемыйТекстHTML, 1);
					
				КонецЦикла;
				
				ПозицияНачалаОткрывающегоТега = 0;
				
			Иначе
				
				ПозицияНачалаОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ЗначениеЗаполнено(НазваниеТега) Тогда
			
			НазваниеЭлемента = НазваниеТега;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если НазваниеЭлемента = "blockquote" Тогда
		РазрешитьВложенныеТеги = Истина;
	Иначе
		РазрешитьВложенныеТеги = Ложь;
	КонецЕсли;
	
	НачалоОткрывающегоТега = "<" + НРег(НазваниеЭлемента);
	КонецОткрывающегоТега = ">";
	ЗакрывающийТег = "</" + НРег(НазваниеЭлемента) + ">";
	ОбрабатываемыйТекстHTML = НРег(Сред(ТекстHTML, НачальнаяПозиция));
	Смещение = НачальнаяПозиция - 1;
	
	СтруктураТега = СформироватьСтруктуруТега();
	СтруктураТега.НазваниеЭлемента = НазваниеЭлемента;
	
	ПозицияНачалаОткрывающегоТега = ПолучитьПозициюНачалаОткрывающегоТега(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
	Если ПозицияНачалаОткрывающегоТега = 0 Тогда
		// Если нет начала открывающего тега, то тега нет
		Возврат СтруктураТега;
	КонецЕсли;
	ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, ПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега));
	Смещение = Смещение + ПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега) - 1;
	
	ПозицияОкончанияОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, КонецОткрывающегоТега);
	Если ПозицияОкончанияОткрывающегоТега = 0 Тогда
		// Если нет окончания открывающего тега, то тега нет
		Возврат СтруктураТега;
	КонецЕсли;
	ПараметрыОткрывающегоТега = Сред(ТекстHTML, Смещение + 1, ПозицияОкончанияОткрывающегоТега - 1);
	ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, ПозицияОкончанияОткрывающегоТега + СтрДлина(КонецОткрывающегоТега));
	Смещение = Смещение + ПозицияОкончанияОткрывающегоТега + СтрДлина(КонецОткрывающегоТега) - 1;
	
	Если РазрешитьВложенныеТеги Тогда
		
		ПозицияНачалаЗакрывающегоТега = 0;
		КоличествоОткрытыхТегов = 1;
		Пока КоличествоОткрытыхТегов > 0 Цикл
			
			БлижайшийЗакрывающийТег = СтрНайти(ОбрабатываемыйТекстHTML, ЗакрывающийТег);
			Если БлижайшийЗакрывающийТег = 0 Тогда
				// Нет больше тегов.
				Прервать;
			КонецЕсли;
			
			БлижайшийОткрывающийТег = ПолучитьПозициюНачалаОткрывающегоТега(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
			Если БлижайшийОткрывающийТег = 0 Или БлижайшийЗакрывающийТег < БлижайшийОткрывающийТег Тогда
				
				// Найден закрывающий тег
				КоличествоОткрытыхТегов = КоличествоОткрытыхТегов - 1;
				ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + БлижайшийЗакрывающийТег + СтрДлина(ЗакрывающийТег) - 1;
				
				ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, БлижайшийЗакрывающийТег + СтрДлина(ЗакрывающийТег));
				
			Иначе
				
				// Найден открывающий тег
				КоличествоОткрытыхТегов = КоличествоОткрытыхТегов + 1;
				ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + БлижайшийОткрывающийТег + СтрДлина(НачалоОткрывающегоТега) - 1;
				ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, БлижайшийОткрывающийТег + СтрДлина(НачалоОткрывающегоТега));
				
				БлижайшееОкончаниеОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, КонецОткрывающегоТега);
				Если ПозицияОкончанияОткрывающегоТега = 0 Тогда
					// Если нет окончания открывающего тега, то тега нет
					Прервать;
				КонецЕсли;
				ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + БлижайшееОкончаниеОткрывающегоТега + СтрДлина(КонецОткрывающегоТега) - 1;
				ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, БлижайшееОкончаниеОткрывающегоТега + СтрДлина(КонецОткрывающегоТега));
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если КоличествоОткрытыхТегов <> 0 Тогда
			ПозицияНачалаЗакрывающегоТега = 0;
		Иначе
			ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега - СтрДлина(ЗакрывающийТег) + 1;
		КонецЕсли;
		
	Иначе
		
		ПозицияНачалаЗакрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, ЗакрывающийТег);
		
	КонецЕсли;
	
	// Заполнение позиций в тексте HTML и содержания.
	ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТега + (НачальнаяПозиция - 1);
	ПозицияНачалаТега = ПозицияНачалаОткрывающегоТега;
	ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + (СтрДлина(НачалоОткрывающегоТега) - 1) + ПозицияНачалаОткрывающегоТега;
	Если ПозицияНачалаЗакрывающегоТега <> 0 Тогда
		Содержание = Сред(ТекстHTML, Смещение + 1, ПозицияНачалаЗакрывающегоТега - 1);
		ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + ПозицияОкончанияОткрывающегоТега;
		ПозицияОкончанияЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + (СтрДлина(ЗакрывающийТег) - 1);
	Иначе
		Содержание = "";
		ПозицияОкончанияЗакрывающегоТега = 0;
	КонецЕсли;
	Если ПозицияОкончанияЗакрывающегоТега <> 0 Тогда
		ПозицияОкончанияТега = ПозицияОкончанияЗакрывающегоТега;
	Иначе
		ПозицияОкончанияТега = ПозицияОкончанияОткрывающегоТега;
	КонецЕсли;
	
	// Заполнение структуры тега
	СтруктураТега.ПараметрыОткрывающегоТега = ПараметрыОткрывающегоТега;
	СтруктураТега.Содержание = Содержание;
	СтруктураТега.ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТега;
	СтруктураТега.ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега;
	СтруктураТега.ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега;
	СтруктураТега.ПозицияОкончанияЗакрывающегоТега = ПозицияОкончанияЗакрывающегоТега;
	СтруктураТега.ПозицияНачалаТега = ПозицияНачалаТега;
	СтруктураТега.ПозицияОкончанияТега = ПозицияОкончанияТега;
	СтруктураТега.НазваниеЭлемента = НазваниеЭлемента;
	
	Возврат СтруктураТега;
	
КонецФункции

// Проверяет наличие название элемента тега в списке значений
Функция ТегСодержитсяВСписке(СтруктураТега, СписокЗначений)
	
	Если Не ЗаполненаСтруктураТега(СтруктураТега) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	НазваниеЭлемента = НРег(СтруктураТега.НазваниеЭлемента);
	
	Для Каждого ЭлементСписка Из СписокЗначений Цикл
		
		ЗначениеЭлементаСписка = ЭлементСписка.Значение;
		Если ТипЗнч(ЗначениеЭлементаСписка) = Тип("Строка") Тогда
			
			ЗначениеЭлементаСписка = НРег(ЗначениеЭлементаСписка);
			ЗначениеЗакрывающегоЭлементаСписка = "/" + ЗначениеЭлементаСписка;
			
			Если НазваниеЭлемента = ЗначениеЭлементаСписка
				ИЛИ НазваниеЭлемента = ЗначениеЗакрывающегоЭлементаСписка Тогда
				
				Возврат Истина;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет заполненность структуры тега: 
// - наличие всех необходимых тегу свойств в структуре;
// - заполненность позиции начала и окончания тега.
Функция ЗаполненаСтруктураТега(СтруктураТега)
	
	Если (Не СтруктураТега.Свойство("НазваниеЭлемента"))
		ИЛИ (Не СтруктураТега.Свойство("ПараметрыОткрывающегоТега"))
		ИЛИ (Не СтруктураТега.Свойство("Содержание"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияНачалаОткрывающегоТега"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияОкончанияОткрывающегоТега"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияНачалаЗакрывающегоТега"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияОкончанияЗакрывающегоТега"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияНачалаТега"))
		ИЛИ (Не СтруктураТега.Свойство("ПозицияОкончанияТега"))  Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураТега.ПозицияНачалаТега)
		И ЗначениеЗаполнено(СтруктураТега.ПозицияОкончанияТега) Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет нахождение внутри параметров открывающего тега (возможно, который не закрыт)
Функция ПозицияНаходитсяВПараметреТега(ТекстHTML, Позиция, НужныйТег = "", ЯвляетсяНужнымТегом = Ложь)
	
	НачалоТега = "<";
	КонецТега = ">";
	ОткрытТег = Ложь;
	ЯвляетсяНужнымТегом = Ложь;
	
	НачалоТекстаHTML = Лев(НРег(ТекстHTML), Позиция - 1);
	НайденнаяПозицияНачалаОткрывающегоТега = 0;
	ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоТега);
	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл
		
		НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияНачалаОткрывающегоТега + 1);
		ПервыйСимволНазванияТега = Сред(НачалоТекстаHTML, 1, 1);
		
		Если ЗначениеЗаполнено(ПервыйСимволНазванияТега) Тогда
			
			ПозицияОкончанияОткрывающегоТега = СтрНайти(НачалоТекстаHTML, КонецТега);
			Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда
				
				// Пропускаем содержимое открытых тегов для корректного определения является ли тег нужным
				// Например: "<a <test " - открыт тег a; "<test <a " - открыт тег test.
				НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияОкончанияОткрывающегоТега + 1);
				
			Иначе
				
				ПозицияНужногоТега = СтрНайти(НачалоТекстаHTML, НужныйТег + " ");
				Если ПозицияНужногоТега = 0 Тогда
					ПозицияНужногоТега = СтрНайти(НачалоТекстаHTML, НужныйТег + ">");
				КонецЕсли;
				
				Если ПозицияНужногоТега = 1 Тогда
					ЯвляетсяНужнымТегом = Истина;
				КонецЕсли;
				
				ОткрытТег = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЕсли;
		
		ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоТега);
		
	КонецЦикла;
	
	Возврат ОткрытТег;
	
КонецФункции

// Заменяет в строке все имена спецсимволов на соответствующие им спецсимволы,
// возвращает измененную строку.
Функция ЗаменитьСпецСимволыHTMLОбратно(Строка, СпецСимволыСоотв = Неопределено)
	
	ОбратноеСоответствиеСпецСимволов = РаботаС_HTMLПовтИсп.ПолучитьСоответствиеСпецСимволов();
	
	ЗаменитьСпецСимволHTMLОбратно(Строка, 38, "amp");
	
	Для Каждого СпецСимвол Из ОбратноеСоответствиеСпецСимволов Цикл
		ЗаменитьСпецСимволHTMLОбратно(Строка, СпецСимвол.Ключ, СпецСимвол.Значение);
	КонецЦикла;
	
	Возврат Строка;
	
КонецФункции

Процедура ЗаменитьСпецСимволHTMLОбратно(Строка, КодСимвола, ИмяСимвола)
	
	Строка = СтрЗаменить(Строка, "&" + ИмяСимвола + ";", Символ(КодСимвола));
	
КонецПроцедуры

// Дописывать значение из href в свойство title ссылок и картинок.
Процедура ЗаполнитьСвойствоTitleУСсылок(ТекстHTML)
	
	ТекстBase = ОпределитьBase(ТекстHTML);
	
	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a");
	
	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл
		
		Смещение = 0;
		СимволОграниченияHref = Неопределено;
		СимволОграниченияTitle = Неопределено;
		НачалоTitle = 0;
		КонецTitle = 0;
		
		ТекстHref = ПолучитьЗначениеПараметраТега(Тег, "href", СимволОграниченияHref);
		
		// Считаем ссылку относительной, если в ней нет символа ":"
		Если ТекстBase <> "" И СтрНайти(ТекстHref, ":") = 0 Тогда
			
			Если (Лев(ТекстHref, 1) <> "\" И Лев(ТекстHref, 1) <> "/")
				И (Прав(ТекстBase, 1) <> "\" И Прав(ТекстBase, 1) <> "/") Тогда
				
				// Нет "/" в тексте ссылки и Base
				ТекстHref = "/" + ТекстHref;
				
			ИначеЕсли (Лев(ТекстHref, 1) = "\" ИЛИ Лев(ТекстHref, 1) = "/")
				И (Прав(ТекстBase, 1) = "\" ИЛИ Прав(ТекстBase, 1) = "/") Тогда
				
				// Есть "/" в тексте ссылки и Base
				ТекстHref = Сред(ТекстHref, 2);
				
			КонецЕсли;
			
			ТекстHref = ТекстBase + ТекстHref;
			
		КонецЕсли;
		
		
		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
			Продолжить;
		КонецЕсли;
		
		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);
		
		Если ТекстTitle = Неопределено Тогда
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстTitle) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);
			
		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда
			
			ТекстДоTitle = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);
			
			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда
				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");
				КонецЕсли;
			КонецЕсли;
			
			Если СимволОграниченияTitle = "" Тогда
				ТекстTitle = СтрЗаменить(ТекстTitle, """", "'");
				ТекстHref = СтрЗаменить(ТекстHref, """", "'");
				СимволОграниченияTitle = """";
			КонецЕсли;
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстHref) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);
			
		Иначе
			
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
			
		КонецЕсли;
		
		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);
		
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
		
	КонецЦикла;
	
	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img");
	
	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл
		
		Смещение = 0;
		ВнешнийТегСсылки = Неопределено;
		СимволОграниченияHref = Неопределено;
		СимволОграниченияTitle = Неопределено;
		НачалоTitle = 0;
		КонецTitle = 0;
		
		Если НЕ ПозицияНаходитсяВТеге(ТекстHTML, "a", Тег.ПозицияНачалаТега, ВнешнийТегСсылки) Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		
		ТекстHref = ПолучитьЗначениеПараметраТега(ВнешнийТегСсылки, "href", СимволОграниченияHref);
		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		
		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);
		Если ТекстTitle = Неопределено Тогда
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстTitle) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);
			
		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда
			
			ТекстДоTitle = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);
			
			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда
				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");
				ИначеЕсли СимволОграниченияTitle = "" Тогда
					ТекстTitle = СтрЗаменить(ТекстHref, """", "'");
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
					СимволОграниченияTitle = """";
				КонецЕсли;
			КонецЕсли;
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстHref) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);
			
		Иначе
			
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
			
		КонецЕсли;
		
		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);
		
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
		
	КонецЦикла;
	
	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area");
	
	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл
		
		Смещение = 0;
		СимволОграниченияHref = Неопределено;
		СимволОграниченияTitle = Неопределено;
		НачалоTitle = 0;
		КонецTitle = 0;
		
		ТекстHref = ПолучитьЗначениеПараметраТега(Тег, "href", СимволОграниченияHref);
		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияОткрывающегоТега + 1);
			Продолжить;
		КонецЕсли;
		
		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);
		
		Если ТекстTitle = Неопределено Тогда
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстTitle) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);
			
		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда
			
			ТекстДоTitle = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);
			
			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда
				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");
				ИначеЕсли СимволОграниченияTitle = "" Тогда
					ТекстTitle = СтрЗаменить(ТекстTitle, """", "'");
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
					СимволОграниченияTitle = """";
				КонецЕсли;
			КонецЕсли;
			
			ТекстTitle = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстHref) + 1;
			
			НовыйОткрывающийТег = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);
			
		Иначе
			
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
			
		КонецЕсли;
		
		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);
		
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает значение свойства параметра тега
Функция ПолучитьЗначениеПараметраТега(Тег, Параметр,
	СимволОграничения = Неопределено, НачалоПараметра = Неопределено, КонецПараметра = Неопределено)
	
	Если НЕ ЗаполненаСтруктураТега(Тег) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПараметрыДляПоиска = НРег(Тег.ПараметрыОткрывающегоТега);
	ПараметрДляПоиска = НРег(" " + Параметр);
	
	ПозицияПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска);
	Если ПозицияПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "=""");
	Если НачалоПараметра <> 0 Тогда
		СимволОграничения = """";
	Иначе
		НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "='");
		Если НачалоПараметра <> 0 Тогда
			СимволОграничения = "'";
		Иначе
			НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "=");
			Если НачалоПараметра <> 0 Тогда
				СимволОграничения = "";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если НачалоПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	НачалоПараметра = НачалоПараметра + 1;
	
	Если СимволОграничения = "" Тогда
		ЗакрывающийСимволОграничения = " ";
		КонецПараметра = РаботаСоСтроками.НайтиПосле(ПараметрыДляПоиска, ЗакрывающийСимволОграничения,
			НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));
		Если КонецПараметра = 0 Тогда
			ЗакрывающийСимволОграничения = Символы.ПС;
			КонецПараметра = РаботаСоСтроками.НайтиПосле(ПараметрыДляПоиска, ЗакрывающийСимволОграничения,
				НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));
			Если КонецПараметра = 0 Тогда
				КонецПараметра = СтрДлина(ПараметрыДляПоиска) + 1;
			КонецЕсли;
		КонецЕсли;
	Иначе
		КонецПараметра = РаботаСоСтроками.НайтиПосле(ПараметрыДляПоиска, СимволОграничения,
			НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));
		Если КонецПараметра = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если КонецПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗначениеПараметраТега = Сред(Тег.ПараметрыОткрывающегоТега, НачалоПараметра + СтрДлина(Параметр + "=" + СимволОграничения),
		КонецПараметра - (НачалоПараметра + СтрДлина(Параметр + "=" + СимволОграничения)));
	
	Возврат ЗначениеПараметраТега;
	
КонецФункции

// Дописывать значение из href в текстовое содержимое ссылки и картинок.
//
// Параметры:
//  ТекстHTML - Строка - Текст, в котором следует выделить ссылки
//
// Возвращаемое значение:
//  Строка - Текст с выделенными ссылками в виде текста
//
Функция ПолучитьТекстHTMLСВыделениемСсылок(Знач ТекстHTML)
	
	// Для относительных ссылок используется упрощенный
	// метод определения относительной ссылки и работы с тегом BASE, для самых частотных случаев.
	// Ссылка считается относительной, если в нет не присутствует ":".
	// К представлению относительных ссылок дописывается текст тега Base.
	ТегBody = ПолучитьТегВТекстеHTML(ТекстHTML, "body");
	ТегBase = ПолучитьТегВТекстеHTML(ТекстHTML, "base");
	ТекстBase = ПолучитьЗначениеПараметраТега(ТегBase, "href");
	Если ТекстBase = Неопределено
		ИЛИ (ЗаполненаСтруктураТега(ТегBody) И ТегBase.ПозицияОкончанияТега > ТегBody.ПозицияНачалаТега) Тогда
		ТекстBase = "";
	КонецЕсли;
	
	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a");
	
	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл
		
		Если Не ЗначениеЗаполнено(Тег.ПозицияНачалаЗакрывающегоТега) Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
			Продолжить;
		КонецЕсли;
		
		Смещение = 0;
		
		ТекстHref = ПолучитьЗначениеПараметраТега(Тег, "href");
		
		// Считаем ссылку относительной, если в ней нет символа ":".
		Если ТекстBase <> "" И СтрНайти(ТекстHref, ":") = 0 Тогда
			
			Если (Лев(ТекстHref, 1) <> "\" И Лев(ТекстHref, 1) <> "/")
				И (Прав(ТекстBase, 1) <> "\" И Прав(ТекстBase, 1) <> "/") Тогда
				
				// Нет "/" в тексте ссылки и Base
				ТекстHref = "/" + ТекстHref;
				
			ИначеЕсли (Лев(ТекстHref, 1) = "\" ИЛИ Лев(ТекстHref, 1) = "/")
				И (Прав(ТекстBase, 1) = "\" ИЛИ Прав(ТекстBase, 1) = "/") Тогда
				
				// Есть "/" в тексте ссылки и Base
				ТекстHref = Сред(ТекстHref, 2);
				
			КонецЕсли;
			
			ТекстHref = ТекстBase + ТекстHref;
			
		КонецЕсли;
		
		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
			Продолжить;
		КонецЕсли;
		
		ТекстHref = УдалитьСхемуДокументооборота(ТекстHref);
		Содержание = Тег.Содержание;
		
		// Проверка допустимого последнего символа.
		ДопустимыйТекстHref = ТекстHref;
		Если СтрЗаканчиваетсяНа(ТекстHref, "/") Тогда
			ДопустимыйТекстHref = Лев(ТекстHref, СтрДлина(ТекстHref) - 1);
		КонецЕсли;
		Если Найти(Содержание, ДопустимыйТекстHref) <> 0 Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		
		// Проверка допустимых пропусков схемы.
		ДопустимыйТекстHrefБезMailto = УдалитьСхему(ДопустимыйТекстHref, "mailto:");
		Если Найти(Содержание, ДопустимыйТекстHrefБезMailto) <> 0 Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		ДопустимыйТекстHrefБезHttp = УдалитьСхему(ДопустимыйТекстHref, "http://");
		Если Найти(Содержание, ДопустимыйТекстHrefБезHttp) <> 0 Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		ДопустимыйТекстHrefБезFile = УдалитьСхему(ДопустимыйТекстHref, "file://");
		Если Найти(Содержание, ДопустимыйТекстHrefБезFile) <> 0 Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
			Продолжить;
		КонецЕсли;
		
		// Выделение ссылки.
		ПредставлениеСсылки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '(Ссылка: %1)'; en = '(Reference: %1)'"), ТекстHref);
		Если ЗначениеЗаполнено(Содержание) Тогда
			ПредставлениеСсылки = " " + ПредставлениеСсылки;
		КонецЕсли;
		
		Содержание = Содержание + ПредставлениеСсылки;
		Смещение = Смещение + СтрДлина(ПредставлениеСсылки) + 1;
		
		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега)
			+ Содержание
			+ Сред(ТекстHTML, Тег.ПозицияНачалаЗакрывающегоТега);
		
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + Смещение + 1);
		
	КонецЦикла;
	
	Возврат ТекстHTML;
	
КонецФункции

// Проверяет корректность шрифта для отображения во встроенной почте.
// Корректным шрифтом считается абсолютный шрифт с указанным именем и размером, большим 0.
//
// Параметры:
//  ШрифтОтображения - Шрифт - Шрифт, который следует проверить.
//
// Возвращаемое значение:
//  Булево - Корректность шрифта для отображения во встроенной почте.
//
Функция КорректныйШрифтОтображения(ШрифтОтображения)
	
	Если ШрифтОтображения.Вид = ВидШрифта.Абсолютный
		И ЗначениеЗаполнено(ШрифтОтображения.Имя) И ШрифтОтображения.Размер > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Формирует тег style со стилем для встроенной почты. Прописываются стили для следующих элементов:
//  body - шрифт тела письма;
//  .v8doc-mail-header - шрифт заголовка письма;
//  .v8doc-mail-information - шрифт информации о письме;
//  .v8doc-mail-monospace - шрифт моноширинного письма;
//  blockquote - отображение цитат.
//
// Параметры:
//  ШрифтОтображения - Шрифт - Шрифт для отображения тела письма.
//  ОтображатьДругиеШрифты - Булево - Указание всех шрифтов письма.
//
// Возвращаемое значение:
//  Строка - Тег style с атрибутом class=v8doc-style и описанием стиля для встроенной почты.
//
Функция ПолучитьОписаниеСтиля(ШрифтОтображения = Неопределено, ОтображатьДругиеШрифты = Неопределено,
	ДляКарточкиВходящегоПисьма = Ложь)
	
	Если ШрифтОтображения = Неопределено Тогда
		ШрифтОтображения =
			ВстроеннаяПочтаСервер.ПолучитьПерсональнуюНастройку("ШрифтОтображения");
	КонецЕсли;
	
	Если ОтображатьДругиеШрифты = Неопределено Тогда
		ОтображатьДругиеШрифты =
			ВстроеннаяПочтаСервер.ПолучитьПерсональнуюНастройку("ОтображатьДругиеШрифтыВПисьмах");
	КонецЕсли;
	
	Если Не КорректныйШрифтОтображения(ШрифтОтображения) Тогда
		ШрифтОтображения = ВстроеннаяПочтаКлиентСервер.ПолучитьШрифтПочтыПоУмолчанию();
	КонецЕсли;
	
	ОписаниеСтиля = "<style class=v8doc-style type=text/css>";
	
	// Отображение шрифтов
	Если ОтображатьДругиеШрифты Тогда
		ОписаниеСтиля = ОписаниеСтиля + Символы.ПС
			+ "body{
				|	font-family:%1;
				|	font-size:%2pt;
				|   overflow: auto;
				|}
				|.v8doc-mail-header{
				|	font-size=%3pt;
				|	font-family=Arial;
				|	line-height:15pt;
				|	margin-bottom: 5pt;
				|}
				|.v8doc-mail-information{
				|	font-size=%4pt;
				|	font-family=Arial;
				|	line-height:12pt;
				|}
				|.v8doc-mail-information-date{
				|	font-size=%4pt;
				|	font-family=Arial;
				|	line-height:12pt;
				|   color:#7a7a7a;
				|}
				|.v8doc-mail-monospace{
				|	font-family:""Courier New"",monospace;
				|	font-size:%4pt;
				|}";
	Иначе
		ОписаниеСтиля = ОписаниеСтиля + Символы.ПС
			+ "*{
				|	font-family:%1 !important;
				|	font-size:%2pt !important;
				|}
				|.v8doc-mail-header *{
				|	font-size=%3pt !important;
				|	font-family=Arial !important;
				|	line-height:20pt;
				|}
				|.v8doc-mail-header{
				|	font-size=%3pt !important;
				|	font-family=Arial !important;
				|	line-height:150%%;
				|}
				|.v8doc-mail-information *{
				|	font-size=%4pt !important;
				|	font-family=Arial !important;
				|	line-height:12pt;
				|	margin-bottom:0pt;
				|}
				|.v8doc-mail-information{
				|	font-size=%4pt !important;
				|	font-family=Arial !important;
				|	line-height:12pt;
				|	margin-bottom:0pt;
				|}
				|.v8doc-mail-monospace *{
				|	font-family:""Courier New"",monospace !important;
				|	font-size:%4pt !important;
				|
				|.v8doc-mail-monospace{
				|	font-family:""Courier New"",monospace !important;
				|	font-size:%4pt !important;
				|}";
	КонецЕсли;
	
	// Отображение цитирования
	ВидЦитированияПриОтвете = ВстроеннаяПочтаСерверПовтИсп.ПолучитьВидЦитированияПриОтвете();
	ТекстСтиляBlockquote = РаботаС_HTML.ПолучитьСтильЦитированияПриОтвете(ВидЦитированияПриОтвете, Истина);
	
	ОписаниеСтиля = ОписаниеСтиля + Символы.ПС
		+ "blockquote{
			|" + ТекстСтиляBlockquote + "
			|}";
	
	ОписаниеСтиля = ОписаниеСтиля + Символы.ПС + "</style>";
	
	ИмяШрифта = ШрифтОтображения.Имя;
	Если СтрНайти(ИмяШрифта, " ") <> 0 Тогда
		ИмяШрифта = """" + ИмяШрифта + """";
	КонецЕсли;
	
	РазмерШрифта = ШрифтОтображения.Размер;
	РазмерШрифтаЗаголовка = Формат(РазмерШрифта * 1.2, "ЧДЦ=0; ЧН=0; ЧГ=0"); // Увеличенный шрифт заголовка
	РазмерШрифтаИнформация = Формат(РазмерШрифта * 0.8, "ЧДЦ=0; ЧН=0; ЧГ=0"); // Уменьшенный шрифт информации
	Если ДляКарточкиВходящегоПисьма = Истина Тогда
		РазмерШрифтаИнформация = Формат(РазмерШрифта * 1.0, "ЧДЦ=0; ЧН=0; ЧГ=0"); // Уменьшенный шрифт информации
	КонецЕсли;	
	
	ОписаниеСтиля = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ОписаниеСтиля,
		ИмяШрифта, РазмерШрифта, РазмерШрифтаЗаголовка, РазмерШрифтаИнформация);
	
	Возврат ОписаниеСтиля;
	
КонецФункции

// Выделяет цитаты в переданном тексте в теги blockquote
//
// Параметры:
//  ТекстHTML - Строка - Текст, в котором следует выделить цитаты
//
// Возвращаемое значение:
//  Строка - Текст, с выделением цитат в теги blockquote
//
Функция ПолучитьТекстHTMLСВыделениемТекстовыхЦитат(Знач ТекстHTML)
	
	СимволЦитирования = ВстроеннаяПочтаСерверПовтИсп.ПолучитьСимволЦитированияВПереписке();
	Если Не ЗначениеЗаполнено(СимволЦитирования) Тогда
		Возврат ТекстHTML;
	КонецЕсли;
	
	// Альтернативные цитаты - цитаты, в которых не учитываются незначащие символы справа от символа цитирования
	АльтернативныйСимволЦитирования = СокрП(СимволЦитирования);
	
	ЗаменитьТабуляцииИПробелы(СимволЦитирования);
	ЗаменитьСпецСимволыHTML(СимволЦитирования);
	ЗаменитьТабуляцииИПробелы(АльтернативныйСимволЦитирования);
	ЗаменитьСпецСимволыHTML(АльтернативныйСимволЦитирования);
	
	ДлинаСимволаЦитирование = СтрДлина(СимволЦитирования);
	ДлинаАльтернативногоСимволаЦитирования = СтрДлина(АльтернативныйСимволЦитирования);
	
	ВидЦитированияПриОтвете = ВстроеннаяПочтаСерверПовтИсп.ПолучитьВидЦитированияПриОтвете();
	ТекстСтиляBlockquote = РаботаС_HTML.ПолучитьСтильЦитированияПриОтвете(ВидЦитированияПриОтвете);
	
	МаксимальныйУровеньЦитирования = 100;
	ТекущийУровеньЦитирования = 0;
	НайденаЦитата = СтрНайти(ТекстHTML, СимволЦитирования);
	Пока НайденаЦитата И ТекущийУровеньЦитирования < МаксимальныйУровеньЦитирования Цикл
		
		НайденаЦитата = Ложь;
		НачатоВыделениеЦитирования = Ложь;
		
		ТекстИсточника = Новый ТекстовыйДокумент;
		ТекстИсточника.УстановитьТекст(ТекстHTML);
		КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
		ТекстРезультата = Новый ТекстовыйДокумент;
		СмещениеСтрокРезультата = 0;
		
		Для К = 1 По КоличествоСтрок Цикл
			
			Строка = ТекстИсточника.ПолучитьСтроку(К);
			
			СтрокаЯвляетсяЦитатой = (Найти(Строка, СимволЦитирования) = 1);
			СтрокаЯвляетсяАльтернативнойЦитатой = (Найти(Строка, АльтернативныйСимволЦитирования) = 1);
			
			Если СтрокаЯвляетсяЦитатой Или СтрокаЯвляетсяАльтернативнойЦитатой Тогда
				
				НайденаЦитата = Истина;
				
				Если СтрокаЯвляетсяЦитатой Тогда
					Строка = Сред(Строка, 1 + ДлинаСимволаЦитирование);
				ИначеЕсли СтрокаЯвляетсяАльтернативнойЦитатой Тогда
					Строка = Сред(Строка, 1 + ДлинаАльтернативногоСимволаЦитирования);
				КонецЕсли;
				
				Если К = КоличествоСтрок И НачатоВыделениеЦитирования Тогда
					НачатоВыделениеЦитирования = Ложь;
					Строка = Строка + "</blockquote>";
				ИначеЕсли К = КоличествоСтрок И Не НачатоВыделениеЦитирования Тогда
					Строка = "<blockquote " + ТекстСтиляBlockquote + ">" + Символы.ПС + Строка + "</blockquote>";
					СмещениеСтрокРезультата = СмещениеСтрокРезультата + 1;
				ИначеЕсли К <> КоличествоСтрок И Не НачатоВыделениеЦитирования Тогда
					НачатоВыделениеЦитирования = Истина;
					Строка = "<blockquote " + ТекстСтиляBlockquote + ">" + Символы.ПС + Строка;
					СмещениеСтрокРезультата = СмещениеСтрокРезультата + 1;
				КонецЕсли;
				
			ИначеЕсли НачатоВыделениеЦитирования Тогда
				
				НачатоВыделениеЦитирования = Ложь;
				НомерПредыдущейСтроки = К - 1 + СмещениеСтрокРезультата;
				ПредыдущаяСтрока = ТекстРезультата.ПолучитьСтроку(НомерПредыдущейСтроки);
				ПредыдущаяСтрока = ПредыдущаяСтрока + "</blockquote>";
				ТекстРезультата.ЗаменитьСтроку(НомерПредыдущейСтроки, ПредыдущаяСтрока);
				
			КонецЕсли;
			
			Если К = КоличествоСтрок И НачатоВыделениеЦитирования Тогда
				НачатоВыделениеЦитирования = Ложь;
				Строка = Строка + "</blockquote>";
			КонецЕсли;
			
			ТекстРезультата.ДобавитьСтроку(Строка);
			
		КонецЦикла;
		
		ТекстHTML = ТекстРезультата.ПолучитьТекст();
		ТекущийУровеньЦитирования = ТекущийУровеньЦитирования + 1;
		
	КонецЦикла;
	
	Возврат ТекстHTML;
	
КонецФункции

// Устанавливает пометки цитат %V8DocУровеньЦитаты+% и %V8DocУровеньЦитаты-% по тегам blockquote
//
// Параметры:
//  ТекстHTML - Строка - Текст, в котором следует выделить цитаты
//
// Возвращаемое значение:
//  Строка - Текст с разметкой уровней цитат
//
Функция ПолучитьТекстHTMLСВыделениемУровнейЦитат(Знач ТекстHTML)
	
	Смещение = 0;
	СтрокаУвеличениеУровняЦитаты = "%V8DocУровеньЦитаты+%";
	СтрокаУменьшениеУровняЦитаты = "%V8DocУровеньЦитаты-%";
	ДлинаСтрокиУвеличенияУровняЦитаты = СтрДлина(СтрокаУвеличениеУровняЦитаты);
	ДлинаСтрокиУменьшенияУровняЦитаты = СтрДлина(СтрокаУвеличениеУровняЦитаты);
	
	ТегBlockquote = ПолучитьТегВТекстеHTML(ТекстHTML, "blockquote");
	Пока ЗаполненаСтруктураТега(ТегBlockquote) <> 0 Цикл
		
		Если ТегBlockquote.ПозицияНачалаЗакрывающегоТега <> 0 Тогда
			
			ТекстHTML =
				Лев(ТекстHTML, ТегBlockquote.ПозицияОкончанияОткрывающегоТега)
				+ СтрокаУвеличениеУровняЦитаты
				+ Сред(ТекстHTML,
					ТегBlockquote.ПозицияОкончанияОткрывающегоТега + 1,
					(ТегBlockquote.ПозицияНачалаЗакрывающегоТега - 1) - ТегBlockquote.ПозицияОкончанияОткрывающегоТега)
				+ СтрокаУменьшениеУровняЦитаты
				+ Сред(ТекстHTML, ТегBlockquote.ПозицияНачалаЗакрывающегоТега);
			
			ТегBlockquote = 
				ПолучитьТегВТекстеHTML(ТекстHTML, "blockquote",
					ТегBlockquote.ПозицияОкончанияОткрывающегоТега
						+ ДлинаСтрокиУвеличенияУровняЦитаты + 1);
			
		Иначе
			
			ТекстHTML =
				Лев(ТекстHTML, ТегBlockquote.ПозицияОкончанияОткрывающегоТега)
				+ СтрокаУвеличениеУровняЦитаты
				+ Сред(ТекстHTML, ТегBlockquote.ПозицияОкончанияОткрывающегоТега + 1);
			
			ТегBlockquote =
				ПолучитьТегВТекстеHTML(ТекстHTML, "blockquote",
					ТегBlockquote.ПозицияОкончанияОткрывающегоТега
						+ ДлинаСтрокиУвеличенияУровняЦитаты + 1);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстHTML;
	
КонецФункции

// Формирует цитирование текста с выделением уровня цитат. Формирование производится по
// меткам %V8DocУровеньЦитаты+% и %V8DocУровеньЦитаты-% в тексте.
//
// Параметры:
//  Текст - Строка - Текст, в котором необходимо выделить цитаты.
// 
// Возвращаемое значение:
//  Строка - Текст с выделенными цитатами.
//
Функция ПолучитьТекстСВыделениемЦитатПоУровням(Знач Текст)
	
	УровеньЦитаты = 0;
	СтрокаУвеличениеУровняЦитаты = "%V8DocУровеньЦитаты+%";
	СтрокаУменьшениеУровняЦитаты = "%V8DocУровеньЦитаты-%";
	СимволЦитирования = ВстроеннаяПочтаСерверПовтИсп.ПолучитьСимволЦитированияВПереписке();
	
	ТекстИсточника = Новый ТекстовыйДокумент;
	ТекстИсточника.УстановитьТекст(Текст);
	КоличествоСтрок = ТекстИсточника.КоличествоСтрок();
	ТекстРезультата = Новый ТекстовыйДокумент;
	
	Для К = 1 По КоличествоСтрок Цикл
		
		Строка = ТекстИсточника.ПолучитьСтроку(К);
		
		УвеличениеУровняЦитаты = СтрЧислоВхождений(Строка, СтрокаУвеличениеУровняЦитаты);
		УменьшениеУровняЦитаты = СтрЧислоВхождений(Строка, СтрокаУменьшениеУровняЦитаты);
		
		Строка = СтрЗаменить(Строка, СтрокаУвеличениеУровняЦитаты, "");
		Строка = СтрЗаменить(Строка, СтрокаУменьшениеУровняЦитаты, "");
		Если СтрДлина(СокрЛП(Строка)) = 0 И (УвеличениеУровняЦитаты > 0 Или УменьшениеУровняЦитаты > 0) Тогда
			УровеньЦитаты = УровеньЦитаты + УвеличениеУровняЦитаты - УменьшениеУровняЦитаты;
			Продолжить;
		КонецЕсли;
		
		УровеньЦитаты = УровеньЦитаты + УвеличениеУровняЦитаты;
		
		Если УровеньЦитаты > 0 Тогда
			Для ИндексУровняЦитаты = 1 По УровеньЦитаты Цикл
				Строка = СимволЦитирования + Строка;
			КонецЦикла;
		КонецЕсли;
		
		УровеньЦитаты = УровеньЦитаты - УменьшениеУровняЦитаты;
		ТекстРезультата.ДобавитьСтроку(Строка);
		
	КонецЦикла;
	
	Текст = ТекстРезультата.ПолучитьТекст();
	
	Возврат Текст;
	
КонецФункции

// Формирует пустую структуру тега
//
// Возвращаемое значение:
//  Структура - НазваниеЭлемента - Строка - Имя тега
//            - ПараметрыОткрывающегоТега - Строка - Параметры тега
//            - Содержание - Строка - Текстовое содержимое тега
//            - ПозицияНачалаОткрывающегоТега - Число - Позиция символа "<" открывающего тега
//            - ПозицияНачалаОткрывающегоТега - Число - Позиция символа ">" открывающего тега
//            - ПозицияНачалаЗакрывающегоТега - Число - Позиция символа "<" закрывающего тега.
//                                                      Если нет закрывающего тега, то содержит 0.
//            - ПозицияОкончанияЗакрывающегоТега - Число - Позиция символа ">" открывающего тега
//                                                      Если нет закрывающего тега, то содержит 0.
//            - ПозицияНачалаТега - Число - Позиция символа "<" открывающего тега
//            - ПозицияОкончанияТега - Число - Позиция символа ">" закрывающего тега. Если нет 
//                                             закрывающего тега, то содержит позицию символа ">"
//                                             открывающего тега.
//
Функция СформироватьСтруктуруТега()
	
	Тег = Новый Структура;
	Тег.Вставить("НазваниеЭлемента", "");
	Тег.Вставить("ПараметрыОткрывающегоТега", "");
	Тег.Вставить("Содержание", "");
	Тег.Вставить("ПозицияНачалаОткрывающегоТега", 0);
	Тег.Вставить("ПозицияОкончанияОткрывающегоТега", 0);
	Тег.Вставить("ПозицияНачалаЗакрывающегоТега", 0);
	Тег.Вставить("ПозицияОкончанияЗакрывающегоТега", 0);
	Тег.Вставить("ПозицияНачалаТега", 0);
	Тег.Вставить("ПозицияОкончанияТега", 0);
	
	Возврат Тег;
	
КонецФункции

// Определяет позицию открывающего тега в переданном тексте
Функция ПолучитьПозициюНачалаОткрывающегоТега(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега)
	
	ПозицияНачалаОткрывающегоТега = 0;
	
	ВозможнаяПозицияНачалаОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
	СледующийСимвол = Сред(ОбрабатываемыйТекстHTML, ВозможнаяПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега), 1);
	
	Если СледующийСимвол = " " Или СледующийСимвол = Символы.ПС Или СледующийСимвол = ">" Тогда
		ПозицияНачалаОткрывающегоТега = ВозможнаяПозицияНачалаОткрывающегоТега;
	ИначеЕсли СледующийСимвол = "/" Тогда
		СледующиеДваСимвола = Сред(ОбрабатываемыйТекстHTML, ВозможнаяПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега), 2);
		Если СледующиеДваСимвола = "/>" Тогда
			ПозицияНачалаОткрывающегоТега = ВозможнаяПозицияНачалаОткрывающегоТега;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПозицияНачалаОткрывающегоТега;
	
КонецФункции

// Дописывает текст в начало тега head. Если тега head нет - то создает его в начале тега html.
// Если тега html нет - то создает его, помещая текст HTML в содержимое тега body.
//
// Параметры::
//  ТекстHTML - Обрабатываемый текст HTML, в который могут быть добавлены теги.
//  ДобавляемыйТекст - Текст, который будет добавлен в тег head.
//
Процедура ДобавитьВТегHead(ТекстHTML, ДобавляемыйТекст)
	
	// Если тега head нет, то его следует создать
	ТегHead = ПолучитьТегВТекстеHTML(ТекстHTML, "head");
	Если Не ЗаполненаСтруктураТега(ТегHead) Тогда
		
		// Если тега html нет, то его следует создать
		ТегHTML = ПолучитьТегВТекстеHTML(ТекстHTML, "html");
		Если Не ЗаполненаСтруктураТега(ТегHTML) Тогда
			
			// Если тега body нет, то его следует создать
			ТегBody = ПолучитьТегВТекстеHTML(ТекстHTML, "body");
			Если Не ЗаполненаСтруктураТега(ТегBody) Тогда
				ТекстHTML = "<body>" + ТекстHTML + "</body>";
			КонецЕсли;
			
			ТекстHTML = "<html>" + ТекстHTML + "</html>";
			ТегHTML = ПолучитьТегВТекстеHTML(ТекстHTML, "html");
			
		КонецЕсли;
		
		ТекстHTML =
			Лев(ТекстHTML, ТегHTML.ПозицияОкончанияОткрывающегоТега)
			+ "<head></head>"
			+ Сред(ТекстHTML, ТегHTML.ПозицияОкончанияОткрывающегоТега + 1);
		ТегHead = ПолучитьТегВТекстеHTML(ТекстHTML, "head");
		
	КонецЕсли;
	
	ТекстHTML = Лев(ТекстHTML, ТегHead.ПозицияОкончанияОткрывающегоТега)
		+ ДобавляемыйТекст
		+ Сред(ТекстHTML, ТегHead.ПозицияОкончанияОткрывающегоТега + 1);
	
КонецПроцедуры

// Формирует текстовое представление ссылки с тегом
Функция СформироватьСсылкуСТегом(Ссылка, Схема, НовоеЗначениеСхемы)
	
	ПредставлениеСсылки = Ссылка;
	// Если ссылка совпадает со схемой, то выделять ссылку нет необходимости.
	Если Ссылка = Схема Тогда
		Возврат Ссылка;
	КонецЕсли;
	
	// Замены схемы в ссылке при необходимости, например "www." => "http<<ВНЕШНЕЕСОЕДИНЕНИЕ>>www."
	Если ЗначениеЗаполнено(НовоеЗначениеСхемы) И СсылкаСоответствуетСхеме(Ссылка, Схема) Тогда
		Ссылка = НовоеЗначениеСхемы + Сред(Ссылка, СтрДлина(Схема) + 1);
	КонецЕсли;
	
	// Удаление тегов из ссылки
	ПозицияНачалаОткрывающегоТега = РаботаСоСтроками.НайтиПосле(Ссылка, "<");
	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл
		
		СтруктураТега = ПолучитьТегВТекстеHTML(Ссылка, , ПозицияНачалаОткрывающегоТега);
		Если ЗаполненаСтруктураТега(СтруктураТега) Тогда
			
			Ссылка = Лев(Ссылка, СтруктураТега.ПозицияНачалаОткрывающегоТега - 1) + Сред(Ссылка, СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТега - 1;
			
		КонецЕсли;
		
		ПозицияНачалаОткрывающегоТега = РаботаСоСтроками.НайтиПосле(Ссылка, "<", ПозицияНачалаОткрывающегоТега);
		
	КонецЦикла;
	
	Если Не СтрНайти(Ссылка, """") Тогда
		СсылкаСТегом = "<a href=""" + Ссылка + """>" + ПредставлениеСсылки + "</a>";
	ИначеЕсли Не СтрНайти(Ссылка, "'") Тогда
		СсылкаСТегом = "<a href='" + Ссылка + "'>" + ПредставлениеСсылки + "</a>";
	Иначе
		ЗаменитьСпецСимволыHTMLОбратно(Ссылка);
		ЗаменитьСпецСимволыHTML(Ссылка);
		СсылкаСТегом = "<a href=""" + Ссылка + """>" + ПредставлениеСсылки + "</a>";
	КонецЕсли;
	
	Возврат СсылкаСТегом;
	
КонецФункции

// Проверяет соответствие ссылки схеме.
Функция СсылкаСоответствуетСхеме(Ссылка, Схема)
	
	ДлинаСхемы = СтрДлина(Схема);
	СхемаВСсылке = Лев(Ссылка, ДлинаСхемы);
	
	Возврат НРег(Схема) = НРег(СхемаВСсылке);
	
КонецФункции

// Корректирует ссылки по схеме - если ссылка и ее представление не совпадает,
// то выполняет пересоздание ссылки только в параметром href.
Процедура СкорректироватьСсылки(ТекстHTML, Схема, НовоеЗначениеСхемы = "")
	
	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a");
	
	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл
		
		Href = ПолучитьЗначениеПараметраТега(Тег, "href");
		
		Если ЗначениеЗаполнено(НовоеЗначениеСхемы) Тогда
			
			// Проверка соответствует ли href новой схеме
			Если Не СсылкаСоответствуетСхеме(Href, НовоеЗначениеСхемы)
				Или Не СсылкаСоответствуетСхеме(Тег.Содержание, Схема) Тогда
				Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
				Продолжить;
			КонецЕсли;
			
			// Проверка совпадает ли содержание ссылки с href
			МодификацияСхемы = СтрЗаменить(НовоеЗначениеСхемы, Схема, "");
			Если Href = МодификацияСхемы + Тег.Содержание Тогда
				Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
				Продолжить;
			КонецЕсли;
			
		Иначе
			
			// Проверка соответствует ли href и содержание схеме
			Если Не СсылкаСоответствуетСхеме(Href, Схема)
				Или Не СсылкаСоответствуетСхеме(Тег.Содержание, Схема) Тогда
				Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
				Продолжить;
			КонецЕсли;
			
			// Проверка совпадает ли содержание ссылки с href
			Если Href = Тег.Содержание Тогда
				Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияОткрывающегоТега + 1);
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		НачалоСтроки = Лев(ТекстHTML, Тег.ПозицияНачалаТега - 1);
		КонецСтроки = Сред(ТекстHTML, Тег.ПозицияОкончанияТега + 1);
		СсылкаСТегом = СформироватьСсылкуСТегом(Тег.Содержание, Схема, НовоеЗначениеСхемы);
		
		ТекстHTML = НачалоСтроки + СсылкаСТегом + КонецСтроки;
		
		ДобавленныйТег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияНачалаТега);
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", ДобавленныйТег.ПозицияОкончанияОткрывающегоТега + 1);
		
	КонецЦикла;
	
КонецПроцедуры

// Для отображения подсказки к относительным ссылкам используется упрощенный
// метод определения относительной ссылки и работы с тегом BASE, для самых частотных случаев.
// Ссылка считается относительной, если в ней не присутствует ":".
// К представлению относительных ссылок дописывается текст тега Base.
Функция ОпределитьBase(ТекстHTML)
	
	ТегBody = ПолучитьТегВТекстеHTML(ТекстHTML, "body");
	ТегBase = ПолучитьТегВТекстеHTML(ТекстHTML, "base");
	ТекстBase = ПолучитьЗначениеПараметраТега(ТегBase, "href");
	Если ТекстBase = Неопределено
		ИЛИ (ЗаполненаСтруктураТега(ТегBody) И ТегBase.ПозицияОкончанияТега > ТегBody.ПозицияНачалаТега) Тогда
		ТекстBase = "";
	КонецЕсли;
	
	Возврат ТекстBase;
	
КонецФункции

#КонецОбласти
