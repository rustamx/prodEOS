////////////////////////////////////////////////////////////////////////////////
// Подсистема "Файловые функции".
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Объявляет служебные события подсистемы ФайловыеФункции:
//
// Серверные события:
//   ПриДобавленииФайловВТомаПриРазмещении,
//   ПриУдаленииРегистрацииИзменений,
//   ПриОпределенииТекстаЗапросаДляИзвлеченияТекста,
//   ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом,
//   ПриЗаписиИзвлеченногоТекста,
//   ПриОпределенииКоличестваФайловВТомах,
//   ПриОпределенииНаличияХранимыхФайлов,
//   ПриПолученииХранимыхФайлов,
//   ПриОпределенииНавигационнойСсылкиФайла,
//   ПриОпределенииИмениФайлаСПутемКДвоичнымДанным,
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Добавляет файл на том при "Разместить файлы начального образа".
	//
	// Синтаксис:
	// Процедура ПриДобавленииФайловВТомаПриРазмещении(СоответствиеПутейФайлов, ХранитьФайлыВТомахНаДиске, ПрисоединяемыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриДобавленииФайловВТомаПриРазмещении");
	
	// Удаляет регистрацию изменений после "Разместить файлы начального образа".
	//
	// Синтаксис:
	// Процедура ПриУдаленииРегистрацииИзменений(ПланОбменаСсылка, ПрисоединяемыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриУдаленииРегистрацииИзменений");
	
	// Заполняет текст запроса для получения файлов у которых не извлечен текст.
	// В качестве параметра может прийти другой запрос, с которым следует сделать объединение.
	//
	// Параметры:
	//  ТекстЗапроса - Строка (возвращаемое значение), варианты передаваемых значений:
	//                   Пустая строка   - будет возвращен требуемый текст запроса.
	//                   Непустая строка - будет возвращен требуемый текст запроса, добавленный
	//                                     к переданному тексту посредством "ОБЪЕДИНИТЬ ВСЕ".
	// 
	//  ПолучитьВсеФайлы - Булево - начальное значение Ложь. Позволяет отключить выборку
	//                     файлов по частям, если передать Истина.
	//
	// Синтаксис:
	// Процедура ПриОпределенииТекстаЗапросаДляИзвлеченияТекста(ТекстЗапроса, ПолучитьВсеФайлы = Ложь) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииТекстаЗапросаДляИзвлеченияТекста");
	
	// Возвращает число файлов с неизвлеченным текстом.
	//
	// Синтаксис:
	// Процедура ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом(ЧислоВерсий) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом");
	
	// Записывает извлеченный текст.
	//
	// Синтаксис:
	// Процедура ПриЗаписиИзвлеченногоТекста(ФайлОбъект) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
	
	// Возвращает в параметре КоличествоФайловВТомах количество файлов в томах.
	//
	// Синтаксис:
	// Процедура ПриОпределенииКоличестваФайловВТомах(КоличествоФайловВТомах) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваФайловВТомах");
	
	// Возвращает Истина в параметре ЕстьХранимыеФайлы, если есть хранимые файлы к объекту ВнешнийОбъект.
	//
	// Синтаксис:
	// Процедура ПриОпределенииНаличияХранимыхФайлов(ВнешнийОбъект, ЕстьХранимыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНаличияХранимыхФайлов");
	
	// Возвращает в параметре ХранимыеФайлы массив хранимых файлов к объекту ВнешнийОбъект.
	//
	// Синтаксис:
	// Процедура ПриПолученииХранимыхФайлов(ВнешнийОбъект, ХранимыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриПолученииХранимыхФайлов");
	
	// Возвращает навигационную ссылку на файл (на реквизит или во временное хранилище).
	//
	// Синтаксис:
	// Процедура ПриОпределенииНавигационнойСсылкиФайла(ФайлСсылка, УникальныйИдентификатор, НавигационнаяСсылка) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНавигационнойСсылкиФайла");
	
	// Получает полный путь к файлу на диске.
	//
	// Синтаксис:
	// Процедура ПриОпределенииИмениФайлаСПутемКДвоичнымДанным(ФайлСсылка, ПутьКФайлу, ПустойПутьДляПустыхДанных = Ложь) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииИмениФайлаСПутемКДвоичнымДанным");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
			"ФайловыеФункцииСлужебный");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиента"].Добавить(
			"ФайловыеФункцииСлужебный");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам"].Добавить(
			"ФайловыеФункцииСлужебный");
			
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиентаПриЗапуске"].Добавить(
		"ФайловыеФункцииСлужебный");
			
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаДанных") Тогда
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке"].Добавить(
				"ФайловыеФункцииСлужебный");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
		СерверныеОбработчики["СтандартныеПодсистемы.ВариантыОтчетов\ПриНастройкеВариантовОтчетов"].Добавить(
			"ФайловыеФункцииСлужебный");
	КонецЕсли;
	
КонецПроцедуры

// Определить список справочников, доступных для загрузки с помощью подсистемы "Загрузка данных из файла".
//
// Параметры:
//  ЗагружаемыеСправочники - ТаблицаЗначений - список справочников, в которые возможна загрузка данных.
//      * ПолноеИмя          - Строка - полное имя справочника (как в метаданных).
//      * Представление      - Строка - представление справочника в списке выбора.
//      * ПрикладнаяЗагрузка - Булево - если Истина, значит справочник использует собственный алгоритм загрузки и
//                                      в модуле менеджера справочника определены функции.
//
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в справочник ТомаХраненияФайлов запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ТомаХраненияФайлов.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// Определить объекты метаданных, в модулях менеджеров которых ограничивается возможность 
// редактирования реквизитов при групповом изменении.
//
// Параметры:
//   Объекты - Соответствие - в качестве ключа указать полное имя объекта метаданных,
//                            подключенного к подсистеме "Групповое изменение объектов". 
//                            Дополнительно в значении могут быть перечислены имена экспортных функций:
//                            "РеквизитыНеРедактируемыеВГрупповойОбработке",
//                            "РеквизитыРедактируемыеВГрупповойОбработке".
//                            Каждое имя должно начинаться с новой строки.
//                            Если указана пустая строка, значит в модуле менеджера определены обе функции.
//
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ТомаХраненияФайлов.ПолноеИмя(), "РеквизитыРедактируемыеВГрупповойОбработке");
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Поддержка обмена файлами

// Служебная функции. Используется для удаления файла на сервере.
// 
Процедура УдалитьФайлыНаСервере(ПрежнийПутьНаТоме) Экспорт
	
	// Удаляем файл.
	ФайлВременный = Новый Файл(ПрежнийПутьНаТоме);
	Если ФайлВременный.Существует() Тогда
		
		Попытка
			ФайлВременный.УстановитьТолькоЧтение(Ложь);
			УдалитьФайлы(ПрежнийПутьНаТоме);
		Исключение
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Файлы.Удаление файлов в томе при обмене'; en = 'Files.Deleting files in volume during exchange'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ИнформацияОбОшибке());
		КонецПопытки;
		
	КонецЕсли;
	
	// Удаляем каталог файла, если после удаления файла каталог стал пустым.
	Попытка
		МассивФайловВКаталоге = НайтиФайлы(ФайлВременный.Путь, "*.*");
		Если МассивФайловВКаталоге.Количество() = 0 Тогда
			УдалитьФайлы(ФайлВременный.Путь);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Файлы.Удаление файлов в томе при обмене'; en = 'Files.Deleting files in volume during exchange'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ИнформацияОбОшибке() );
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с томами файлов

// Возвращает тип хранения файлов.
// 
// Возвращаемое значение:
//  Булево. Истина, если указано хранить файлы в томах на диске.
//
Функция ХранениеФайловВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	
	Возврат ХранитьФайлыВТомахНаДиске;
	
КонецФункции

// Возвращает тип хранения файлов с учетом наличия томов.
// Если томов хранения файлов нет, тогда хранение в ИБ.
//
// Возвращаемое значение:
//  ПеречисленияСсылка.ТипыХраненияФайлов.
//
Функция ТипХраненияФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	
	Если ХранитьФайлыВТомахНаДиске Тогда
		
		Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
			Возврат Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
		Иначе
			Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
		КонецЕсли;
		
	Иначе
		Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	КонецЕсли;

КонецФункции

// Проверяет, что хотя бы в одном томе есть хотя бы один файл.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьФайлыВТомах() Экспорт
	
	Если КоличествоФайловВТомах() <> 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Возвращает полный путь тома - в зависимости от ОС.
Функция ПолныйПутьТома(СсылкаНаТом) Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияДокументооборотПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
	 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		Возврат СсылкаНаТом.ПолныйПутьWindows;
	Иначе
		Возврат СсылкаНаТом.ПолныйПутьLinux;
	КонецЕсли;
	
КонецФункции

// Добавляет файл в один из томов (где есть свободное место).
//
// Параметры:
//   ДвоичныеДанныеИлиПуть  - ДвоичныеДанные, Строка - двоичные данные файла или полный путь к файлу на диске.
//   ВремяИзмененияУниверсальное - Дата - универсальное время, которое будет установлено файлу как время последнего
//                                        изменения.
//   ИмяБезРасширения       - Строка - имя файла без расширения. 
//   Расширение             - Строка - расширение файла без точки. 
//   НомерВерсии            - Строка - номер версии файла. Если указан, то имя файла для хранения на диске формируется
//                                     как:
//                                     ИмяБезРасширения + "." + НомерВерсии + "." + Расширение
//                                     в противном случае, ИмяБезРасширения + "." + Расширение.
//   Зашифрован             - Булево - если Истина, то к полному имени файла будет добавлено расширение ".p7m".
//   ДатаДляРазмещенияВТоме - Дата   - если не указано, то используется текущее время сеанса.
//  
//  Возвращаемое значение:
//    Структура - со свойствами:
//      * Том         - СправочникСсылка.ТомаХраненияФайлов - том, в котором был размещен файл.
//      * ПутьКФайлу  - Строка - путь, по которому был размещен файл в томе.
//
Функция ДобавитьФайлВТом(ДвоичныеДанныеИлиПуть, ВремяИзмененияУниверсальное, ИмяБезРасширения, Расширение,
	НомерВерсии = "", Зашифрован = Ложь, ДатаДляРазмещенияВТоме = Неопределено) Экспорт
	
	ОжидаемыеТипы = Новый Массив;
	ОжидаемыеТипы.Добавить(Тип("ДвоичныеДанные"));
	ОжидаемыеТипы.Добавить(Тип("Строка"));
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр("ФайловыеФункцииСлужебный.ДобавитьНаДиск", "ДвоичныеДанныеИлиПуть", ДвоичныеДанныеИлиПуть,	
		Новый ОписаниеТипов(ОжидаемыеТипы));
		
	УстановитьПривилегированныйРежим(Истина);
	
	СсылкаНаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	
	КраткоеОписаниеВсехОшибок   = ""; // Ошибки со всех томов.
	ПодробноеОписаниеВсехОшибок = ""; // Для журнала регистрации.
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ТомаХраненияФайлов.Ссылка
		|ИЗ
		|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
		|ГДЕ
		|	ТомаХраненияФайлов.ПометкаУдаления = ЛОЖЬ
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТомаХраненияФайлов.ПорядокЗаполнения";

	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'Нет ни одного тома для размещения файла.'; en = 'There is no volume for the file placement.'");
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		
		СсылкаНаТом = Выборка.Ссылка;
		
		ПутьКТому = ПолныйПутьТома(СсылкаНаТом);
		// Добавляем слэш в конце, если его нет.
		ПутьКТому = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПутьКТому);
		
		// Имя файла для хранения на диске формировать следующим образом
		// - имя файла.номер версии.расширение файла.
		Если ПустаяСтрока(НомерВерсии) Тогда
			ИмяФайла = ИмяБезРасширения + "." + Расширение;
		Иначе
			ИмяФайла = ИмяБезРасширения + "." + НомерВерсии + "." + Расширение;
		КонецЕсли;
		
		Если Зашифрован Тогда
			ИмяФайла = ИмяФайла + "." + "p7m";
		КонецЕсли;
		
		Попытка
			
			Если ТипЗнч(ДвоичныеДанныеИлиПуть) = Тип("ДвоичныеДанные") Тогда
				РазмерФайла = ДвоичныеДанныеИлиПуть.Размер();
			Иначе // Считаем, что иначе это путь к файлу на диске.
				ФайлИсточник = Новый Файл(ДвоичныеДанныеИлиПуть);
				РазмерФайла = ФайлИсточник.Размер();
			КонецЕсли;
			
			// Если МаксимальныйРазмер = 0 - нет ограничения на размер файлов на томе.
			Если СсылкаНаТом.МаксимальныйРазмер <> 0 Тогда
				
				ТекущийРазмерВБайтах = 0;
				
				ПриОпределенииРазмераФайловНаТоме(СсылкаНаТом.Ссылка, ТекущийРазмерВБайтах);
				
				НовыйРазмерВБайтах = ТекущийРазмерВБайтах + РазмерФайла;
				НовыйРазмер = НовыйРазмерВБайтах / (1024 * 1024);
				
				Если НовыйРазмер > СсылкаНаТом.МаксимальныйРазмер Тогда
					
					ВызватьИсключение СтрШаблон(
						НСтр("ru = 'Превышен максимальный размер тома (%1 Мб).'; en = 'Maximum size of the volume (%1 Mb) is exceeded.'"),
						СсылкаНаТом.МаксимальныйРазмер);
				КонецЕсли;
			КонецЕсли;
			
			Дата = ТекущаяДатаСеанса();
			Если ДатаДляРазмещенияВТоме <> Неопределено Тогда
				Дата = ДатаДляРазмещенияВТоме;
			КонецЕсли;
			
			// Использование абсолютного формата даты "ДФ" в следующей строке
			// является правильным, так как дата используется не для просмотра пользователем.
			ПутьДня = Формат(Дата, "ДФ=ггггММдд") + ПолучитьРазделительПути();
			
			ПутьКТому = ПутьКТому + ПутьДня;
			
			ИмяФайлаСПутем = ФайловыеФункцииСлужебныйКлиентСервер.ПолучитьУникальноеИмяСПутем(ПутьКТому, ИмяФайла);
			ПолноеИмяФайлаСПутем = ПутьКТому + ИмяФайлаСПутем;
			
			Если ТипЗнч(ДвоичныеДанныеИлиПуть) = Тип("ДвоичныеДанные") Тогда
				ДвоичныеДанныеИлиПуть.Записать(ПолноеИмяФайлаСПутем);
			Иначе // Считаем, что иначе это путь к файлу на диске.
				КопироватьФайл(ДвоичныеДанныеИлиПуть, ПолноеИмяФайлаСПутем);
			КонецЕсли;
			
			// Установка времени изменения файла таким, как оно стоит в текущей версии.
			ФайлНаДиске = Новый Файл(ПолноеИмяФайлаСПутем);
			ФайлНаДиске.УстановитьУниверсальноеВремяИзменения(ВремяИзмененияУниверсальное);
			ФайлНаДиске.УстановитьТолькоЧтение(Истина);
			
			Возврат Новый Структура("Том,ПутьКФайлу", СсылкаНаТом, ПутьДня + ИмяФайлаСПутем); 
			
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			
			Если ПодробноеОписаниеВсехОшибок <> "" Тогда
				ПодробноеОписаниеВсехОшибок = ПодробноеОписаниеВсехОшибок + Символы.ПС + Символы.ПС;
				КраткоеОписаниеВсехОшибок   = КраткоеОписаниеВсехОшибок   + Символы.ПС + Символы.ПС;
			КонецЕсли;
			
			ШаблонОписанияОшибки =
				НСтр("ru = 'Ошибка при добавлении файла ""%1""
				           |в том ""%2"" (%3):
				           |""%4"".';
				           |en = 'Error while adding a file ""%1"" to volume ""%2"" (%3): 
				           |""%4"".'");
			
			ПодробноеОписаниеВсехОшибок = ПодробноеОписаниеВсехОшибок
				+ СтрШаблон(
					ШаблонОписанияОшибки,
					ИмяФайла,
					Строка(СсылкаНаТом),
					ПутьКТому,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
			КраткоеОписаниеВсехОшибок = КраткоеОписаниеВсехОшибок
				+ СтрШаблон(
					ШаблонОписанияОшибки,
					ИмяФайла,
					Строка(СсылкаНаТом),
					ПутьКТому,
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
			
			// Надо переходить к следующему тому.
			Продолжить;
		КонецПопытки;
		
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запись в журнал регистрации для администратора
	// здесь выдадим ошибки со всех томов.
	ШаблонСообщенияОбОшибке = НСтр("ru = 'Не удалось добавить файл ни в один из томов.
		|Список ошибок:
		|
		|%1';
		|en = 'Failed to add file to any volume.
		|List of errors: %1'");
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Добавление файла'; en = 'Files.Adding file'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка,,,
		СтрШаблон(ШаблонСообщенияОбОшибке, ПодробноеОписаниеВсехОшибок));
	
	Если Пользователи.ЭтоПолноправныйПользователь() Тогда
		СтрокаИсключения = СтрШаблон(ШаблонСообщенияОбОшибке, КраткоеОписаниеВсехОшибок);
	Иначе
		// Сообщение обычному пользователю.
		СтрокаИсключения = СтрШаблон(
			НСтр("ru = 'Не удалось добавить файл:
			           |""%1.%2"".
			           |
			           |Обратитесь к администратору.';
			           |en = 'Failed to add the file:
			           |""%1.%2"". 
			           |
			           |Contact the administrator.'"),
			ИмяБезРасширения, Расширение);
	КонецЕсли;
	
	ВызватьИсключение СтрокаИсключения;

КонецФункции

// Возвращает количество файлов, хранящихся в томах.
Функция КоличествоФайловВТомах()
	
	КоличествоФайловВТомах = 0;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваФайловВТомах");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииКоличестваФайловВТомах(КоличествоФайловВТомах);
	КонецЦикла;
	
	Возврат КоличествоФайловВТомах;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Электронная подпись и шифрование для файлов.

// Управляет видимостью элементов и команд в зависимости от наличия и
// использования электронной подписи и шифрования.
//
Процедура КриптографияПриСозданииФормыНаСервере(Форма, ЭтоФормаСписка = Истина, ТолькоКартинкаСтрок = Ложь) Экспорт
	
	Элементы = Форма.Элементы;
	
	ЭлектронноеПодписание = Ложь;
	Шифрование = Ложь;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись")
	   И Пользователи.РолиДоступны("ДобавлениеИзменениеЭлектронныхПодписейИШифрование")
	   И Не ОбщегоНазначенияКлиентСервер.ЭтоВебКлиентПодMacOS() Тогда
		
		МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
		
		ЭлектронноеПодписание = МодульЭлектроннаяПодпись.ИспользоватьЭлектронныеПодписи();
		Шифрование            = МодульЭлектроннаяПодпись.ИспользоватьШифрование();
	КонецЕсли;
	
	Используется = ЭлектронноеПодписание Или Шифрование;
	
	Если ЭтоФормаСписка Тогда
		Элементы.СписокНомерКартинкиПодписанЗашифрован.Видимость = Используется;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Видимость = Используется;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Видимость = Используется;
		Иначе
			Элементы.ГруппаЭлектронныеПодписи.Видимость = ЭлектронноеПодписание;
			Элементы.ГруппаСертификатыШифрования.Видимость = Шифрование;
			Элементы.ГруппаДополнительныеДанныеСтраницы.ОтображениеСтраниц =
				?(Используется, ОтображениеСтраницФормы.ЗакладкиСверху, ОтображениеСтраницФормы.Нет);
		КонецЕсли;
	КонецЕсли;
	
	Если Не Используется Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодпись.Видимость = ЭлектронноеПодписание;
		Элементы.ФормаГруппаКомандШифрование.Видимость = Шифрование;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодпись.Видимость = ЭлектронноеПодписание;
			Элементы.СписокКонтекстноеМенюГруппаКомандШифрование.Видимость = Шифрование;
		КонецЕсли;
	КонецЕсли;
	
	Если ЭлектронноеПодписание И Шифрование Тогда
		Заголовок = НСтр("ru = 'Электронная подпись и шифрование'; en = 'Digital signature and encryption'");
		Подсказка = НСтр("ru = 'Наличие электронной подписи или шифрования'; en = 'Presence of a digital signature or encryption'");
		Картинка  = БиблиотекаКартинок["ПодписанЗашифрованЗаголовок"];
	ИначеЕсли ЭлектронноеПодписание Тогда
		Заголовок = НСтр("ru = 'Электронная подпись'; en = 'Digital signature'");
		Подсказка = НСтр("ru = 'Наличие электронной подписи'; en = 'Presence of digital signature'");
		Картинка  = БиблиотекаКартинок["ПодписанЭП"];
	Иначе // Шифрование
		Заголовок = НСтр("ru = 'Шифрование'; en = 'Encryption'");
		Подсказка = НСтр("ru = 'Наличие шифрования'; en = 'Presence of encryption'");
		Картинка  = БиблиотекаКартинок["Зашифрован"];
	КонецЕсли;
	
	Если ЭтоФормаСписка Тогда
		Элементы.СписокНомерКартинкиПодписанЗашифрован.КартинкаШапки = Картинка;
		Элементы.СписокНомерКартинкиПодписанЗашифрован.Подсказка = Подсказка;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Заголовок = Заголовок;
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Подсказка = Заголовок;
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Картинка  = Картинка;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Заголовок = Заголовок;
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Подсказка = Заголовок;
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Картинка  = Картинка;
		КонецЕсли;
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		МодульЭлектроннаяПодписьСлужебный = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьСлужебный");
		МодульЭлектроннаяПодписьСлужебный.ОформитьСписокПодписей(Форма, "ЭлектронныеПодписи");
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПеренестиРезультатыПроверкиПодписей(ПодписиВФорме, ПодписиВОбъекте) Экспорт
	
	Если ПодписиВФорме.Количество() <> ПодписиВОбъекте.Количество() Тогда
		Возврат; // Если объект был изменен, результаты проверки не переносятся.
	КонецЕсли;
	
	Если ПодписиВФорме.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Свойства = Новый Структура("ДатаПроверкиПодписи, ПодписьВерна", Null, Null);
	ЗаполнитьЗначенияСвойств(Свойства, ПодписиВОбъекте[0]);
	Если Свойства.ДатаПроверкиПодписи = Null
	 Или Свойства.ПодписьВерна = Null Тогда
		Возврат; // Если в объекте нет реквизитов проверки, результаты проверки не переносятся.
	КонецЕсли;
	
	Для Каждого Строка Из ПодписиВФорме Цикл
		СтрокаВОбъекте = ПодписиВОбъекте.Получить(ПодписиВФорме.Индекс(Строка));
		Если Строка.ДатаПодписи         <> СтрокаВОбъекте.ДатаПодписи
		 Или Строка.Комментарий         <> СтрокаВОбъекте.Комментарий
		 Или Строка.КомуВыданСертификат <> СтрокаВОбъекте.КомуВыданСертификат
		 Или Строка.Отпечаток           <> СтрокаВОбъекте.Отпечаток
		 Или Строка.УстановившийПодпись <> СтрокаВОбъекте.УстановившийПодпись Тогда
			Возврат; // Если объект был изменен, результаты проверки не переносятся.
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Строка Из ПодписиВФорме Цикл
		СтрокаВОбъекте = ПодписиВОбъекте.Получить(ПодписиВФорме.Индекс(Строка));
		ЗаполнитьЗначенияСвойств(Свойства, СтрокаВОбъекте);
		Если Строка.ДатаПроверкиПодписи = Свойства.ДатаПроверкиПодписи
		   И Строка.ПодписьВерна        = Свойства.ПодписьВерна Тогда
			Продолжить; // Не нужно устанавливать модифицированность, если результаты проверки совпадают.
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Свойства, Строка);
		ЗаполнитьЗначенияСвойств(СтрокаВОбъекте, Свойства);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие функции

// Возвращает Истина, если текст из файлов извлекается на сервере, а не на клиенте.
//
// Возвращаемое значение:
//  Булево. Ложь - если текст не извлекается на сервере,
//                 т.е. может и должен быть извлечен на клиенте.
//
Функция ИзвлекатьТекстыФайловНаСервере() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат Константы.ИзвлекатьТекстыФайловНаСервере.Получить();
	
КонецФункции

// Возвращает Истина, если сервер работает под Windows.
Функция ЭтоПлатформаWindows() Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияДокументооборотПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
	 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Получает строку из временного хранилища (передача с клиента на сервер,
// делается через временное хранилище).
//
Функция ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста) Экспорт
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ПолучитьИзВременногоХранилища(АдресВременногоХранилищаТекста).Записать(ИмяВременногоФайла);
	
	ТекстовыйФайл = Новый ЧтениеТекста(ИмяВременногоФайла, КодировкаТекста.UTF8);
	Текст = ТекстовыйФайл.Прочитать();
	ТекстовыйФайл.Закрыть();
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат Текст;
	
КонецФункции

// Служебная функция используется для помещения двоичных данных файла в томе
// в хранилище значения.
//
Функция ПоместитьДвоичныеДанныеВХранилище(Том, ПутьКФайлу, УникальныйИдентификатор) Экспорт
	
	ПолныйПуть = ПолныйПутьТома(Том) + ПутьКФайлу;
	УникальныйИдентификатор = УникальныйИдентификатор;
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
	Возврат Новый ХранилищеЗначения(ДвоичныеДанные);
	
КонецФункции

// Служебная функция используется при создании начального образа.
// Выполняется всегда на сервере.
//
Процедура СкопироватьФайлПриСозданииНачальногоОбраза(ПолныйПуть, НовыйПутьФайла) Экспорт
	
	Попытка
		// Если файл в томе - скопируем его во временный каталог (при создании начального образа).
		КопироватьФайл(ПолныйПуть, НовыйПутьФайла);
		ФайлВременный = Новый Файл(НовыйПутьФайла);
		ФайлВременный.УстановитьТолькоЧтение(Ложь);
	Исключение
		// Не регистрируется, возможно файл не найден.
	КонецПопытки;
	
КонецПроцедуры

// Записывает на сервер результат извлечения текста - извлеченный текст и СтатусИзвлеченияТекста.
Процедура ЗаписатьРезультатИзвлеченияТекста(ФайлИлиВерсияСсылка,
                                            РезультатИзвлечения,
                                            АдресВременногоХранилищаТекста) Экспорт
	
	ФайлИлиВерсияОбъект = ФайлИлиВерсияСсылка.ПолучитьОбъект();
	ФайлИлиВерсияОбъект.Заблокировать();
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Текст = "";
	Иначе
		Текст = ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		ФайлИлиВерсияОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		УдалитьИзВременногоХранилища(АдресВременногоХранилищаТекста);
	КонецЕсли;
	
	Если РезультатИзвлечения = "НеИзвлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	ИначеЕсли РезультатИзвлечения = "Извлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
	ИначеЕсли РезультатИзвлечения = "ИзвлечьНеУдалось" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
	КонецЕсли;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаписиИзвлеченногоТекста(ФайлИлиВерсияОбъект);
	КонецЦикла;
	
КонецПроцедуры

// Получает кодировку текстового файла, указанную пользователем (если есть).
//
// Параметры:
//  ВерсияФайла - ссылка на версию файла.
//
// Возвращаемое значение:
//  Строка - идентификатор кодировки текста или пустая строка.
//
Функция ПолучитьКодировкуВерсииФайла(ВерсияФайла) Экспорт
	
	Кодировка = "";
	ПриОпределенииКодировкиВерсииФайла(ВерсияФайла, Кодировка);
	
	Возврат Кодировка;
	
КонецФункции

Функция СписокРасширенийДляПредпросмотра() Экспорт
	
	// См. также перечисление ФорматКартинки
	РасширенияДляПредпросмотра = Новый СписокЗначений;
	РасширенияДляПредпросмотра.Добавить("bmp");
	РасширенияДляПредпросмотра.Добавить("emf");
	РасширенияДляПредпросмотра.Добавить("gif");
	РасширенияДляПредпросмотра.Добавить("ico");
	РасширенияДляПредпросмотра.Добавить("icon");
	РасширенияДляПредпросмотра.Добавить("jpg");
	РасширенияДляПредпросмотра.Добавить("jpeg");
	РасширенияДляПредпросмотра.Добавить("png");
	РасширенияДляПредпросмотра.Добавить("tiff");
	РасширенияДляПредпросмотра.Добавить("tif");
	РасширенияДляПредпросмотра.Добавить("wmf");
	
	Возврат РасширенияДляПредпросмотра;
	
КонецФункции

Функция СписокЗапрещенныхРасширений() Экспорт
	
	СписокЗапрещенныхРасширений = Новый СписокЗначений;
	СписокЗапрещенныхРасширений.Добавить("ade");
	СписокЗапрещенныхРасширений.Добавить("adp");
	СписокЗапрещенныхРасширений.Добавить("app");
	СписокЗапрещенныхРасширений.Добавить("bas");
	СписокЗапрещенныхРасширений.Добавить("bat");
	СписокЗапрещенныхРасширений.Добавить("chm");
	СписокЗапрещенныхРасширений.Добавить("class");
	СписокЗапрещенныхРасширений.Добавить("cmd");
	СписокЗапрещенныхРасширений.Добавить("com");
	СписокЗапрещенныхРасширений.Добавить("cpl");
	СписокЗапрещенныхРасширений.Добавить("crt");
	СписокЗапрещенныхРасширений.Добавить("dll");
	СписокЗапрещенныхРасширений.Добавить("exe");
	СписокЗапрещенныхРасширений.Добавить("fxp");
	СписокЗапрещенныхРасширений.Добавить("hlp");
	СписокЗапрещенныхРасширений.Добавить("hta");
	СписокЗапрещенныхРасширений.Добавить("ins");
	СписокЗапрещенныхРасширений.Добавить("isp");
	СписокЗапрещенныхРасширений.Добавить("jse");
	СписокЗапрещенныхРасширений.Добавить("js");
	СписокЗапрещенныхРасширений.Добавить("lnk");
	СписокЗапрещенныхРасширений.Добавить("mda");
	СписокЗапрещенныхРасширений.Добавить("mdb");
	СписокЗапрещенныхРасширений.Добавить("mde");
	СписокЗапрещенныхРасширений.Добавить("mdt");
	СписокЗапрещенныхРасширений.Добавить("mdw");
	СписокЗапрещенныхРасширений.Добавить("mdz");
	СписокЗапрещенныхРасширений.Добавить("msc");
	СписокЗапрещенныхРасширений.Добавить("msi");
	СписокЗапрещенныхРасширений.Добавить("msp");
	СписокЗапрещенныхРасширений.Добавить("mst");
	СписокЗапрещенныхРасширений.Добавить("ops");
	СписокЗапрещенныхРасширений.Добавить("pcd");
	СписокЗапрещенныхРасширений.Добавить("pif");
	СписокЗапрещенныхРасширений.Добавить("prf");
	СписокЗапрещенныхРасширений.Добавить("prg");
	СписокЗапрещенныхРасширений.Добавить("reg");
	СписокЗапрещенныхРасширений.Добавить("scf");
	СписокЗапрещенныхРасширений.Добавить("scr");
	СписокЗапрещенныхРасширений.Добавить("sct");
	СписокЗапрещенныхРасширений.Добавить("shb");
	СписокЗапрещенныхРасширений.Добавить("shs");
	СписокЗапрещенныхРасширений.Добавить("url");
	СписокЗапрещенныхРасширений.Добавить("vb");
	СписокЗапрещенныхРасширений.Добавить("vbe");
	СписокЗапрещенныхРасширений.Добавить("vbs");
	СписокЗапрещенныхРасширений.Добавить("wsc");
	СписокЗапрещенныхРасширений.Добавить("wsf");
	СписокЗапрещенныхРасширений.Добавить("wsh");
	
	Возврат СписокЗапрещенныхРасширений;
	
КонецФункции

Функция ПодготовитьСтруктуруПараметровОтправки() Экспорт
	
	Возврат Новый Структура("Получатель,Тема,Текст", Неопределено, "", "");
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов

Функция ФайлРедактируетсяВОблаке(Файл) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл
		|ИЗ
		|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
		|ГДЕ
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл = &Файл";
	
	Запрос.УстановитьПараметр("Файл", Файл);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Возврат Истина;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему.

// См. описание одноименной процедуры в общем модуле РегламентныеЗаданияПереопределяемый.
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Зависимости) Экспорт
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ИзвлечениеТекста;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
		МодульПолнотекстовыйПоискСервер = ОбщегоНазначения.ОбщийМодуль("ПолнотекстовыйПоискСервер");
		Зависимость.ФункциональнаяОпция = МодульПолнотекстовыйПоискСервер.ИспользоватьПолнотекстовыйПоиск();
	КонецЕсли;
	Зависимость.ДоступноВМоделиСервиса = Ложь;
	
	//Зависимость = Зависимости.Добавить();
	//Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ОчисткаНенужныхФайлов;
	//Зависимость.РаботаетСВнешнимиРесурсами = Истина;
	
	//Зависимость = Зависимости.Добавить();
	//Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.СинхронизацияФайлов;
	//Зависимость.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ИспользоватьСинхронизациюФайлов;
	//Зависимость.РаботаетСВнешнимиРесурсами = Истина;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов с облачным сервисом
Процедура ДобавитьДоступныеПоляОтбора(ТекстЗапроса, ТипОбъекта) Экспорт
	
	ВсеСправочники = Справочники.ТипВсеСсылки();
	ВсеДокументы = Документы.ТипВсеСсылки();
	
	Если ВсеСправочники.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
		Справочник = Метаданные.Справочники[ТипОбъекта.Имя];
		Для Каждого Реквизит Из Справочник.Реквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникПапок." + Реквизит.Имя + " КАК " + Реквизит.Имя +",";
		КонецЦикла;
	ИначеЕсли ВсеДокументы.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
		Документ = Метаданные.Документы[ТипОбъекта.Имя];
		Для Каждого Реквизит Из Документ.Реквизиты Цикл
			Если Реквизит.Тип = Новый ОписаниеТипов("Дата") Тогда
				ТекстЗапроса = ТекстЗапроса + Символы.ПС + "РАЗНОСТЬДАТ(" + Реквизит.Имя + ", &ТекущаяДата, ДЕНЬ) Как ДнейДоУдаленияОт" + Реквизит.Имя + ",";
			КонецЕсли;
			ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникПапок." + Реквизит.Имя + ",";
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры
#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики служебных событий подсистем БСП.

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.1.6";
	Обработчик.Процедура = "ФайловыеФункцииСлужебный.ПеренестиКонстантыРасширений";
	
КонецПроцедуры	

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиРаботыСФайлами = ФайловыеФункцииСлужебныйПовтИсп.НастройкиРаботыСФайлами();
	
	Параметры.Вставить("ПерсональныеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		НастройкиРаботыСФайлами.ПерсональныеНастройки));
	
	Параметры.Вставить("ОбщиеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		НастройкиРаботыСФайлами.ОбщиеНастройки));
	
КонецПроцедуры

// Добавляет параметры работы клиентской логики при запуске системы для подсистемы обмена данными в модели сервиса.
//
Процедура ПриДобавленииПараметровРаботыКлиентаПриЗапуске(Параметры) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиРаботыСФайлами = ФайловыеФункцииСлужебныйПовтИсп.НастройкиРаботыСФайлами();
	
	Параметры.Вставить("ПерсональныеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		НастройкиРаботыСФайлами.ПерсональныеНастройки));
	
КонецПроцедуры

// Заполняет перечень запросов внешних разрешений, которые обязательно должны быть предоставлены
// при создании информационной базы или обновлении программы.
//
// Параметры:
//  ЗапросыРазрешений - Массив - список значений, возвращенных функцией.
//                      РаботаВБезопасномРежиме.ЗапросНаИспользованиеВнешнихРесурсов().
//
Процедура ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам(ЗапросыРазрешений) Экспорт
	
	//Если ПолучитьФункциональнуюОпцию("ХранитьФайлыВТомахНаДиске") Тогда
	//	Справочники.ТомаХраненияФайлов.ДобавитьЗапросыНаИспользованиеВнешнихРесурсовВсехТомов(ЗапросыРазрешений);
	//КонецЕсли;
	
КонецПроцедуры

// Заполняет массив типов неразделенных данных, для которых не требуется сопоставление ссылок
// при загрузке данных в другую информационную базу, т.к. корректное сопоставление ссылок
// гарантируется с помощью других механизмов.
//
// Параметры:
//  Типы - Массив(ОбъектМетаданных)
//
Процедура ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	
	// В процессе выгрузки данных ссылки на справочник ТомаХраненияФайлов очищаются,
	// а при загрузке загрузка производится относительно настройки томов в ИБ, в которую
	// производится загрузка, а не относительно настройки томов в ИБ, из которой были
	// выгружены данные.
	Типы.Добавить(Метаданные.Справочники.ТомаХраненияФайлов);
	
КонецПроцедуры

// Содержит настройки размещения вариантов отчетов в панели отчетов.
//
// Параметры:
//   Настройки - Коллекция - Содержит настройки всех отчетов и вариантов конфигурации.
//       Используется для передачи в параметрах вспомогательных методов.
//
// Описание:
//   См. ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//
// Вспомогательные методы:
//   1. Функции ОписаниеОтчета и ОписаниеВарианта формируют описание настроек отчета и варианта для последующего изменения:
//       НастройкиОтчета   = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//       НастройкиВарианта = ВариантыОтчетов.ОписаниеВарианта(Настройки, НастройкиОтчета, "<ИмяВарианта>");
//       Возвращаемые коллекции содержат одинаковый набор свойств.
//       НастройкиОтчета используются как умолчания для вариантов, описания которых еще не получены.
//       Подробнее - см. "свойства для изменения" в комментарии к ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//   2. Процедура УстановитьРежимВыводаВПанеляхОтчетов позволяет настроить режим группировки вариантов в панелях отчетов:
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, НастройкиОтчета, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Отчеты.<ИмяОтчета>, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Подсистемы.<ИмяПодсистемы>, Истина/Ложь);
//   3. Процедура НастроитьОтчетВМодулеМенеджера позволяет переопределять настройки отчета в его модуле менеджера:
//       ВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//
Процедура ПриНастройкеВариантовОтчетов(Настройки) Экспорт
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обмен файлами

// Подготовка параметров и предварительные проверки перед созданием файлового начального образа.
//
Функция ПодготовитьДанныеДляСозданияФайловогоНачальногоОбраза(СтруктураПараметров) Экспорт
	
	Результат = Новый Структура("ДанныеПодготовлены, ТребуетсяПодтверждение, ТекстВопроса", Истина, Ложь, "");
	
	Узел 							= СтруктураПараметров.Узел;
	УникальныйИдентификаторФормы 	= СтруктураПараметров.УникальныйИдентификаторФормы;
	Язык 							= СтруктураПараметров.Язык;
	ПолноеИмяФайловойБазыWindows 	= СтруктураПараметров.ПолноеИмяФайловойБазыWindows;
	ПолноеИмяФайловойБазыLinux 		= СтруктураПараметров.ПолноеИмяФайловойБазыLinux;
	ПутьКАрхивуСФайламиТомовWindows = СтруктураПараметров.ПутьКАрхивуСФайламиТомовWindows;
	ПутьКАрхивуСФайламиТомовLinux 	= СтруктураПараметров.ПутьКАрхивуСФайламиТомовLinux;
	
	ПутьКАрхивуСФайламиТомов = "";
	ПолноеИмяФайловойБазы = "";
	
	ЕстьФайлыВТомах = Ложь;
	
	Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
		ЕстьФайлыВТомах = ЕстьФайлыВТомах();
	КонецЕсли;
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ТипПлатформыСервера = СистемнаяИнфо.ТипПлатформы;
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовWindows;
		ПолноеИмяФайловойБазы = ПолноеИмяФайловойБазыWindows;
		
		ПараметрыРаботыКлиента = СтандартныеПодсистемыВызовСервера.ПараметрыРаботыКлиента();
		Если НЕ ПараметрыРаботыКлиента.ИнформационнаяБазаФайловая Тогда
			Если ЕстьФайлыВТомах И Не ПустаяСтрока(ПутьКАрхивуСФайламиТомов) И (Лев(ПутьКАрхивуСФайламиТомов, 2) <> "\\"
				ИЛИ СтрНайти(ПутьКАрхивуСФайламиТомов, ":") <> 0) Тогда
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к архиву с файлами томов должен быть
					           |в формате UNC (\\servername\resource)'; en = 'The path to the file with the files of volumes must be in UNC format (\\servername\resource)'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;

			КонецЕсли;

			Если Не ПустаяСтрока(ПолноеИмяФайловойБазы) И (Лев(ПолноеИмяФайловойБазы, 2) <> "\\" ИЛИ СтрНайти(ПолноеИмяФайловойБазы, ":") <> 0) Тогда

				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к файловой базе должен быть
					           |в формате UNC (\\servername\resource)'; en = 'File base path must be in UNC format (\\servername\resource)'"),
					,
					"ПолноеИмяФайловойБазыWindows");
				Результат.ДанныеПодготовлены = Ложь;
			КонецЕсли;
		КонецЕсли;

	Иначе
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовLinux;
		ПолноеИмяФайловойБазы = ПолноеИмяФайловойБазыLinux;
	КонецЕсли;
	
	Если ПустаяСтрока(ПолноеИмяФайловойБазы) Тогда

		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			НСтр("ru = 'Укажите полное имя файловой базы (файл 1cv8.1cd)'; en = 'Specify the full name of the file base (file 1cv8.1cd)'"),,
			"ПолноеИмяФайловойБазыWindows");
		Результат.ДанныеПодготовлены = Ложь;
	ИначеЕсли Результат.ДанныеПодготовлены Тогда
		ФайлБазы = Новый Файл(ПолноеИмяФайловойБазы);
		
		Если ЕстьФайлыВТомах Тогда
			Если ПустаяСтрока(ПутьКАрхивуСФайламиТомов) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Укажите полное имя архива с файлами томов (файл *.zip)'; en = 'Specify the full name of the archive with files (*.zip file)'"),, 
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
			Иначе
				Файл = Новый Файл(ПутьКАрхивуСФайламиТомов);
				
				Если Файл.Существует() И ФайлБазы.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файлы ""%1"" и ""%2"" уже существуют.
							           |Заменить существующие файлы?';
							           |en = 'Files ""%1"" and ""%2"" already exists.
							           |Replace the existing files?'"), ПутьКАрхивуСФайламиТомов, ПолноеИмяФайловойБазы);
					Результат.ТребуетсяПодтверждение = Истина;
				ИначеЕсли Файл.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
							           |Заменить существующий файл?';
							           |en = 'The file ""%1"" already exists.
							           |Replace existing file?'"), ПутьКАрхивуСФайламиТомов);
					Результат.ТребуетсяПодтверждение = Истина;
				КонецЕсли;
			КонецЕсли;

		КонецЕсли;
		
		Если Результат.ДанныеПодготовлены Тогда
			Если ФайлБазы.Существует() И НЕ Результат.ТребуетсяПодтверждение Тогда
				Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
						           |Заменить существующий файл?';
						           |en = 'The file ""%1"" already exists.
						           |Replace existing file?'"), ПолноеИмяФайловойБазы);
				Результат.ТребуетсяПодтверждение = Истина;
			КонецЕсли;
			
			// Создать временный каталог.
			ИмяКаталога = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталога);
			
			// Создать временный каталог для файлов.
			ИмяКаталогаФайлов = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталогаФайлов);
			
			// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
			СохранитьНастройку("ОбменФайлами", "ВременныйКаталог", ИмяКаталогаФайлов);
			
			// Добавляем в параметры переменные, которые потребуются для создания начального образа.
			СтруктураПараметров.Вставить("ИмяКаталога", ИмяКаталога);
			СтруктураПараметров.Вставить("ИмяКаталогаФайлов", ИмяКаталогаФайлов);
			СтруктураПараметров.Вставить("ЕстьФайлыВТомах", ЕстьФайлыВТомах);
			СтруктураПараметров.Вставить("ПутьКАрхивуСФайламиТомов", ПутьКАрхивуСФайламиТомов);
			СтруктураПараметров.Вставить("ПолноеИмяФайловойБазы", ПолноеИмяФайловойБазы);
		КонецЕсли;

	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создать файловый начальный образ на сервере. . Запускается регламентным заданием.
//
Процедура СоздатьФайловыйНачальныйОбразНаСервере(Параметры, АдресХранилища) Экспорт
	
	Попытка
		
		СтрокаСоединения = "File=""" + Параметры.ИмяКаталога + """;"
						 + "Locale=""" + Параметры.Язык + """;";
		ПланыОбмена.СоздатьНачальныйОбраз(Параметры.Узел, СтрокаСоединения);  // Собственно создание начального образа.
		
		Если Параметры.ЕстьФайлыВТомах Тогда
			ZIP = Новый ЗаписьZipФайла;
			ZIP.Открыть(Параметры.ПутьКАрхивуСФайламиТомов);
			
			ВременныеФайлы = Новый Массив;
			ВременныеФайлы = НайтиФайлы(Параметры.ИмяКаталогаФайлов, "*.*");
			
			Для Каждого ВременныйФайл Из ВременныеФайлы Цикл
				Если ВременныйФайл.ЭтоФайл() Тогда
					ПутьВременногоФайла = ВременныйФайл.ПолноеИмя;
					ZIP.Добавить(ПутьВременногоФайла);
				КонецЕсли;
			КонецЦикла;
			
			ZIP.Записать();
			
			УдалитьФайлы(Параметры.ИмяКаталогаФайлов); // Удаляем вместе с файлами внутри.
		КонецЕсли;
		
	Исключение
		
		УдалитьФайлы(Параметры.ИмяКаталога);
		ВызватьИсключение;
		
	КонецПопытки;
	
	ПутьВременногоФайлаБазы = Параметры.ИмяКаталога + "\1Cv8.1CD";
	ПереместитьФайл(ПутьВременногоФайлаБазы, Параметры.ПолноеИмяФайловойБазы);
	
	// очистка
	УдалитьФайлы(Параметры.ИмяКаталога);
	
КонецПроцедуры

// Подготовка параметров и предварительные проверки перед созданием серверного начального образа.
//
Функция ПодготовитьДанныеДляСозданияСерверногоНачальногоОбраза(СтруктураПараметров) Экспорт
	
	Результат = Новый Структура("ДанныеПодготовлены, ТребуетсяПодтверждение, ТекстВопроса", Истина, Ложь, "");
	
	Узел 							= СтруктураПараметров.Узел;
	СтрокаСоединения 				= СтруктураПараметров.СтрокаСоединения;
	ПутьКАрхивуСФайламиТомовWindows = СтруктураПараметров.ПутьКАрхивуСФайламиТомовWindows;
	ПутьКАрхивуСФайламиТомовLinux 	= СтруктураПараметров.ПутьКАрхивуСФайламиТомовLinux;
	
	ПутьКАрхивуСФайламиТомов = "";
	ПолноеИмяФайловойБазы = "";
	
	ЕстьФайлыВТомах = Ложь;
	
	Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
		ЕстьФайлыВТомах = ЕстьФайлыВТомах();
	КонецЕсли;
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ТипПлатформыСервера = СистемнаяИнфо.ТипПлатформы;
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовWindows;
		
		Если ЕстьФайлыВТомах Тогда
			Если Не ПустаяСтрока(ПутьКАрхивуСФайламиТомов)
			   И (Лев(ПутьКАрхивуСФайламиТомов, 2) <> "\\"
			 ИЛИ СтрНайти(ПутьКАрхивуСФайламиТомов, ":") <> 0) Тогда
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к архиву с файлами томов должен быть
					           |в формате UNC (\\servername\resource).'; en = 'The path to the file with the files of volumes must be in UNC format (\\servername\resource).'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовLinux;
	КонецЕсли;
	
	Если Результат.ДанныеПодготовлены Тогда
		Если ЕстьФайлыВТомах И ПустаяСтрока(ПутьКАрхивуСФайламиТомов) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Укажите полное имя архива с файлами томов (файл *.zip)'; en = 'Specify the full name of the archive with files (*.zip file)'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
		Иначе
			Если ЕстьФайлыВТомах Тогда
				Файл = Новый Файл(ПутьКАрхивуСФайламиТомов);
				Если Файл.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
							           |Заменить существующий файл?';
							           |en = 'The file ""%1"" already exists. 
							           |Replace existing file?'"), ПутьКАрхивуСФайламиТомов);
					Результат.ТребуетсяПодтверждение = Истина;
				КонецЕсли;
			КонецЕсли;
			
			// Создать временный каталог.
			ИмяКаталога = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталога);
			
			// Создать временный каталог для файлов.
			ИмяКаталогаФайлов = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталогаФайлов);
			
			// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
			СохранитьНастройку("ОбменФайлами", "ВременныйКаталог", ИмяКаталогаФайлов);
			
			// Добавляем в параметры переменные, которые потребуются для создания начального образа.
			СтруктураПараметров.Вставить("ЕстьФайлыВТомах", ЕстьФайлыВТомах);
			СтруктураПараметров.Вставить("ПутьФайла", ПутьКАрхивуСФайламиТомов);
			СтруктураПараметров.Вставить("ИмяКаталога", ИмяКаталога);
			СтруктураПараметров.Вставить("ИмяКаталогаФайлов", ИмяКаталогаФайлов);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создать серверный начальный образ на сервере. Запускается регламентным заданием.
//
Процедура СоздатьСерверныйНачальныйОбразНаСервере(Параметры, АдресРезультата) Экспорт
	
	Попытка
		
		ПланыОбмена.СоздатьНачальныйОбраз(Параметры.Узел, Параметры.СтрокаСоединения);
		
		Если Параметры.ЕстьФайлыВТомах Тогда
			ZIP = Новый ЗаписьZipФайла;
			ПутьZIP = Параметры.ПутьФайла;
			ZIP.Открыть(ПутьZIP);
			
			ВременныеФайлы = Новый Массив;
			ВременныеФайлы = НайтиФайлы(Параметры.ИмяКаталогаФайлов, "*.*");
			
			Для Каждого ВременныйФайл Из ВременныеФайлы Цикл
				Если ВременныйФайл.ЭтоФайл() Тогда
					ПутьВременногоФайла = ВременныйФайл.ПолноеИмя;
					ZIP.Добавить(ПутьВременногоФайла);
				КонецЕсли;
			КонецЦикла;
			
			ZIP.Записать();
			УдалитьФайлы(Параметры.ИмяКаталогаФайлов); // Удаляем вместе с файлами внутри.
		КонецЕсли;
		
	Исключение
		
		УдалитьФайлы(Параметры.ИмяКаталога);
		ВызватьИсключение;
		
	КонецПопытки;
	
	// очистка
	УдалитьФайлы(Параметры.ИмяКаталога);
	
КонецПроцедуры

// Размещает файлы в томах, устанавливая ссылки в ВерсииФайла.
//
Функция ДобавитьФайлыВТома(ПутьКАрхивуWindows, ПутьКАрхивуLinux) Экспорт
	
	ПолноеИмяФайлаZip = "";
	ТипПлатформыСервера = ОбщегоНазначенияДокументооборотПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		ПолноеИмяФайлаZip = ПутьКАрхивуWindows;
	Иначе
		ПолноеИмяФайлаZip = ПутьКАрхивуLinux;
	КонецЕсли;
	
	ИмяКаталога = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(ИмяКаталога);
	
	ZIP = Новый ЧтениеZipФайла(ПолноеИмяФайлаZip);
	ZIP.ИзвлечьВсе(ИмяКаталога, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	
	СоответствиеПутейФайлов = Новый Соответствие;
	
	Для Каждого ZIPЭлемент Из ZIP.Элементы Цикл
		ПолныйПутьФайла = ИмяКаталога + "\" + ZIPЭлемент.Имя;
		УникальныйИдентификатор = ZIPЭлемент.ИмяБезРасширения;
		
		СоответствиеПутейФайлов.Вставить(УникальныйИдентификатор, ПолныйПутьФайла);
	КонецЦикла;
	
	ТипХраненияФайлов = ТипХраненияФайлов();
	ПрисоединяемыеФайлы = Новый Массив;
	НачатьТранзакцию();
	Попытка
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.ФайловыеФункции\ПриДобавленииФайловВТомаПриРазмещении");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриДобавленииФайловВТомаПриРазмещении(
				СоответствиеПутейФайлов, ТипХраненияФайлов, ПрисоединяемыеФайлы);
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
		
	// Очистим регистрацию изменений, которые мы только что сделали.
	Для Каждого ПланОбмена Из Метаданные.ПланыОбмена Цикл
		ИмяПланаОбмена      = ПланОбмена.Имя;
		МенеджерПланаОбмена = ПланыОбмена[ИмяПланаОбмена];
		
		ЭтотУзел = МенеджерПланаОбмена.ЭтотУзел();
		Выборка = МенеджерПланаОбмена.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			ПланОбменаОбъект = Выборка.ПолучитьОбъект();
			Если ПланОбменаОбъект.Ссылка <> ЭтотУзел Тогда
				
				ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
					"СтандартныеПодсистемы.ФайловыеФункции\ПриУдаленииРегистрацииИзменений");
				
				Для каждого Обработчик Из ОбработчикиСобытия Цикл
					Обработчик.Модуль.ПриУдаленииРегистрацииИзменений(
						ПланОбменаОбъект.Ссылка, ПрисоединяемыеФайлы);
				КонецЦикла;
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
КонецФункции

// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
//
Процедура СохранитьНастройку(КлючОбъекта, КлючНастроек, Настройки) 
		
	УстановитьПривилегированныйРежим(Истина);
	ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Настройки);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий.

// Обработчик регламентного задания ИзвлечениеТекста.
// Извлекает текст из файлов на диске.
//
Процедура ИзвлечьТекстИзФайловНаСервере() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ИзвлечениеТекста);
	
	ИзвлечьТекстИзФайлов();
	
КонецПроцедуры

Процедура ИзвлечьТекстИзФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ ЭтоПлатформаWindows() Тогда
		Возврат; // Извлечение текста работает только под Windows.
	КонецЕсли;
	
	ИмяСРасширениемФайла = "";
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Извлечение текста'; en = 'Files.Extracting text'",
		     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		,
		,
		НСтр("ru = 'Начато регламентное извлечения текста'; en = 'Started scheduled text extraction'"));
		
	ИтоговыйТекстЗапроса = "";
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииТекстаЗапросаДляИзвлеченияТекста");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		ТекущийТекстЗапроса = "";
		Обработчик.Модуль.ПриОпределенииТекстаЗапросаДляИзвлеченияТекста(ТекущийТекстЗапроса);
		Если НЕ ПустаяСтрока(ТекущийТекстЗапроса) Тогда
			Если ПустаяСтрока(ИтоговыйТекстЗапроса) Тогда
				ИтоговыйТекстЗапроса = ТекущийТекстЗапроса;
			Иначе
				ИтоговыйТекстЗапроса = ИтоговыйТекстЗапроса + "
					|
					|ОБЪЕДИНИТЬ ВСЕ
					|
					|" + ТекущийТекстЗапроса;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ПустаяСтрока(ИтоговыйТекстЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос(ИтоговыйТекстЗапроса);
	Результат = Запрос.Выполнить();
	
	ТаблицаВыгрузки = Результат.Выгрузить();
	
	Для Каждого Строка Из ТаблицаВыгрузки Цикл
		
		ФайлОбъект = Строка.Ссылка.ПолучитьОбъект();
		Попытка
			ФайлОбъект.Заблокировать();
		Исключение
			// Заблокированные файлы будут обработаны в следующий раз.
			Продолжить;
		КонецПопытки;
		
		ИмяСРасширениемФайла = ФайлОбъект.Наименование + "." + ФайлОбъект.Расширение;
		ИмяФайлаСПутем = "";
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииИмениФайлаСПутемКДвоичнымДанным");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриОпределенииИмениФайлаСПутемКДвоичнымДанным(
				ФайлОбъект.Ссылка, ИмяФайлаСПутем, Истина);
		КонецЦикла;
		
		Кодировка = ПолучитьКодировкуВерсииФайла(Строка.Ссылка);
		
		Отказ = Ложь;
		Если ПустаяСтрока(ИмяФайлаСПутем) Тогда
			Отказ = Истина;
			Текст = "";
		Иначе
			Текст = ФайловыеФункцииСлужебныйКлиентСервер.ИзвлечьТекст(ИмяФайлаСПутем, Отказ, Кодировка);
		КонецЕсли;
		
		Если Отказ = Ложь Тогда
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		Иначе
			// Если текст некому извлечь это не ошибка, а нормальный случай.
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
		КонецЕсли;
			
		Если Строка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе
		   И Не ПустаяСтрока(ИмяФайлаСПутем) Тогда
			
			УдалитьФайлы(ИмяФайлаСПутем);
		КонецЕсли;
		
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст, Новый СжатиеДанных);
		
		Попытка
			ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
				"СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
			
			Для каждого Обработчик Из ОбработчикиСобытия Цикл
				Обработчик.Модуль.ПриЗаписиИзвлеченногоТекста(ФайлОбъект);
			КонецЦикла;
		Исключение
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Файлы.Извлечение текста'; en = 'Files.Extracting text'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				СтрШаблон(
					НСтр("ru = 'Во время регламентного извлечения текста из файла
					           |""%1""
					           |произошла ошибка:
					           |""%2"".';
					           |en = 'During scheduled job of extracting text from file
					           |""%1""
					           |and error occurred:
					           |""%2"".'"),
					ИмяСРасширениемФайла,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ));
		КонецПопытки;
		
	КонецЦикла;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Извлечение текста'; en = 'Files.Extracting text'",
		     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		,
		,
		НСтр("ru = 'Закончено регламентное извлечение текста'; en = 'Finished scheduled text extraction'"));
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Перенести константы СписокЗапрещенныхРасширений и СписокРасширенийФайловOpenDocument.
Процедура ПеренестиКонстантыРасширений() Экспорт
	
КонецПроцедуры	

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Дополняет структуру, содержащую общие и персональные настройки по работе с файлами.
Процедура ПриДобавленииНастроекРаботыСФайлами(ОбщиеНастройки, ПерсональныеНастройки) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		МодульРаботаСФайламиСлужебныйВызовСервера.ДобавитьНастройкиРаботыСФайлами(ОбщиеНастройки, ПерсональныеНастройки);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПриСохраненииНастроекРаботыСФайлами(КлючиОбъектовНастроекРаботыСФайлами) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		МодульРаботаСФайламиСлужебный.ПриСохраненииНастроекРаботыСФайлами(КлючиОбъектовНастроекРаботыСФайлами);
	КонецЕсли;
	
КонецПроцедуры

// Вычисляет объем файлов тома в байтах, результат возвращается в параметр РазмерФайлов.
Процедура ПриОпределенииРазмераФайловНаТоме(СсылкаТома, РазмерФайлов) Экспорт
	
	РазмерФайлов = 0;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		РазмерФайлов = РазмерФайлов + МодульРаботаСФайламиСлужебныйВызовСервера.ПодсчитатьРазмерФайловНаТоме(СсылкаТома);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		РазмерФайлов = РазмерФайлов + МодульПрисоединенныеФайлыСлужебный.ПодсчитатьРазмерФайловНаТоме(СсылкаТома);
	КонецЕсли;
	
КонецПроцедуры

// Читает кодировку версии файла.
//
// Параметры:
// ВерсияСсылка - ссылка на версию файла.
//
// Возвращаемое значение:
//   Строка кодировки
Процедура ПриОпределенииКодировкиВерсииФайла(ВерсияСсылка, Кодировка)
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		Кодировка = МодульРаботаСФайламиСлужебныйВызовСервера.ПолучитьКодировкуВерсииФайла(ВерсияСсылка);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Сканирование

Функция ПараметрыСканераВПеречисления(РазрешениеЧисло, ЦветностьЧисло, ПоворотЧисло, РазмерБумагиЧисло) Экспорт 
	
	Если РазрешениеЧисло = 200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi200;
	ИначеЕсли РазрешениеЧисло = 300 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi300;
	ИначеЕсли РазрешениеЧисло = 600 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi600;
	ИначеЕсли РазрешениеЧисло = 1200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi1200;
	КонецЕсли;
	
	Если ЦветностьЧисло = 0 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Монохромное;
	ИначеЕсли ЦветностьЧисло = 1 Тогда
		Цветность = Перечисления.ЦветностиИзображения.ГрадацииСерого;
	ИначеЕсли ЦветностьЧисло = 2 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Цветное;
	КонецЕсли;
	
	Если ПоворотЧисло = 0 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.НетПоворота;
	ИначеЕсли ПоворотЧисло = 90 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа90;
	ИначеЕсли ПоворотЧисло = 180 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа180;
	ИначеЕсли ПоворотЧисло = 270 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВлевоНа90;
	КонецЕсли;
	
	Если РазмерБумагиЧисло = 0 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.НеЗадано;
	ИначеЕсли РазмерБумагиЧисло = 11 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A3;
	ИначеЕсли РазмерБумагиЧисло = 1 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A4;
	ИначеЕсли РазмерБумагиЧисло = 5 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A5;
	ИначеЕсли РазмерБумагиЧисло = 6 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B4;
	ИначеЕсли РазмерБумагиЧисло = 2 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B5;
	ИначеЕсли РазмерБумагиЧисло = 7 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B6;
	ИначеЕсли РазмерБумагиЧисло = 14 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C4;
	ИначеЕсли РазмерБумагиЧисло = 15 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C5;
	ИначеЕсли РазмерБумагиЧисло = 16 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C6;
	ИначеЕсли РазмерБумагиЧисло = 3 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLetter;
	ИначеЕсли РазмерБумагиЧисло = 4 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLegal;
	ИначеЕсли РазмерБумагиЧисло = 10 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USExecutive;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Разрешение", Разрешение);
	Результат.Вставить("Цветность", Цветность);
	Результат.Вставить("Поворот", Поворот);
	Результат.Вставить("РазмерБумаги", РазмерБумаги);
	Возврат Результат;
	
КонецФункции

#КонецОбласти
